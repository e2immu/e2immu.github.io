<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bart Naudts on </title>
    <link>https://www.e2immu.org/contributors/bart-naudts/</link>
    <description>Recent content in Bart Naudts on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Tue, 06 Oct 2020 08:50:45 +0000</lastBuildDate><atom:link href="https://www.e2immu.org/contributors/bart-naudts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Updated &#39;Road to Immutability&#39;</title>
      <link>https://www.e2immu.org/blog/updated-road-to-immutability/</link>
      <pubDate>Thu, 26 Aug 2021 00:00:00 +0100</pubDate>
      
      <guid>https://www.e2immu.org/blog/updated-road-to-immutability/</guid>
      <description>Section 11 of The Road to Immutability, now titled &amp;lsquo;Immutable Content&amp;rsquo;, has been completely revised. The names &amp;lsquo;implicitly immutable content&amp;rsquo; and &amp;lsquo;support data&amp;rsquo; have been dropped, in favour of the more prosaic modifiable and immutable content of a level 2 immutable type. Their definitions are now more obvious. Section 8, &amp;lsquo;Level 2 Immutability&amp;rsquo;, has been updated accordingly, and has been expanded to explain better how extending types influences immutability.
The changes to the document need to be reflected in the analyser.</description>
    </item>
    
    <item>
      <title>Introducing e2immu</title>
      <link>https://www.e2immu.org/blog/introducing-e2immu/</link>
      <pubDate>Thu, 01 Apr 2021 09:19:42 +0100</pubDate>
      
      <guid>https://www.e2immu.org/blog/introducing-e2immu/</guid>
      <description>Hello there! After 16 months of near full-time development, I&amp;rsquo;m proud to announce that e2immu is now public on GitHub as an open source project.
e2immu is a static code analyser for Java. There&amp;rsquo;s a few analysers around already, but this one focuses strongly on modification and immutability: determining when and where the data of an object gets modified, and ensuring that, after some initialisation phase, the content of certain objects can never be changed again.</description>
    </item>
    
    <item>
      <title>Variable versus value</title>
      <link>https://www.e2immu.org/blog/variable-versus-value/</link>
      <pubDate>Wed, 07 Jul 2021 00:00:00 +0100</pubDate>
      
      <guid>https://www.e2immu.org/blog/variable-versus-value/</guid>
      <description>Sometimes I make intuitive decisions, which turn out to have a large impact on further development. By nature, these decisions are not well documented! So when I get stuck a couple of months later, I start questioning why this decision was made, cannot find a good reason, try to undo it, get stuck, and then, seeing both approaches in new light, can finally make a decision on whether the intuition was good or not.</description>
    </item>
    
    <item>
      <title>Java 17&#39;s sealed classes and the Immutables project</title>
      <link>https://www.e2immu.org/blog/java-17s-sealed-classes-and-the-immutables-project/</link>
      <pubDate>Thu, 13 May 2021 00:00:00 +0100</pubDate>
      
      <guid>https://www.e2immu.org/blog/java-17s-sealed-classes-and-the-immutables-project/</guid>
      <description>The concept of sealed classes, as described in JEPS-409, allows you to fully control sub-classing, by enumerating the possible sub-types explicitly. It goes beyond the final modifier for classes, which simply_prohibits_ sub-classing.
My first reaction to sealed classes was so what?. Probably nothing I&amp;rsquo;d ever make use of. However, studying how to integrate the builders and immutable types generated by the Immutables project, I came across an obvious use case of sealed classes!</description>
    </item>
    
    <item>
      <title>Control flow analysis in e2immu</title>
      <link>https://www.e2immu.org/blog/control-flow-analysis-in-e2immu/</link>
      <pubDate>Thu, 24 Jun 2021 00:00:00 +0100</pubDate>
      
      <guid>https://www.e2immu.org/blog/control-flow-analysis-in-e2immu/</guid>
      <description>e2immu&amp;rsquo;s representation of statements in a method block is very traditional: after parsing the code with JavaParser, the Resolver&amp;rsquo;s doBlock method converts JavaParser&amp;rsquo;s BlockStmt into an e2immu Block. This Block is fully resolved (all variable names and method references are fully known &amp;ndash; JavaParser calls this phase symbol solving) and now available in the MethodInspection. The conversion code resides in ExpressionContext and its helper classes, such as ParseMethodCallExpr. e2immu does not use JavaParser&amp;rsquo;s symbol solving, for the simple reason that I wanted to learn how to do so myself.</description>
    </item>
    
    <item>
      <title>LAST_READ edges for an AST graph</title>
      <link>https://www.e2immu.org/blog/last_read-edges-for-an-ast-graph/</link>
      <pubDate>Thu, 01 Jul 2021 00:00:00 +0100</pubDate>
      
      <guid>https://www.e2immu.org/blog/last_read-edges-for-an-ast-graph/</guid>
      <description>Question: How can I add LAST_READ edges to an abstract syntax tree (AST)? LAST_READ connects a node representing a usage of a variable to all nodes in the AST at which that variableâ€™s value could have been last read from memory.
I will try to answer this question at the level of variables read in the different statements of a method, rather than at level of fields accessed in different methods.</description>
    </item>
    
  </channel>
</rss>
