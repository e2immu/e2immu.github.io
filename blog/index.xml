<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on</title><link>https://www.e2immu.org/blog/</link><description>Recent content in Blog on</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><lastBuildDate>Tue, 06 Oct 2020 08:49:55 +0000</lastBuildDate><atom:link href="https://www.e2immu.org/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Introducing e2immu</title><link>https://www.e2immu.org/blog/introducing-e2immu/</link><pubDate>Thu, 01 Apr 2021 09:19:42 +0100</pubDate><guid>https://www.e2immu.org/blog/introducing-e2immu/</guid><description>Hello there! After 16 months of near full-time development, I&amp;rsquo;m proud to announce that e2immu is now public on GitHub as an open source project.
e2immu is a static code analyser for Java. There&amp;rsquo;s a few analysers around already, but this one focuses strongly on modification and immutability: determining when and where the data of an object gets modified, and ensuring that, after some initialisation phase, the content of certain objects can never be changed again.</description></item><item><title>Java 17's sealed classes and the Immutables project</title><link>https://www.e2immu.org/blog/java-17s-sealed-classes-and-the-immutables-project/</link><pubDate>Thu, 13 May 2021 00:00:00 +0100</pubDate><guid>https://www.e2immu.org/blog/java-17s-sealed-classes-and-the-immutables-project/</guid><description>The concept of sealed classes, as described in JEPS-409, allows you to fully control sub-classing, by enumerating the possible sub-types explicitly. It goes beyond the final modifier for classes, which simply_prohibits_ sub-classing.
My first reaction to sealed classes was so what?. Probably nothing I&amp;rsquo;d ever make use of. However, studying how to integrate the builders and immutable types generated by the Immutables project, I came across an obvious use case of sealed classes!</description></item><item><title>Control flow analysis in e2immu</title><link>https://www.e2immu.org/blog/control-flow-analysis-in-e2immu/</link><pubDate>Thu, 24 Jun 2021 00:00:00 +0100</pubDate><guid>https://www.e2immu.org/blog/control-flow-analysis-in-e2immu/</guid><description>e2immu&amp;rsquo;s representation of statements in a method block is very traditional: after parsing the code with JavaParser, the Resolver&amp;rsquo;s doBlock method converts JavaParser&amp;rsquo;s BlockStmt into an e2immu Block. This Block is fully resolved (all variable names and method references are fully known &amp;ndash; JavaParser calls this phase symbol solving) and now available in the MethodInspection. The conversion code resides in ExpressionContext and its helper classes, such as ParseMethodCallExpr. e2immu does not use JavaParser&amp;rsquo;s symbol solving, for the simple reason that I wanted to learn how to do so myself.</description></item><item><title>LAST_READ edges for an AST graph</title><link>https://www.e2immu.org/blog/last_read-edges-for-an-ast-graph/</link><pubDate>Thu, 01 Jul 2021 00:00:00 +0100</pubDate><guid>https://www.e2immu.org/blog/last_read-edges-for-an-ast-graph/</guid><description>Question: How can I add LAST_READ edges to an abstract syntax tree (AST)? LAST_READ connects a node representing a usage of a variable to all nodes in the AST at which that variableâ€™s value could have been last read from memory.
I will try to answer this question at the level of variables read in the different statements of a method, rather than at level of fields accessed in different methods.</description></item></channel></rss>