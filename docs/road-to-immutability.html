<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="description" content="A walk-through of the concepts and definitions of _e2immu_">
<meta name="author" content="Bart Naudts &lt;bart.naudts@e2immu.org&gt;">
<title>The Road to Immutability</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>The Road to Immutability</h1>
<div class="details">
<span id="author" class="author">Bart Naudts &lt;bart.naudts@e2immu.org&gt;</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_dedication">Dedication</a></li>
<li><a href="#_introduction">1. Introduction</a></li>
<li><a href="#assumptions">2. Assumptions</a></li>
<li><a href="#_the_purpose_of_annotations">3. The purpose of annotations</a></li>
<li><a href="#_level_1_immutability">4. Level 1 immutability</a></li>
<li><a href="#modification">5. Modification</a></li>
<li><a href="#containers">6. Containers</a></li>
<li><a href="#linking-and-independence">7. Linking, independence</a></li>
<li><a href="#accessible-hidden-content">8. Accessible and hidden content</a></li>
<li><a href="#_level_2_immutability">9. Level 2 immutability</a>
<ul class="sectlevel2">
<li><a href="#_definition_and_examples">9.1. Definition and examples</a></li>
<li><a href="#inheritance">9.2. Inheritance</a></li>
<li><a href="#generics">9.3. Generics</a></li>
<li><a href="#abstract-methods">9.4. Abstract methods</a></li>
<li><a href="#static-side-effects">9.5. Static side effects</a></li>
<li><a href="#value-based-classes">9.6. Value-based classes</a></li>
<li><a href="#dynamic-type-annotations">9.7. Dynamic type annotations</a></li>
</ul>
</li>
<li><a href="#eventual-immutability">10. Eventual immutability</a>
<ul class="sectlevel2">
<li><a href="#_builders">10.1. Builders</a></li>
<li><a href="#_definition">10.2. Definition</a></li>
<li><a href="#_propagation">10.3. Propagation</a></li>
<li><a href="#_before_the_mark">10.4. Before the mark</a></li>
<li><a href="#_extensions_of_annotations">10.5. Extensions of annotations</a></li>
<li><a href="#_frameworks_and_contracts">10.6. Frameworks and contracts</a></li>
</ul>
</li>
<li><a href="#modification-part2">11. Modification, part 2</a>
<ul class="sectlevel2">
<li><a href="#_cyclic_references">11.1. Cyclic references</a></li>
<li><a href="#computing-dependence">11.2. How to compute linking</a></li>
<li><a href="#_locally_implemented_abstract_methods">11.3. Locally implemented abstract methods</a></li>
</ul>
</li>
<li><a href="#hidden-content">12. Hidden content</a>
<ul class="sectlevel2">
<li><a href="#_visitors">12.1. Visitors</a></li>
<li><a href="#_modifiable_vs_immutable_content">12.2. Modifiable vs immutable content</a></li>
<li><a href="#_deeply_immutable_types">12.3. Deeply immutable types</a></li>
<li><a href="#_propagating_modifications">12.4. Propagating modifications</a></li>
<li><a href="#immutable-content-linking">12.5. Immutable content linking</a></li>
<li><a href="#_iterator_iterable_loops">12.6. Iterator, Iterable, loops</a></li>
<li><a href="#independent-type">12.7. Independence of types</a></li>
<li><a href="#_immutable_content_and_eventual_immutability">12.8. Immutable content and eventual immutability</a></li>
</ul>
</li>
<li><a href="#support-classes">13. Support classes</a>
<ul class="sectlevel2">
<li><a href="#support-flipswitch">13.1. FlipSwitch</a></li>
<li><a href="#support-setonce">13.2. SetOnce</a></li>
<li><a href="#support-eventuallyfinal">13.3. EventuallyFinal</a></li>
<li><a href="#support-freezable">13.4. Freezable</a></li>
<li><a href="#support-setoncemap">13.5. SetOnceMap</a></li>
<li><a href="#support-lazy">13.6. Lazy</a></li>
<li><a href="#support-firstthen">13.7. FirstThen</a></li>
<li><a href="#in-the-analyser">13.8. Support classes in the analyser</a></li>
</ul>
</li>
<li><a href="#_other_annotations">14. Other annotations</a>
<ul class="sectlevel2">
<li><a href="#nullable-section">14.1. Nullable, not null</a></li>
<li><a href="#identity-and-fluent">14.2. Identity and fluent methods</a></li>
<li><a href="#finalizers">14.3. Finalizers</a></li>
<li><a href="#_utility_classes">14.4. Utility classes</a></li>
<li><a href="#_extension_classes">14.5. Extension classes</a></li>
<li><a href="#singleton-classes">14.6. Singleton classes</a></li>
</ul>
</li>
<li><a href="#preconditions-and-instance-state">15. Preconditions and instance state</a></li>
<li><a href="#_copyright_and_license">16. Copyright and License</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Effective and eventual immutability with <em>e2immu</em>, a static code analyser for Java.</p>
</div>
<div class="paragraph">
<p>Main website: <a href="https://www.e2immu.org" class="bare">https://www.e2immu.org</a>.
Third major iteration, beginning of October 2021.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dedication">Dedication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This work is dedicated to those who have had, or are still having, a difficult pandemic.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction">1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This document aims to be a logical walk through of the concepts of the  <em>e2immu</em>  project.
It does not intend to be complete, and is not structured for reference.</p>
</div>
<div class="paragraph">
<p>The overarching aim of the  <em>e2immu</em>  project is to improve every day programming by making code more readable, more robust, and more future-proof.
More concretely, the project focuses on adding various forms of immutability protections to your Java code base, by making the immutable nature of the types more visible.</p>
</div>
<div class="paragraph">
<p><em>Why Java?</em> As a widely used object-oriented programming language, it has evolved over the years, and it has been increasingly equipped with functional programming machinery.
It is therefore possible to write Java code in different styles, from overly object oriented to almost fully functional.
Combine this with lots of legacy code, both in house and in libraries, and many large software projects will end up mixing styles a lot.
This adds to the complexity of understanding and maintaining the code base.</p>
</div>
<div class="paragraph">
<p><em>Why immutability?</em> An important aspect of understanding the code of large software projects is to try to assess the <em>object lifecycle</em> of the data it manages: when and how are these objects modified?
In object-oriented programming, full of public getters and setters, objects can be modified all the time.
In many a functional set-up, objects are immutable but new immutable versions pop up all the time.
Java allows for the whole scala from object-oriented to functional, and the whole ecosystem reflects this choice.</p>
</div>
<div class="paragraph">
<p>An easy way to envisage the life cycle of an object is to assume that it consists of a building phase, followed by an immutable phase.
We set out to show that there are different forms of immutability, from very strict deep immutability to weak guarantees of non-modification, that can be made visible in the code.
We believe that code complexity can be greatly reduced when the software engineer is permanently aware of the modification state of objects.</p>
</div>
<div class="paragraph">
<p>The  <em>e2immu</em>  project consists of a set of definitions, a static code analyser to compute and enforce rules and definitions, and IDE support to visualize the results without cluttering.
Using  <em>e2immu</em>  in your project will help to maintain higher coding standards, the ultimate beneficiary being code that will survive longer.</p>
</div>
<div class="paragraph">
<p>A <em>lack of references to academic literature</em> in this version of the document is explained by the fact that this is my first foray into the world of static code analysers, and theory of software engineering and programming languages.
Academically coming from the theory of machine learning, I spent a decade and a half writing software and managing teams of software engineers.
This work builds on that practical experience alone.
I did not consult or research the literature, and I realise I may be duplicating quite a lot here.
I only want to mention JetBrain&#8217;s brilliant <a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">IntelliJ IDEA</a>, which acts as my gold standard.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="assumptions">2. Assumptions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We discuss the Java language, version 8 and higher.
We have already indicated that we believe that Java offers too much freedom to programmers.
In this section, we impose some limits that are not critical to the substance of the discussion, but facilitate reasoning.
Think of them as low-hanging fruit programming guidelines:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Exceptions do not belong to the normal programming flow; they are meant to raise situations that the program does not want to deal with.</p>
</li>
<li>
<p>Parameters of a method cannot be assigned; we act as if they always have the <code>final</code> modifier.
The simple way around is to create a new local variable, and assign the parameter to it.</p>
</li>
<li>
<p>We make no distinction between the various non-private access modifiers (package-private, protected, public).
Either a field, method or type is private, or it is not.</p>
</li>
<li>
<p>Static fields can only be used for non-constant purposes in very limited circumstances; one example is a variable to check enforce a singleton.
The whole topic of using statics to access thread-local variables is outside the scope of  <em>e2immu</em>  at the moment.</p>
</li>
<li>
<p>Methods must be static if they do not access non-static fields, and do not implement or overload some interface or class method.</p>
</li>
<li>
<p>Synchronization is orthogonal to the data of the program; whilst it may have an influence on <em>when</em> certain code runs, it should not be used to influence the semantics of the code.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The  <em>e2immu</em>  code analyser warns for many other doubtful practices, as detailed in the user manual.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_purpose_of_annotations">3. The purpose of annotations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this document we will add many annotations to the code fragments shown.
We are acutely aware annotations clutter the code and can make it less readable.
Some IDEs, however, like JetBrains' IntelliJ IDEA, have extensive support to make working with annotations visually pleasing.</p>
</div>
<div class="paragraph">
<p>The  <em>e2immu</em>  code analyser computes almost all the annotations that we add to the code fragments in this document.
The complementary IDE plugin uses them to color code types, methods and fields.
Except when the annotations act as a contract, in interfaces, they do not have to be present in your code.</p>
</div>
<div class="paragraph">
<p>Explicitly adding the annotations to classes can be helpful during software development, however.
Say you intend for a class to be immutable, then you can add the corresponding annotation to the type.
Each time the code analyser runs, and the computation finds the type is not immutable, it will raise an error.</p>
</div>
<div class="paragraph">
<p>Explicit annotations also act as a safe-guard against the changing of semantics by overriding methods.
Making the method <code>final</code>, or the type <code>final</code>, merely <em>prohibits</em> overriding, which is typically too strong a mechanism.</p>
</div>
<div class="paragraph">
<p>The final situation where explicit annotations in the code are important, is for the development of the analyser.
We add them to the code as a means of verification: the analyser will check if it generates the same annotation at that location.
Some annotations, like <code>@Linked</code> and <code>@Constant</code>, serve no other purpose than debugging.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_level_1_immutability">4. Level 1 immutability</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let us start with a definition:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition</strong>: We say a field is <strong>effectively final</strong> when it either has the modifier <code>final</code>, or it is not assigned to in methods that can be transitively called from non-private (non-constructor) methods.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The analyser annotates with  <code>@Final</code>  in the latter case; there is no point in cluttering with an annotation when the modifier is already there.
It annotates fields that are not effectively final with  <code>@Variable</code> .</p>
</div>
<div class="paragraph">
<p>This definition allows effectively final fields to be assigned in methods accessible only from the constructor:</p>
</div>
<div class="listingblock">
<div class="title">Example 1, effectively final, but not with the <code>final</code> modifier</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">EffectivelyFinal1</span> {
    <span class="annotation">@Final</span>
    <span class="directive">private</span> <span class="predefined-type">Random</span> random;

    <span class="directive">public</span> EffectivelyFinal1() {
        initialize(<span class="integer">3L</span>);
    }

    <span class="directive">private</span> <span class="type">void</span> initialize(<span class="type">long</span> seed) {
        random = <span class="keyword">new</span> <span class="predefined-type">Random</span>(seed);
    }

    <span class="comment">// no methods access initialize()</span>

    <span class="directive">public</span> <span class="type">int</span> nextInt() {
        <span class="keyword">return</span> random.nextInt();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Obviously, if the same method is also accessible after construction, the field becomes variable:</p>
</div>
<div class="listingblock">
<div class="title">Example 2, the method setting the field is accessible after construction</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">EffectivelyFinal2</span> {
    <span class="annotation">@Variable</span>
    <span class="directive">private</span> <span class="predefined-type">Random</span> random;

    <span class="directive">public</span> EffectivelyFinal2() {
        reset();
    }

    <span class="directive">public</span> <span class="type">void</span> reset() {
        initialize(<span class="integer">3L</span>);
    }

    <span class="directive">private</span> <span class="type">void</span> initialize(<span class="type">long</span> seed) {
        random = <span class="keyword">new</span> <span class="predefined-type">Random</span>(seed);
    }

    <span class="directive">public</span> <span class="type">int</span> nextInt() {
        <span class="keyword">return</span> random.nextInt();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that it is perfectly possible to rewrite the first example in such a way that the <code>final</code> modifier can be used.
From the point of view of the analyser, this does not matter.
The wider definition will allow for more situations to be recognized for what they really are.</p>
</div>
<div class="paragraph">
<p>When an object consists solely of primitives, or deeply immutable objects such as <code>java.lang.String</code>, having all fields effectively final is sufficient to generate an object that is again deeply immutable.</p>
</div>
<div class="listingblock">
<div class="title">Example 3, an object consisting of primitives and a string.<a id="deeply-immutable1"></a></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">DeeplyImmutable1</span> {
    <span class="directive">public</span> <span class="directive">final</span> <span class="type">int</span> x;
    <span class="directive">public</span> <span class="directive">final</span> <span class="type">int</span> y;
    <span class="directive">public</span> <span class="directive">final</span> <span class="predefined-type">String</span> message;

    <span class="directive">public</span> DeeplyImmutable1(<span class="type">int</span> x, <span class="type">int</span> y, <span class="predefined-type">String</span> message) {
        <span class="local-variable">this</span>.message = message;
        <span class="local-variable">this</span>.x = x;
        <span class="local-variable">this</span>.y = y;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example 4, another way of being effectively final</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">DeeplyImmutable2</span> {
    <span class="annotation">@Final</span>
    <span class="directive">private</span> <span class="type">int</span> x;
    <span class="annotation">@Final</span>
    <span class="directive">private</span> <span class="type">int</span> y;
    <span class="annotation">@Final</span>
    <span class="directive">private</span> <span class="predefined-type">String</span> message;

    <span class="directive">public</span> DeeplyImmutable2(<span class="type">int</span> x, <span class="type">int</span> y, <span class="predefined-type">String</span> message) {
        <span class="local-variable">this</span>.message = message;
        <span class="local-variable">this</span>.x = x;
        <span class="local-variable">this</span>.y = y;
    }

    <span class="directive">public</span> <span class="predefined-type">String</span> getMessage() {
        <span class="keyword">return</span> message;
    }

    <span class="directive">public</span> <span class="type">int</span> getX() {
        <span class="keyword">return</span> x;
    }

    <span class="directive">public</span> <span class="type">int</span> getY() {
        <span class="keyword">return</span> y;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Examples 3 and 4 are functionally equivalent: there is no way of changing the values of the fields once they have been set.
In the real world there may be a reason why someone requires the getters.
Or, you may be given code as in Example 2, but you are not allowed to change it.
Whatever the reason, the analyser should recognize effective finality.</p>
</div>
<div class="paragraph">
<p>Note that we will not make a distinction between any of the different non-private access modes in Java.
Only the private modifier gives sufficient guarantees that no reassignment to the fields is possible.</p>
</div>
<div class="paragraph">
<p>We now have observed that for the purpose of defining immutability, having all your fields effectively final can be sufficient in certain circumstances.
We use this as the basis for the first level of immutability:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition</strong>: We call a type <strong>effectively level 1 immutable</strong> when all its fields are effectively final.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The analyser annotates level 1 immutable types with  <code>@E1Immutable</code> .
Types that are not  <code>@E1Immutable</code>  because they have at least one  <code>@Variable</code>  field, are annotated either  <code>@MutableModifiesArguments</code>  or  <code>@Container</code> , depending on properties of the methods' parameters to be explained later.</p>
</div>
<div class="paragraph">
<p>Note that as of more recent versions of Java, the <code>record</code> type enforces explicitly final fields, along with additional support for equality and visibility.
Any <code>record</code> will be at least  <code>@E1Immutable</code> .</p>
</div>
<div class="paragraph">
<p>As above with effective finality, the term <em>effective</em> is present to make a distinction between formal immutability, and immutability that the analyser computes.
It will also serve to distinguish from <em>eventual</em> immutability, where (in this case) the finality will be achieved only after the code reaches a certain state.
More on this later, but here is a first example of an eventually level 1 immutable type:</p>
</div>
<div class="listingblock">
<div class="title">Example 5, simplified version of <code>SetOnce</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E1Immutable</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
<span class="type">class</span> <span class="class">SetOnce</span>&lt;T&gt; {
    <span class="directive">private</span> T t;

    <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">void</span> set(T t) {
        <span class="keyword">if</span>(t == <span class="predefined-constant">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">NullPointerException</span>();
        <span class="keyword">if</span>(<span class="local-variable">this</span>.t != <span class="predefined-constant">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Already set</span><span class="delimiter">&quot;</span></span>);
        <span class="local-variable">this</span>.t = t;
    }

    <span class="annotation">@Only</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">void</span> get() {
        <span class="keyword">if</span>(<span class="local-variable">this</span>.t == <span class="predefined-constant">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Not yet set</span><span class="delimiter">&quot;</span></span>);
        <span class="keyword">return</span> <span class="local-variable">this</span>.t;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once a value has been set, the field <code>t</code> cannot be assigned anymore.</p>
</div>
<div class="paragraph">
<p>We have just observed that if one restricts to primitives and types like <code>java.lang.String</code>, level 1 immutability is sufficient to guarantee deep immutability.
It is not feasible, and we do not wish to, work only with deeply immutable objects.
Moreover, it is easy to see that level 1 immutability is not enough to guarantee what we intuitively may think immutability stands for:</p>
</div>
<div class="listingblock">
<div class="title">Example 6, level 1 immutability does not guarantee intuitive immutability</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E1Immutable</span>
<span class="type">class</span> <span class="class">StringsInArray</span> {
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span><span class="type">[]</span> data;
    <span class="directive">public</span> StringsInArray(<span class="predefined-type">String</span><span class="type">[]</span> strings) {
        <span class="local-variable">this</span>.data = strings;
    }
    <span class="directive">public</span> <span class="predefined-type">String</span> getFirst() {
        <span class="keyword">return</span> data[<span class="integer">0</span>];
    }
}

...
String<span class="type">[]</span> strings = { <span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span> };
StringsInArray sia = <span class="keyword">new</span> StringsInArray(strings);
Assert.assertEquals(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>, sia.getFirst());
strings[<span class="integer">0</span>] = <span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>; <i class="conum" data-value="1"></i><b>(1)</b>
Assert.assertEquals(<span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>, sia.getFirst()); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>External modification of the array.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>As a consequence, the data structure has been modified.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To continue, we must first understand the notion of modification.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="modification">5. Modification</h2>
<div class="sectionbody">
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition</strong>: a <strong>method is modifying</strong> if it causes an assignment in the object graph of the fields of the object it is applied to.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>We use the term 'object graph' to denote the fields of the object, the fields of these fields, etc., to arbitrary depth.</p>
</div>
<div class="paragraph">
<p>Consequently, a method is not modifying if it only reads from the object graph of the fields.
The analyser uses the annotations  <code>@NotModified</code> and  <code>@Modified</code> .
They are exclusive, and the analyser will compute one or the other for every method of the type.
All non-trivial constructors are modifying, so we avoid clutter by not annotating them.</p>
</div>
<div class="paragraph">
<p>It follows from the definition that directly assigning to the fields also causes the  <code>@Modified</code>  mark for methods.
As a consequence, setters are  <code>@Modified</code> , while getters are  <code>@NotModified</code>.
Consider:</p>
</div>
<div class="listingblock">
<div class="title">Example 7, modifying and non-modifying methods</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Counter</span> {
    <span class="annotation">@Variable</span>
    <span class="directive">private</span> <span class="type">int</span> counter;

    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="type">int</span> getCounter() {
        <span class="keyword">return</span> counter;
    }

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">int</span> increment() {
        counter += <span class="integer">1</span>;
        <span class="keyword">return</span> counter;
    }
}

<span class="annotation">@E1Immutable</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="type">class</span> <span class="class">CountedInfo</span> {
    <span class="annotation">@Final</span>
    <span class="annotation">@Modified</span>
    <span class="directive">private</span> <span class="directive">final</span> Counter counter = <span class="keyword">new</span> Counter();

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> printInfo(<span class="predefined-type">String</span> info) {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Message </span><span class="delimiter">&quot;</span></span> + counter.increment() + <span class="string"><span class="delimiter">&quot;</span><span class="content">: </span><span class="delimiter">&quot;</span></span>+info);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The next section will show that the annotation will actually be  <code>@E1Container</code> , representing the combination of  <code>@E1Immutable</code>  and  <code>@Container</code> .</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We also see in the example that the <code>printInfo</code> method is  <code>@Modified</code> .
This is because it calls a modifying method on one of the fields: <code>increment</code>.</p>
</div>
<div class="paragraph">
<p>Moving from methods to parameters and fields, keeping the same two annotations,</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition</strong>:
The analyser marks a <strong>parameter</strong> as <strong>modified</strong> when the parameter&#8217;s method applies an assignment or modifying methods on the object that enters the method via the parameter.
This definition holds with respect to the parameter&#8217;s entire object graph.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>We will apply a similar reasoning to a field:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition</strong>:
The analyser marks a <strong>field</strong> as <strong>modified</strong> when at least one of the type&#8217;s methods, transitively reachable from a non-private non-constructor method, applies at least one assignment to or modifying method on this field.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Let us start by agreeing that the methods of <code>Object</code> and <code>String</code> are all  <code>@NotModified</code>.
This is pretty obvious in the case of <code>toString</code>, <code>hashCode</code>, <code>getClass</code>.
It is less obvious for the <code>wait</code> and other synchronization-related methods, but remember that as discussed in the <a href="#assumptions">Assumptions</a>, we exclude synchronization support from this discussion.</p>
</div>
<div class="paragraph">
<p>Note also that we cannot add modifying methods to the type <code>DeeplyImmutable1</code> defined <a href="#deeply-immutable1">earlier</a>.</p>
</div>
<div class="paragraph">
<p>Proceeding, let us also look at (a part of) the <code>Collection</code> interface, where we&#8217;ve restricted the annotations to  <code>@NotModified</code> and  <code>@Modified</code> .
An abstract method without  <code>@Modified</code>  is assumed to be non-modifying, i.e.,  <code>@NotModified</code> is implicitly present.
(The reason for this choice is explained later, in <a href="#abstract-methods">Abstract methods</a>.) While in normal classes the analyser computes the annotations, in interfaces the user stipulates or <em>contracts</em> behaviour by annotating:</p>
</div>
<div class="listingblock">
<div class="title">Example 8, <a id="collection-interface"></a> modification aspects of the <code>Collection</code> interface</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Collection</span>&lt;E&gt; <span class="directive">extends</span> <span class="predefined-type">Iterable</span>&lt;E&gt; {
    <span class="annotation">@Modified</span>
    <span class="type">boolean</span> add(E e);

    <span class="annotation">@Modified</span>
    <span class="type">boolean</span> addAll(<span class="annotation">@NotModified</span> <span class="predefined-type">Collection</span>&lt;? <span class="directive">extends</span> E&gt; collection);

    <span class="type">boolean</span> contains(<span class="predefined-type">Object</span> object);

    <span class="type">boolean</span> containsAll(<span class="annotation">@NotModified</span> <span class="predefined-type">Collection</span>&lt;?&gt; c);

    <span class="type">void</span> forEach(Consumer&lt;? <span class="local-variable">super</span> E&gt; action);

    <span class="type">boolean</span> isEmpty();

    <span class="annotation">@Modified</span>
    <span class="type">boolean</span> remove(<span class="predefined-type">Object</span> object);

    <span class="annotation">@Modified</span>
    <span class="type">boolean</span> removeAll(<span class="annotation">@NotModified</span> <span class="predefined-type">Collection</span>&lt;?&gt; c);

    <span class="type">int</span> size();

    Stream&lt;E&gt; stream();

    <span class="predefined-type">Object</span><span class="type">[]</span> toArray();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adding an object to a collection (set, list) will cause some assignment somewhere inside the data structure.
Returning the size of the collection should not.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Under supervision of the analyser, you will not be able to create an implementation of this interface which violates the modification rules.
This is intentional: no implementation should modify the data structure when <code>size</code> is called.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Adding all elements of a collection to the object (in <code>addAll</code>) should not modify the input collection, whence the  <code>@NotModified</code>.
Other types in the parameters have not been annotated with  <code>@NotModified</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Object</code> because it is immutable;</p>
</li>
<li>
<p><code>E</code> because it is of an unbound generic type, it has the same methods available as <code>Object</code>.
No code statically visible to implementations of <code>Collection</code> can make modifications to <code>E</code>;</p>
</li>
<li>
<p><code>Consumer</code> because it is a functional interface (an interface with a single abstract method) in <code>java.util.function</code>; they are  <code>@IgnoreModifications</code>  by convention.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In order to keep the narrative going, we defer a discussion of modification in the context of parameters of abstract types to the sections
<a href="#abstract-methods">Abstract methods</a> and <a href="#hidden-content">Hidden content</a>.
Here, we continue with the first use case of modification: containers.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="containers">6. Containers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Loosely speaking, a container is a type to which you can safely pass on your objects, it will not modify them.
This is the formal rule:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition</strong>: a type is a <strong>container</strong> when no non-private method or constructor modifies its parameters.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Whatever else the container does, storing the parameters in fields or not, it will not change your objects.
You obviously remain free to change them elsewhere; then the container will hold on to the changed object, not some copy.</p>
</div>
<div class="paragraph">
<p>Containers are complementary to immutable objects, and we will find that many immutable objects are containers, while some containers are the precursors to immutable types.
There are two archetypes for containers: collections and builders.</p>
</div>
<div class="paragraph">
<p>The code analyser will annotate a type that is both level 1 immutable, and a container, with  <code>@E1Container</code> .
This occurs frequently enough to justify a separate annotation.
The simple but useful utility type <code>Pair</code> trivially satisfies both requirements:</p>
</div>
<div class="listingblock">
<div class="title">Example 9, a <code>Pair</code> of objects</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E1Container</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Pair</span>&lt;K,V&gt; {
    <span class="directive">public</span> <span class="directive">final</span> K k;
    <span class="directive">public</span> <span class="directive">final</span> V v;

    <span class="directive">public</span> Pair(K k, V v) {
        <span class="local-variable">this</span>.k = k;
        <span class="local-variable">this</span>.v = v;
    }

    <span class="directive">public</span> K getK() {
        <span class="keyword">return</span> k;
    }

    <span class="directive">public</span> V getV() {
        <span class="keyword">return</span> v;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>While it is clearly level 1 immutable, it will remain to be seen if it satisfies all criteria for intuitive immutability.
However, it is easily recognized as a container: a type you use and trust to hold objects.</p>
</div>
<div class="paragraph">
<p>Containers occur frequently as static nested types to build immutable objects.
Examples of these will follow later, after the definition of level 2 immutability.</p>
</div>
<div class="paragraph">
<p>Let us conclude this section with an example consisting of three types: the first a class computed to be a container, the second a container according to the contract, and the third a class which cannot be a container:</p>
</div>
<div class="listingblock">
<div class="title">Example 10, two containers and a type that is not a container</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Container</span>
<span class="type">class</span> <span class="class">ErrorMessage</span> {
    <span class="annotation">@Variable</span>
    <span class="directive">private</span> <span class="predefined-type">String</span> message;

    <span class="directive">public</span> ErrorMessage(<span class="predefined-type">String</span> message) {
        <span class="local-variable">this</span>.message = message;
    }

    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> getMessage() {
        <span class="keyword">return</span> message;
    }

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> setMessage(<span class="predefined-type">String</span> message) {
        <span class="local-variable">this</span>.message = message;
    }
}

<span class="annotation">@Container</span>
<span class="type">interface</span> <span class="class">ErrorRegistry</span> {
    <span class="comment">// @NotModified implicitly</span>
    <span class="predefined-type">List</span>&lt;ErrorMessage&gt; getErrors();

    <span class="annotation">@Modified</span>
    <span class="type">void</span> addError(<span class="annotation">@NotModified</span> ErrorMessage errorMessage); <i class="conum" data-value="1"></i><b>(1)</b>
}

<span class="type">class</span> <span class="class">BinaryExpression</span> <span class="directive">extends</span> <span class="predefined-type">Expression</span> {
    <span class="directive">public</span> <span class="directive">final</span> <span class="predefined-type">Expression</span> lhs;
    <span class="directive">public</span> <span class="directive">final</span> <span class="predefined-type">Expression</span> rhs;

    <span class="comment">// ...</span>

    <span class="directive">public</span> <span class="type">void</span> evaluate(<span class="annotation">@Modified</span> ErrorRegistry errorRegistry) {
        <span class="comment">// ...</span>
        <span class="keyword">if</span>(lhs <span class="keyword">instanceof</span> NullConstant || rhs <span class="keyword">instanceof</span> NullConstant) {
            errorRegistry.addError(<span class="keyword">new</span> ErrorMessage(...)); <i class="conum" data-value="2"></i><b>(2)</b>
        }
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Implementations of <code>ErrorRegistry</code> will not be allowed to use the <code>setMessage</code> setter in <code>addError</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Here a modifying method call takes place.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>BinaryExpression</code> class is not a container, because it uses one of the parameters of a public method, <code>errorRegistry</code> of <code>evaluate</code>, as a writable container.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="linking-and-independence">7. Linking, independence</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let us now elaborate on how we will compute modifications, in a path towards level 2 immutability.
Consider the following example:</p>
</div>
<div class="listingblock">
<div class="title">Example 11, a field assigned to a constructor parameter</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">LinkExample1</span>&lt;X&gt; {
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;X&gt; set;

    <span class="directive">public</span> LinkExample1(<span class="predefined-type">Set</span>&lt;X&gt; xs) {
        <span class="local-variable">this</span>.set = xs;
    }

    <span class="directive">public</span> <span class="type">void</span> add(X x) {
        set.add(x);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>After construction, an instance of <code>LinkExample1</code> contains a reference to the set that was passed on as an argument to its constructor.
We say the field <code>set</code> links to the parameter <code>xs</code> of the constructor.
In this example, this is an expensive way of saying that there is an assignment from one to the other.
However, linking can become more complicated.</p>
</div>
<div class="paragraph">
<p>The  <em>e2immu</em>  analyser will add modification annotations to <code>LinkExample1</code> as follows:</p>
</div>
<div class="listingblock">
<div class="title">Example 12, a field linked to a constructor parameter, with annotations</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">LinkExample1</span>&lt;X&gt; {
    <span class="annotation">@Modified</span>
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;X&gt; set;

    <span class="directive">public</span> LinkExample1(<span class="annotation">@Modified</span> <span class="predefined-type">Set</span>&lt;X&gt; xs) {
        <span class="local-variable">this</span>.set = xs;
    }

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> add(X x) {
        set.add(x);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The parameter <code>x</code> of <code>LinkExample1.add</code> is  <code>@NotModified</code> because the first parameter of <code>Set.add</code> is  <code>@NotModified</code>.
The <code>add</code> method modifies the field, which causes the annotation first on the method, then on the field, and finally on the parameter of the constructor.
Because of the latter, <code>LinkExample1</code> cannot be marked  <code>@Container</code> .</p>
</div>
<div class="paragraph">
<p>Linking looks at the underlying object, and not at the variable.
Consider the following alternative <code>add</code> method:</p>
</div>
<div class="listingblock">
<div class="title">Example 13, alternative <code>add</code> method for <code>LinkExample1</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Modified</span>
<span class="directive">public</span> <span class="type">void</span> add(X x) {
    <span class="predefined-type">Set</span>&lt;X&gt; theSet = <span class="local-variable">this</span>.set;
    X theX = x;
    theSet.add(theX);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nothing has changed, obviously.
Finally, as an example of how linking can become more complicated than following assignments, consider a typical <em>view</em> on a collection:</p>
</div>
<div class="listingblock">
<div class="title">Example 14, linking using a method call</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;X&gt; list = createSomeLargeList();
<span class="predefined-type">List</span>&lt;X&gt; sub = list.subList(<span class="integer">1</span>, <span class="integer">5</span>);
sub.set(<span class="integer">0</span>, x); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The modifying method call <code>set</code> will modify <code>sub</code>, and <code>list</code> as well!</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>On the other side of the spectrum, linking does not work on objects that cannot be modified, like primitives or deeply immutable objects such as the primitives, or <code>java.lang.String</code>.</p>
</div>
<div class="paragraph">
<p>Let us summarize by:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition</strong>: Two objects are independent of each other when no modification to the first can imply a modification to the second.</p>
</div>
<div class="paragraph">
<p>Conversely, two objects are linked when a modification to the first may imply a modification to the second.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Linked objects typically share a common sub-object: the object returned by <code>subList</code>, for example, is "backed" by the original list, in other words, it maintains a reference to the original list.</p>
</div>
<div class="paragraph">
<p>We will discuss linking in more detail in <a href="#computing-dependence">How to compute linking</a>.
For now, assume that a field links to another field, or to a parameter, if there is a possibility that both variables represent (part of) the same object (their object graphs overlap).</p>
</div>
<div class="paragraph">
<p>Linking and independence is important when it occurs from fields to parameters and return values of methods:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition</strong>:
A method or constructor parameter is <strong>independent</strong> when it is independent of the fields of the type.
A method is <strong>independent</strong> when its return value is independent of the fields of the type.</p>
</div>
<div class="paragraph">
<p>The independence is marked with  <code>@Independent</code>  on the method for the return value, and on the relevant parameters otherwise.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>When a constructor parameter is not independent, any modification made to the object presented to this parameter as an argument may have an influence on the object graph of the fields of the constructor&#8217;s type.
But do all these modifications matter to the type?</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="accessible-hidden-content">8. Accessible and hidden content</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We will try to make our case using two examples.
First, consider <code>Counter</code> and <code>Counters</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example 15, Counter, Counters</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">Counter</span> {
  <span class="type">void</span> increment();
  <span class="type">int</span> getValue();
  <span class="predefined-type">String</span> getName();
}

<span class="type">class</span> <span class="class">Counters</span> {
  <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, Counter&gt; counters;

  <span class="directive">public</span> Counters(<span class="predefined-type">Collection</span>&lt;Counter&gt; counterCollection) {
    <span class="local-variable">this</span>.counters = counterCollection.stream().collect
      (Collectors.toUnmodifiableMap(Counter::getName, c -&gt; c));
  }

  <span class="directive">public</span> Counter getCounter(<span class="predefined-type">String</span> name) {
    <span class="keyword">return</span> counters.get(name);
  }

  <span class="directive">public</span> <span class="type">int</span> getValue(<span class="predefined-type">String</span> name) {
    <span class="keyword">return</span> getCounter(name).getValue();
  }

  <span class="directive">public</span> <span class="type">void</span> increment(<span class="predefined-type">String</span> name) {
    getCounter(name).increment();
  }

  <span class="directive">public</span> <span class="type">void</span> incrementAll() {
    counters.values().forEach(Counter::increment);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The constructor <code>Counters</code> copies every counter in the <code>counterCollection</code> into a new, unmodifiable map.
Clearly, external modifications to the collection itself (i.e., adding, removing a new <code>Counter</code> element) made after creation of the <code>Counters</code> object, will have no effect on the object graph of the field <code>counters</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;Counter&gt; list = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;();
<span class="predefined-type">Collections</span>.addAll(list, <span class="keyword">new</span> CounterImpl(<span class="string"><span class="delimiter">&quot;</span><span class="content">sunny days</span><span class="delimiter">&quot;</span></span>), <span class="keyword">new</span> CounterImpl(<span class="string"><span class="delimiter">&quot;</span><span class="content">rainy days</span><span class="delimiter">&quot;</span></span>));
Counters counters = <span class="keyword">new</span> Counters(list);
Counter sunnyDays = list.remove(<span class="integer">0</span>);
<span class="keyword">assert</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">sunny days</span><span class="delimiter">&quot;</span></span>.equals(sunnyDays.getName());
<span class="keyword">assert</span> sunnyDays == counters.getCounter(<span class="string"><span class="delimiter">&quot;</span><span class="content">sunny days</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, consider the following statements executed after creating a <code>Counters</code> object:</p>
</div>
<div class="listingblock">
<div class="title">Example 16, after creating a Counters object</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">int</span> rainyDays = counters.getValue(<span class="string"><span class="delimiter">&quot;</span><span class="content">rainy days</span><span class="delimiter">&quot;</span></span>);
Counter c = counters.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">rainy days</span><span class="delimiter">&quot;</span></span>);
c.increment();
<span class="keyword">assert</span> c.getValue() == rainyDays + <span class="integer">1</span>;
<span class="keyword">assert</span> counters.getValue(<span class="string"><span class="delimiter">&quot;</span><span class="content">rainy days</span><span class="delimiter">&quot;</span></span>) == rainyDays + <span class="integer">1</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An external modification (<code>c.increment()</code>) to an object presented to the constructor as part of the collection has an effect on the object graph of the fields, to the extent that an identical, non-modifying method call returns a different value!</p>
</div>
<div class="paragraph">
<p>We must conclude that the parameter of the constructor <code>counterCollection</code> is linked to the field <code>counters</code>, even if modifications at the collection level have no effect.</p>
</div>
<div class="paragraph">
<p>Now we put the <code>Counters</code> example in contrast with the <code>Levels</code> example, where the modifying method <code>increment()</code> has been removed from <code>Counter</code> to obtain <code>Level</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example 17, Level, Levels</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">Level</span> {
  <span class="type">int</span> getValue();
  <span class="predefined-type">String</span> getName();
}

<span class="type">class</span> <span class="class">Levels</span> {
  <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Level</span>&gt; levels;

  <span class="directive">public</span> Levels(<span class="predefined-type">Collection</span>&lt;<span class="predefined-type">Level</span>&gt; levelCollection) {
    <span class="local-variable">this</span>.levels = levelCollection.stream().collect
      (Collectors.toUnmodifiableMap(<span class="predefined-type">Level</span>::getName, c -&gt; c));
  }

  <span class="directive">public</span> <span class="predefined-type">Level</span> getLevel(<span class="predefined-type">String</span> name) {
    <span class="keyword">return</span> levels.get(name);
  }

  <span class="directive">public</span> <span class="type">int</span> getValue(<span class="predefined-type">String</span> name) {
    <span class="keyword">return</span> getLevel(name).getValue();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As a consequence of the absence of <code>increment()</code> in <code>Level</code>, we had to remove <code>increment()</code> and <code>incrementAll()</code> from <code>Levels</code> as well.
In fact, whether the <code>Level</code> instances are modifiable or not, does not seem to matter anymore to <code>Levels</code>.</p>
</div>
<div class="paragraph">
<p>We propose to split the object graph of a field into two parts: its accessible part, and its hidden part.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition:</strong> A type <code>A</code>, part of the object graph of the fields of type <code>T</code>, is <strong>accessible</strong> inside the type <code>T</code> when any of its methods or fields is accessed.
The methods of <code>java.lang.Object</code> are excluded from this definition.</p>
</div>
<div class="paragraph">
<p>A type that is part of the object graph of the fields, but is not accessible, is <strong>hidden</strong> (when it is an unbound type parameter) or <strong>transparent</strong> (when it is not).</p>
</div>
</div>
</div>
<div class="paragraph">
<p>A type which is transparent can be replaced by an unbound type parameter, which is why we will use the term <em>hidden</em> from now on.</p>
</div>
<div class="paragraph">
<p>When a type <code>C</code> extends from a parent type <code>P</code>, we see an instance of <code>C</code> as being composed of two parts: the methods and fields of <code>P</code>, augmented by the methods and fields of <code>C</code>.
Whilst the part of the parent, <code>P</code>, can be accessible, the part of the child <code>C</code> may remain hidden.
Similarly, when <code>T</code> implements the interface <code>I</code>, but the interface is used as the formal type, then the methods and fields of <code>I</code> are accessible, but the ones augmented by the implementation <code>T</code> remain hidden.
In the example of <code>Level</code>, implementation or extensions may be modifiable (such as <code>Counter</code>), but when presented with <code>Level</code> only, there are no modifications to be made.
Inside <code>Levels</code>, no such extensions are accessible.</p>
</div>
<div class="paragraph">
<p>Note that we must make this distinction, because every interface is meant to be implemented, and every (non-<code>final</code>) type can be extended in Java.
These extensions could be completely outside the control of the current implementation (even though we can use the analyser to constrain them).</p>
</div>
<div class="paragraph">
<p>Armed with this definition, we split the combined object graph of the fields of a type into the accessible content, and the hidden content:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition:</strong> The <strong>accessible content</strong> of a type are those objects of the object graph of the fields that are of accessible type.</p>
</div>
<div class="paragraph">
<p>The <strong>hidden content</strong> of a type are those objects of the object graph of the fields that are of hidden or transparent type.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>In the first example of this section, <code>LinkExample1</code>, objects of the type <code>X</code> form the hidden content of <code>LinkExample1</code>, while the <code>Set</code> instance is the accessible content.
In <code>Counters</code>, <code>Map</code>, <code>String</code> and <code>Counter</code> are accessible, but whatever augments to <code>Counter</code> by implementing it remains hidden.
Exactly the same applies to <code>Levels</code>: <code>Map</code>, <code>String</code> and <code>Level</code> are accessible, but whatever augments <code>Level</code> by implementing it remains hidden.</p>
</div>
<div class="paragraph">
<p>One of the central tenets of immutability will be that</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>A type is not responsible for modifications to its hidden content.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>We end this section by defining what independence means with respect to the accessible and hidden content of the fields.
The definition of independence given in the previous section is absolute, in the sense that it covers the whole object graphs of the objects being linked, or not.</p>
</div>
<div class="paragraph">
<p>When a parameter is linked to a field, we could try to find out if the modifications affect the accessible content, given that we state that modifications to the hidden content are outside the scope of the type anyway.
In other words, we could distinguish between different forms of non-independence, or, in better English, dependence.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition:</strong> a parameter or method return value is <strong>dependent</strong> on the fields if and only if it is linked to the accessible content of the type.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>In other words, a parameter or method return value is dependent when a modification on the argument or returned value has the possibility to cause a modification in the accessible part of the fields.</p>
</div>
<div class="paragraph">
<p>Linking between parameters or return value and fields which does not involve the accessible part of the fields, will be not be called dependence, but a lighter form of independence.
We will elaborate more in <a href="#hidden-content">Hidden content</a>.
In the following sections, we will often use the term 'independent' when we mean 'not-dependent', i.e., when we only require one of the lighter forms of independence.</p>
</div>
<div class="paragraph">
<p>In terms of annotations, dependence will be the default state for objects of types where dependence is possible.
We will not annotate it.
Instead,  <code>@Independent</code>  on parameters and methods will be used for absolute independence.
When a type is deeply immutable,  <code>@Independent</code>  is the default state, and therefore it will be omitted.
We use  <code>@Independent1</code>  for the lighter forms of independence.</p>
</div>
<div class="paragraph">
<p>Now, all pieces of the puzzle are available to introduce immutability of types.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_level_2_immutability">9. Level 2 immutability</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_definition_and_examples">9.1. Definition and examples</h3>
<div class="paragraph">
<p>First, what do we want intuitively?
A useful form of immutability, less strong than deeply immutable, but better than level 1 immutability for many situations.
We propose the following description:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>After construction, an immutable type holds a number of objects; the type will not change their content, nor will it exchange these objects for other objects, or allow others to do so.
The type is not responsible for what others do to the content of the objects it was given.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Technically, level 2 immutability is much harder to define than level 1 immutability.
We identify three rules, on top of the obvious level 1 immutability requirement.
The first one prevents the type from making changes to its own fields:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition</strong>: the <strong>first rule of level 2 immutability</strong> is that all fields must be  <code>@NotModified</code>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Our friend the <code>Pair</code> satisfies this first rule:</p>
</div>
<div id="type-pair" class="listingblock">
<div class="title">Example 1, the class <code>Pair</code>, revisited</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Pair</span>&lt;K,V&gt; {
    <span class="directive">public</span> <span class="directive">final</span> K k;
    <span class="directive">public</span> <span class="directive">final</span> V v;

    <span class="directive">public</span> Pair(K k, V v) {
        <span class="local-variable">this</span>.k = k;
        <span class="local-variable">this</span>.v = v;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that since <code>K</code> and <code>V</code> are unbound generic types, it is not even possible to modify their content from inside <code>Pair</code>, since there are no modifying methods one can call on unbound types.
The types <code>K</code> and <code>V</code> are hidden in <code>Pair</code>; it does not have any accessible content.</p>
</div>
<div class="paragraph">
<p>How does it fit the intuitive rule for immutability?
The type <code>Pair</code> holds two objects.
The type does not change their content, nor will it exchange these two objects for others, or allow others to do so.
It is clear the users of <code>Pair</code> may be able to change the content of the objects they put in the <code>Pair</code>.
Summarizing: <code>Pair</code> fits the intuitive definition nicely.</p>
</div>
<div class="paragraph">
<p>Here is an example which shows the necessity of the first rule more explicitly:</p>
</div>
<div id="point-and-line" class="listingblock">
<div class="title">Example 2: the types <code>Point</code> and <code>Line</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Container</span>
<span class="type">class</span> <span class="class">Point</span> {
    <span class="annotation">@Variable</span>
    <span class="directive">private</span> <span class="type">double</span> x;

    <span class="annotation">@Variable</span>
    <span class="directive">private</span> <span class="type">double</span> y;

    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="type">double</span> getX() {
        <span class="keyword">return</span> x;
    }

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> setX(<span class="type">double</span> x) {
        <span class="local-variable">this</span>.x = x;
    }

    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="type">double</span> getY() {
        <span class="keyword">return</span> y;
    }

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> setY(<span class="type">double</span> y) {
        <span class="local-variable">this</span>.y = y;
    }
}

<span class="annotation">@E1Container</span>
<span class="type">class</span> <span class="class">Line</span> {
    <span class="annotation">@Final</span>
    <span class="annotation">@Modified</span>
    <span class="directive">private</span> <span class="predefined-type">Point</span> point1;

    <span class="annotation">@Final</span>
    <span class="annotation">@Modified</span>
    <span class="directive">private</span> <span class="predefined-type">Point</span> point2;

    <span class="directive">public</span> <span class="predefined-type">Line</span>(<span class="predefined-type">Point</span> point1, <span class="predefined-type">Point</span> point2) {
        <span class="local-variable">this</span>.point1 = point1;
        <span class="local-variable">this</span>.point2 = point2;
    }

    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="predefined-type">Point</span> middle() {
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">Point</span>((point1.getX() + point2.getX())/<span class="float">2.0</span>,
             (point1.getY()+point2.getY())/<span class="float">2.0</span>);
    }

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> translateHorizontally(<span class="type">double</span> x) {
        point1.setX(point1.getX() + x); <i class="conum" data-value="1"></i><b>(1)</b>
        point2.setX(point2.getX() + x);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Modifying operation on <code>point1</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The fields <code>point1</code> and <code>point2</code> are effectively final.
Without the translation method, the fields would be  <code>@NotModified</code> as well.
The translation method modifies the fields' content, preventing the type from becoming level 2 immutable.</p>
</div>
<div class="paragraph">
<p>From the restriction of rule 1, that all its fields should remain unmodified, it follows that, excluding external changes, every method call on a level 2 immutable container object with the same arguments will render the same result.
We note that this statement cannot be bypassed by using <em>static</em> state, i.e., state specific to the type rather than the object.
The definitions make no distinction between static and instance fields.</p>
</div>
<div class="paragraph">
<p>To obtain a useful definition of immutability, one which is not too strict yet follows our intuitive requirements, we should allow modifiable fields, if they are properly shielded from the modifications they intrinsically allow.
We will introduce two additional rules to constrain the modifications of this modifiable data.
Together with the first rule, and building on level 1 immutability, we define:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition: level 2 immutability</strong>:</p>
</div>
<div class="paragraph">
<p>(<strong>Rule 0</strong>: The type is level 1 immutable: all fields are effectively final)</p>
</div>
<div class="paragraph">
<p><strong>Rule 1</strong>: All fields are  <code>@NotModified</code>.</p>
</div>
<div class="paragraph">
<p><strong>Rule 2</strong>: All fields are either private, or of level 2 immutable type themselves.</p>
</div>
<div class="paragraph">
<p><strong>Rule 3</strong>: No parameters of non-private methods or non-private constructors, no return values of non-private methods, are dependent on (the accessible part of) the fields.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Rule 2 is there to ensure that the modifiable fields of the object cannot be modified externally by means of direct field access to the non-private fields.
Rule 3 ensures that the modifiable fields of the object cannot be modified externally by obtaining or sharing references to the fields via a parameter or return value.</p>
</div>
<div class="paragraph">
<p>Types which are level 2 immutable will be marked  <code>@E2Immutable</code> .
When they are containers too, which should be the huge majority, we write  <code>@E2Container</code> , stressing the container property.</p>
</div>
<div class="paragraph">
<p>Note that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We state that all primitive types are level 2 immutable, as is <code>java.lang.Object</code>.
Whilst this is fairly obvious in the case of primitives, level 2 immutability for <code>Object</code> requires us to either ignore the methods related to synchronization, or to assume that its implementation (for it is not an abstract type) has no fields.</p>
</li>
<li>
<p>A consequence of rule 1 is that all methods in a level 2 immutable type must be  <code>@NotModified</code>.</p>
</li>
<li>
<p>A field whose type is an unbound type parameter, can locally be considered to be of level 2 immutable type, and therefore need not be private.
This is because the type parameter could be substituted by <code>java.lang.Object</code>, which we have just declared to be level 2 immutable.
More details can be found in the section on <a href="#generics">Generics</a>.</p>
</li>
<li>
<p>Constructor parameters whose formal type is an unbound type parameter, are of hidden type inside the type of the constructor.
As a consequence, rule 3 does not apply to them.
This will be expanded on in <a href="#hidden-content">Hidden content</a>.</p>
</li>
<li>
<p>The section on <a href="#inheritance">Inheritance</a> will show how the immutability property relates to implementing interfaces, and sub-classing.
This is important because the definition is recursive, with <code>java.lang.Object</code> the level 2 immutable base of the recursion.
All other types must extend from it.</p>
</li>
<li>
<p>The section on <a href="#abstract-methods">Abstract methods</a> will detail how level 2 immutability is computed for abstract types (interfaces, abstract classes).</p>
</li>
<li>
<p>The first rule can be reached <em>eventually</em> if there is one or more methods that effect a transition from the mutable to the immutable state.
This typically means that all methods that assign or modify fields become off-limits after calling this marker method.
Eventuality for rules 2 and 3 seems too far-fetched.
We address the topic of eventual immutability fully in the section <a href="#eventual-immutability">Eventual immutability</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let us go to examples immediately.</p>
</div>
<div class="listingblock">
<div class="title">Example 18, explaining level 2 immutability: with array, version 1, not good</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E1Container</span>
<span class="type">class</span> <span class="class">ArrayContainer1</span>&lt;T&gt; {
    <span class="annotation">@NotModified</span>
    <span class="directive">private</span> <span class="directive">final</span> T<span class="type">[]</span> data;

    <span class="directive">public</span> ArrayContainer1(T<span class="type">[]</span> ts) {
        <span class="local-variable">this</span>.data = ts;
    }

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Independent1</span>
    <span class="directive">public</span> Stream&lt;T&gt; stream() {
        <span class="keyword">return</span> <span class="predefined-type">Arrays</span>.stream(data);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>After creation, external changes to the source array <code>ts</code> are effectively modifications to the field <code>data</code>.
This construct fails rule 3, as the parameter <code>ts</code> is dependent.
The field is a modifiable data structure, and must be shielded from external modifications.</p>
</div>
<div class="paragraph">
<p>Note the use of the lighter form of independence,  <code>@Independent1</code> , on the return value of <code>stream()</code>, to indicate that modifications to the hidden content are possible on objects obtained from the stream.</p>
</div>
<div class="listingblock">
<div class="title">Example 19, explaining level 2 immutability: with array, version 2, not good</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E1Container</span>
<span class="type">class</span> <span class="class">ArrayContainer2</span>&lt;T&gt; {
    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="directive">final</span> T<span class="type">[]</span> data;

    <span class="directive">public</span> ArrayContainer2(<span class="annotation">@Independent1</span> T<span class="type">[]</span> ts) {
        <span class="local-variable">this</span>.data = <span class="keyword">new</span> T[ts.length];
        <span class="predefined-type">System</span>.arraycopy(ts, <span class="integer">0</span>, data, <span class="integer">0</span>, ts.length);
    }

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Independent1</span>
    <span class="directive">public</span> Stream&lt;T&gt; stream() {
        <span class="keyword">return</span> <span class="predefined-type">Arrays</span>.stream(data);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Users of this type can modify the content of the array using direct field access!
This construct fails rule 2, which applies for the same reasons as in the previous example.</p>
</div>
<div class="listingblock">
<div class="title">Example 20, explaining level 2 immutability: with array, version 3, safe</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>
<span class="type">class</span> <span class="class">ArrayContainer3</span>&lt;T&gt; {
    <span class="annotation">@NotModified</span>
    <span class="directive">private</span> <span class="directive">final</span> T<span class="type">[]</span> data; <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="directive">public</span> ArrayContainer3(<span class="annotation">@Independent1</span> T<span class="type">[]</span> ts) {
        <span class="local-variable">this</span>.data = <span class="keyword">new</span> T[ts.length]; <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="predefined-type">System</span>.arraycopy(ts, <span class="integer">0</span>, data, <span class="integer">0</span>, ts.length);
    }

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Independent1</span>
    <span class="directive">public</span> Stream&lt;T&gt; stream() {
        <span class="keyword">return</span> <span class="predefined-type">Arrays</span>.stream(data);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The array is private, and therefore protected from external modification via the direct access route.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The array has been copied, and therefore is independent of the one passed in the parameter.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The independence rule enforces the type to have its own modifiable structure, rather than someone else&#8217;s.
Here is the same group of examples, now with JDK Collections:</p>
</div>
<div class="listingblock">
<div class="title">Example 21, explaining level 2 immutability: with collection, version 1, not good</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E1Container</span>
<span class="type">class</span> <span class="class">SetBasedContainer1</span>&lt;T&gt; {
    <span class="annotation">@NotModified</span>
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;T&gt; data;

    <span class="annotation">@Dependent</span>
    <span class="directive">public</span> SetBasedContainer1(<span class="predefined-type">Set</span>&lt;T&gt; ts) {
        <span class="local-variable">this</span>.data = ts; <i class="conum" data-value="1"></i><b>(1)</b>
    }

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Independent1</span>
    <span class="directive">public</span> Stream&lt;T&gt; stream() {
        <span class="keyword">return</span> data.stream();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>After creation, changes to the source set are effectively changes to the data.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The lack of independence of the constructor violates rule 3 in the first example.</p>
</div>
<div class="listingblock">
<div class="title">Example 22, explaining level 2 immutability: with collection, version 2, not good</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E1Container</span>
<span class="type">class</span> <span class="class">SetBasedContainer2</span>&lt;T&gt; {
    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;T&gt; data; <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="directive">public</span> SetBasedContainer2(<span class="annotation">@Independent1</span> <span class="predefined-type">Set</span>&lt;T&gt; ts) {
        <span class="local-variable">this</span>.data = <span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;&gt;(ts);
    }

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Independent1</span>
    <span class="directive">public</span> Stream&lt;T&gt; stream() {
        <span class="keyword">return</span> data.stream();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Users of this type can modify the content of the set after creation!</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here, the <code>data</code> field is public, which allows for external modification.</p>
</div>
<div class="listingblock">
<div class="title">Example 23, explaining level 2 immutability: with collection, version 3, safe</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>
<span class="type">class</span> <span class="class">SetBasedContainer3</span>&lt;T&gt; {
    <span class="annotation">@NotModified</span>
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;T&gt; data; <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="directive">public</span> SetBasedContainer3(<span class="annotation">@Independent1</span> <span class="predefined-type">Set</span>&lt;T&gt; ts) {
        <span class="local-variable">this</span>.data = <span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;&gt;(ts); <i class="conum" data-value="2"></i><b>(2)</b>
    }

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Independent1</span>
    <span class="directive">public</span> Stream&lt;T&gt; stream() {
        <span class="keyword">return</span> data.stream();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The set is private, and therefore protected from external modification.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The set has been copied, and therefore is independent of the one passed in the parameter.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally, we have a level 2 immutable type.
The next one is level 2 immutable as well:</p>
</div>
<div class="listingblock">
<div class="title">Example 24, explaining level 2 immutability: with collection, version 4, safe</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>
<span class="type">class</span> <span class="class">SetBasedContainer4</span>&lt;T&gt; {

    <span class="annotation">@E2Container</span>
    <span class="directive">public</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;T&gt; data; <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="directive">public</span> SetBasedContainer4(<span class="annotation">@Independent1</span> <span class="predefined-type">Set</span>&lt;T&gt; ts) {
        <span class="local-variable">this</span>.data = <span class="predefined-type">Set</span>.copyOf(ts); <i class="conum" data-value="2"></i><b>(2)</b>
    }

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Independent1</span>
    <span class="directive">public</span> Stream&lt;T&gt; stream() {
        <span class="keyword">return</span> data.stream();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>the data is public, but the <code>Set</code> is  <code>@E2Immutable</code>  itself, because its content is the result of <code>Set.copyOf</code>, which is an implementation that blocks any modification.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Independence guaranteed.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The section on <a href="#dynamic-type-annotations">Dynamic type annotations</a> will explain how the  <code>@E2Container</code>  annotation travels to the field <code>data</code>.</p>
</div>
<div class="paragraph">
<p>The independence rule, rule 3, is there to ensure that the type does not expose its modifiable data through parameters and return types:</p>
</div>
<div class="listingblock">
<div class="title">Example 25, explaining level 2 immutability: with collection, version 5, not good</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E1Container</span>
<span class="type">class</span> <span class="class">SetBasedContainer5</span>&lt;T&gt; {
    <span class="annotation">@NotModified</span>
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;T&gt; data; <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="directive">public</span> SetBasedContainer5(<span class="annotation">@Independent1</span> <span class="predefined-type">Set</span>&lt;T&gt; ts) {
        <span class="local-variable">this</span>.data = <span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;&gt;(ts); <i class="conum" data-value="2"></i><b>(2)</b>
    }

    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;T&gt; getSet() {
        <span class="keyword">return</span> data; <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>No exposure via the field</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>No exposure via the parameter of the constructor</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230;&#8203; but exposure via the getter.
The presence of the getter is equivalent to adding the modifiers <code>public final</code> to the field.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that by decomposing rules 0 and 1, we observe that requiring all fields to be  <code>@Final</code>  and  <code>@NotModified</code> is equivalent to requiring that all non-private fields have the <code>final</code> modifier, and that methods that are not part of the construction phase, are  <code>@NotModified</code>.
The final example shows a type which violates this rule 1, because a modifying method has been added:</p>
</div>
<div class="listingblock">
<div class="title">Example 26, explaining level 2 immutability: with collection, version 6, not good</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E1Container</span>
<span class="type">class</span> <span class="class">SetBasedContainer6</span>&lt;T&gt; {
    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;T&gt; set = <span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;&gt;();

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> add(<span class="annotation">@Independent1</span> T t) { set.add(t); }

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Independent1</span>
    <span class="directive">public</span> Stream&lt;T&gt; stream() { <span class="keyword">return</span> set.stream(); }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="inheritance">9.2. Inheritance</h3>
<div class="paragraph">
<p>Deriving from a class that is level 2 immutable, is the most normal situation: since <code>java.lang.Object</code> is a level 2 immutable container, every class will do so.
Clearly, the property is not inherited.</p>
</div>
<div class="paragraph">
<p>Most importantly, in terms of inheritance, is that the analyser prohibits changing the modification status of methods from non-modifying to modifying in a derived type.
This means, for example, that the analyser will block a modifying <code>equals()</code> or <code>toString()</code> method, in any class.
Similarly, no implementation of <code>java.util.Collection.size()</code> will be allowed to be modifying.</p>
</div>
<div class="paragraph">
<p>The guiding principle here is that of <em>consistency of expectation</em>: software developers are expecting that <code>equals</code> is non-modifying.
They know that a setter will make an assignment, but they&#8217;ll expect a getter to simply return a value.
No getter should ever be modifying.</p>
</div>
<div class="paragraph">
<p>The other direction is more interesting, while equally simple to explain: deriving from a parent class cannot increase the immutability level.
A method overriding one marked  <code>@Modified</code>  does not have to be modifying, but it is not allowed to be explicitly marked  <code>@NotModified</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example 27, illegal modification status of methods</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">abstract</span> <span class="type">class</span> <span class="class">MyString</span> <span class="directive">implements</span> <span class="predefined-type">Collection</span>&lt;<span class="predefined-type">String</span>&gt; {
    <span class="directive">private</span> <span class="predefined-type">String</span> string = <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>;

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">int</span> size() {
        string = string + <span class="string"><span class="delimiter">&quot;</span><span class="content">!</span><span class="delimiter">&quot;</span></span>; <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="keyword">return</span> string.length();
    }

    <span class="annotation">@Override</span>
    <span class="annotation">@NotModified</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="directive">public</span> <span class="directive">abstract</span> <span class="type">boolean</span> add(<span class="predefined-type">String</span> s);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Not allowed!
Any implementation of <code>Collection.size()</code> must be non-modifying.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Not allowed!
You cannot explicitly (contractually) change <code>Collection.add()</code> from  <code>@Modified</code>  to  <code>@NotModified</code> in a sub-type.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Following the same principles, we observe that types deriving from a  <code>@Container</code>  super-type need not be a container themselves.
So while we may state that <code>Collection</code> is a container, it is perfectly possible to implement a collection which has public methods which modify their parameters, <em>as long as the methods inherited from <code>Collection</code> do not modify their parameters</em>.
In other words, you can add new parameter-modifying methods, but you cannot change the modification status of <code>size</code>!</p>
</div>
<div class="paragraph">
<p>Note that sealed types (since JDK 17) reject the 'you can always extend' assumptions of Java types.
In this case, all sub-types are known, and visible.
The single practical consequence is that if the parent type is abstract, its annotations need not be contracted: they can be computed because all implementations are available to the analyser.</p>
</div>
</div>
<div class="sect2">
<h3 id="generics">9.3. Generics</h3>
<div class="paragraph">
<p>Type parameters are either <em>unbound</em>, in which case they can represent any type, or they explicitly extend a given type.
Because the unbound case is simply a way of saying that the type parameter extends <code>java.lang.Object</code>, we can say that all type parameters extend a certain type, say <code>T extends E</code>.</p>
</div>
<div class="paragraph">
<p>The analyser simply treats the parameterized type <code>T</code> as if it were the type <code>E</code>.
In the case of an unbound parameter type, only the public methods of <code>java.lang.Object</code> are accessible.
By definition, the type belongs to the hidden content, as defined in <a href="#accessible-hidden-content">Accessible and hidden content</a>.</p>
</div>
<div class="paragraph">
<p>The analyser recognises types that can be replaced by an unbound parameter type, when they are used <em>transparently</em>, and therefore belong to the hidden content: no methods are called on it, save the ones from <code>java.lang.Object</code>; none of its fields are accessed, and it is not used as an argument to parameters where anything more specific than <code>java.lang.Object</code> is required.
It will issue a warning, and internally treat the type as an unbound parameter type, and hence  <code>@E2Container</code> , even if the type is obviously modifiable.</p>
</div>
<div class="paragraph">
<p>The following trivial example should clarify:</p>
</div>
<div class="listingblock">
<div class="title">Example 28, a type used transparently in a class</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">OddPair</span> {

    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt; set;
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">StringBuilder</span> sb;

    <span class="directive">public</span> OddPair(<span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt; set, <span class="predefined-type">StringBuilder</span> sb) {
        <span class="local-variable">this</span>.set = set;
        <span class="local-variable">this</span>.sb = sb;
    }

    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt; getSet() { <span class="keyword">return</span> set; }
    <span class="directive">public</span> <span class="predefined-type">StringBuilder</span> getSb() { <span class="keyword">return</span> sb; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nowhere in <code>OddPair</code> do we make actual use of the fact that <code>set</code> is of type <code>Set</code>, or <code>sb</code> is of type <code>StringBuilder</code>.
The analyser encourages you to replace <code>Set</code> by some unbound parameter type, say <code>K</code>, and <code>StringBuilder</code> by some other, say <code>V</code>.
The result is, of course, the type <code>Pair</code> as defined <a href="#type-pair">earlier</a>.</p>
</div>
<div class="paragraph">
<p>Making a concrete choices for a type parameter may have an effect on the immutability level, as will be explained in <a href="#hidden-content">Hidden content</a>.
Some examples are easy to see: any level 1 immutable type whose fields consists only of types of unbound type parameter, will become deeply immutable when the unbound type parameters are substituted for deeply immutable types.
Any level 2 immutable type whose hidden content consists only of types of unbound type parameter, will become deeply immutable when the unbound type parameters are substituted for deeply immutable types.
The <code>Pair</code> mentioned before is a case in point, and an example for both rules: <code>Pair&lt;Integer, Long&gt;</code> is deeply immutable.</p>
</div>
</div>
<div class="sect2">
<h3 id="abstract-methods">9.4. Abstract methods</h3>
<div class="paragraph">
<p>Because <code>java.lang.Object</code> is a level 2 immutable container, trivial extensions are, too:</p>
</div>
<div class="listingblock">
<div class="title">Example 29, trivial extensions of <code>java.lang.Object</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>
<span class="type">interface</span> <span class="class">Marker</span> { }

<span class="annotation">@E2Container</span>
<span class="type">class</span> <span class="class">EmptyClass</span> { }

<span class="annotation">@E2Container</span>
<span class="type">class</span> <span class="class">ImplementsMarker</span> <span class="directive">implements</span> Marker { }

<span class="annotation">@E2Container</span>
<span class="type">class</span> <span class="class">ExtendsEmptyClass</span> <span class="directive">extends</span> ImplementsMarker { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>Things only become interesting when methods enter the picture.
Annotation-wise, we stipulate that</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Unless otherwise explicitly annotated, we will assume that abstract methods, be they in interfaces or abstract classes, are  <code>@NotModified</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Furthermore, we will also impose special variants of the rules for level 2 immutability of an abstract type <code>T</code>, to be obeyed by the abstract methods:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Variant of rule 1</strong>: Abstract methods must be non-modifying.</p>
</div>
<div class="paragraph">
<p><strong>Variant of rule 3</strong>: Abstract methods returning values must be independent, i.e., the object they return must be not be dependent on the fields.
They cannot expose the fields via parameters: parameters of non-primitive, non-level 2 immutable type must not be dependent.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The consequence of these choices is that implementations and extensions of abstract and non-abstract types will have the opportunity to have the same immutability properties.
This allows us, e.g., to think of every implementation of <code>java.util.Set</code> as a level 1 immutable container, if we limit to the public methods of <code>Set</code>.
Similarly, we can treat any implementation of <code>Comparable</code>, defined as:</p>
</div>
<div class="listingblock">
<div class="title">Example 30, <code>java.lang.Comparable</code> annotated</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>
<span class="type">interface</span> <span class="class">Comparable</span>&lt;T&gt; {

    <span class="comment">// @NotModified implicitly present</span>
    <span class="type">int</span> compareTo(<span class="annotation">@NotModified</span> T other);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>as a level 2 immutable type when the only method we can access is <code>compareTo</code>.</p>
</div>
<div class="paragraph">
<p>As for as the modification status of the <em>parameters</em> of abstract methods is concerned, we start off with  <code>@Modified</code>  rather than with  <code>@NotModified</code>:</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Unless otherwise explicitly annotated, or their types are level 2 immutable, we will assume that the parameters of abstract methods, be they in interfaces or abstract classes, are  <code>@Modified</code> .
Overriding the method, the contract can change from  <code>@Modified</code>  to  <code>@NotModified</code>, but not from  <code>@NotModified</code> to  <code>@Modified</code> .
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>While it is possible to compute the immutability and container status of interface types, using the rules presented above, it often makes more practical sense to use the annotations as contracts: they may save a lot of annotation work on the abstract methods in the interface.
We repeat that no implementation of a level 2 immutable interface is guaranteed to be level 2 immutable itself; nor does this guarantee hold for the container property unless no new non-private methods have been added.</p>
</div>
<div class="paragraph">
<p>We continue this section with some examples which will form the backbone of the examples in <a href="#hidden-content">Hidden content</a>.</p>
</div>
<div class="paragraph">
<p>If semantically used correctly, types implementing the <code>HasSize</code> interface expose a single numeric aspect of their content:</p>
</div>
<div class="listingblock">
<div class="title">Example 31, the <code>HasSize</code> interface</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span> <span class="comment">// computed (or contracted)</span>
<span class="type">interface</span> <span class="class">HasSize</span> {

    <span class="comment">// implicitly present: @NotModified</span>
    <span class="type">int</span> size();

    <span class="annotation">@NotModified</span> <span class="comment">// computed, not an abstract method!</span>
    <span class="keyword">default</span> <span class="type">boolean</span> isEmpty() {
        <span class="keyword">return</span> size() == <span class="integer">0</span>;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We extend to:</p>
</div>
<div class="listingblock">
<div class="title">Example 32, still level 2 immutable: <code>NonEmptyImmutableList</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span> <span class="comment">// computed, contracted</span>
<span class="type">interface</span> <span class="class">NonEmptyImmutableList</span>&lt;T&gt; <span class="directive">extends</span> HasSize {

    <span class="comment">// implicitly present: @NotModified</span>
    <span class="annotation">@Independent1</span> <i class="conum" data-value="1"></i><b>(1)</b>
    T first();

    <span class="comment">// implicitly present: @NotModified</span>
    <span class="type">void</span> visit(Consumer&lt;T&gt; consumer); <i class="conum" data-value="2"></i><b>(2)</b>

    <span class="annotation">@Constant</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="annotation">@NotModified</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="annotation">@Override</span>
    <span class="keyword">default</span> <span class="type">boolean</span> isEmpty() {
        <span class="keyword">return</span> <span class="predefined-constant">false</span>;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Whilst formally, <code>T</code> can never be dependent because it must belong to the hidden content of the interface, contracting the  <code>@Independent1</code>  annotation here will force all concrete implementations to have an non-dependent <code>first</code> method.
If the concrete choice for <code>T</code> is modifiable, the independence rule must be satisfied.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The parameter <code>consumer</code> would normally be  <code>@Modified</code> , which would break the  <code>@Container</code>  property that we wish for <code>NonEmptyImmutableList</code>.
However, as detailed and explained in <a href="#hidden-content">Hidden content</a>, the abstract types in <code>java.util.function</code> receive an implicit  <code>@IgnoreModifications</code>  annotation.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Computed, because it is not an abstract method.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>Consumer</code> interface is defined and annotated as:</p>
</div>
<div class="listingblock">
<div class="title">Example 33, the java.util.function.Consumer interface, annotated</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@FunctionalInterface</span>
<span class="type">interface</span> <span class="class">Consumer</span>&lt;T&gt; {

    <span class="annotation">@Modified</span>
    <span class="type">void</span> accept(T t); <span class="comment">// @Modified on t implicit</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Implementations of the <code>accept</code> method are allowed to be modifying (even though in <code>NonEmptyImmutableList.visit</code> we decide to ignore this modification!).
They are also allowed to modify their parameter, as we will demonstrate shortly.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s downgrade from  <code>@E2Container</code>  to  <code>@E1Container</code>  by adding a modifying method:</p>
</div>
<div class="listingblock">
<div class="title">Example 34, not level 2 immutable anymore: <code>NonEmptyList</code> <a id="NonEmptyList"></a></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E1Container</span>
<span class="type">interface</span> <span class="class">NonEmptyList</span>&lt;T&gt; <span class="directive">extends</span> NonEmptyImmutableList&lt;T&gt; {

    <span class="annotation">@Modified</span>
    <span class="type">void</span> setFirst(<span class="annotation">@NotModified</span> T t);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The method <code>setFirst</code> goes against the default annotations twice: because it is modifying, and because it promises to keep its parameter unmodified.
Implementations can even lose level 1 immutability:</p>
</div>
<div class="listingblock">
<div class="title">Example 35, mutable implementation of <code>NonEmptyList</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Container</span>
<span class="directive">static</span> <span class="type">class</span> <span class="class">One</span>&lt;T&gt; <span class="directive">implements</span> NonEmptyList&lt;T&gt; {

    <span class="annotation">@Variable</span>
    <span class="directive">private</span> T t;

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> T first() {
        <span class="keyword">return</span> t;
    }

    <span class="annotation">@Modified</span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> setFirst(T t) {
        <span class="local-variable">this</span>.t = t;
    }

    <span class="annotation">@Constant</span>
    <span class="annotation">@NotModified</span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">int</span> size() {
        <span class="keyword">return</span> <span class="integer">1</span>;
    }

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> visit(Consumer&lt;T&gt; consumer) {
        consumer.accept(t);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is a (slightly more convoluted) implementation that remains  <code>@E1Container</code> :</p>
</div>
<div class="listingblock">
<div class="title">Example 36, level 1 immutable implementation of <code>NonEmptyList</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E1Container</span>
<span class="directive">static</span> <span class="type">class</span> <span class="class">OneWithOne</span>&lt;T&gt; <span class="directive">implements</span> NonEmptyList&lt;T&gt; {
    <span class="directive">private</span> <span class="directive">final</span> One&lt;T&gt; one = <span class="keyword">new</span> One&lt;&gt;();

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> T first() {
        <span class="keyword">return</span> one.first();
    }

    <span class="annotation">@Modified</span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> setFirst(T t) {
        one.setFirst(t);
    }

    <span class="annotation">@Constant</span>
    <span class="annotation">@NotModified</span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">int</span> size() {
        <span class="keyword">return</span> <span class="integer">1</span>;
    }

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> visit(Consumer&lt;T&gt; consumer) {
        consumer.accept(first());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Obviously, a  <code>@E2Container</code>  implementation is not possible: the immutability status of an extension (<code>OneWithOne</code>, <code>One</code>) cannot be better than that of the type it is extending from (<code>NonEmptyList</code>).</p>
</div>
<div class="paragraph">
<p>We end the section by showing how concrete implementations of the <code>accept</code> method in <code>Consumer</code> can make modifications.
First, modifications to the parameter:</p>
</div>
<div class="listingblock">
<div class="title">Example 37, modification to the parameter of <code>Consumer.accept</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">One&lt;<span class="predefined-type">StringBuilder</span>&gt; one = <span class="keyword">new</span> One&lt;&gt;();
one.setFirst(<span class="keyword">new</span> <span class="predefined-type">StringBuilder</span>());
one.visit(sb -&gt; sb.append(<span class="string"><span class="delimiter">&quot;</span><span class="content">!</span><span class="delimiter">&quot;</span></span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The last statement is maybe more easily seen as:</p>
</div>
<div class="listingblock">
<div class="title">Example 38, modification to the parameter of <code>Consumer.accept</code>, written out</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">one.visit(<span class="keyword">new</span> Consumer&lt;<span class="predefined-type">StringBuilder</span>&gt; {

   <span class="annotation">@Override</span>
   <span class="directive">public</span> <span class="type">void</span> accept(<span class="predefined-type">StringBuilder</span> sb) {
       sb.append(<span class="string"><span class="delimiter">&quot;</span><span class="content">!</span><span class="delimiter">&quot;</span></span>);
   }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Second, modifications to the fields of the type:</p>
</div>
<div class="listingblock">
<div class="title">Example 39, the method <code>Consumer.accept</code> modifying a field</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E1Container</span>
<span class="type">class</span> <span class="class">ReceiveStrings</span> <span class="directive">implements</span> Consumer&lt;<span class="predefined-type">String</span>&gt; {

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="directive">final</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; list = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;();

    <span class="annotation">@Modified</span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> accept(<span class="predefined-type">String</span> string) {
        list.add(string);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="static-side-effects">9.5. Static side effects</h3>
<div class="paragraph">
<p>Up to now, we have made no distinction between static fields and instance fields: modifications are modifications.
Inside a primary type, we will stick to this rule.
In the following example, each call to <code>getK</code> increments a counter, which is a modifying operation because the type owns the counter:</p>
</div>
<div class="listingblock">
<div class="title">Example 40, modifications on static fields are modifications</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E1Container</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">CountAccess</span>&lt;K&gt; {

    <span class="annotation">@NotModified</span>
    <span class="directive">private</span> <span class="directive">final</span> K k;

    <span class="annotation">@Modified</span>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">AtomicInteger</span> counter = <span class="keyword">new</span> <span class="predefined-type">AtomicInteger</span>();

    <span class="directive">public</span> CountAccess(K k) {
        <span class="local-variable">this</span>.k = k;
    }

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> K getK() {
        counter.getAndIncrement();
        <span class="keyword">return</span> k;
    }

    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">int</span> countAccessToK() {
        <span class="keyword">return</span> counter.get();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can explicitly ignore modifications with the  <code>@IgnoreModifications</code>  annotation, which may make sense from a semantic point of view:</p>
</div>
<div class="listingblock">
<div class="title">Example 41, modification on static field, explicitly ignored</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">CountAccess</span>&lt;K&gt; {

    <span class="annotation">@NotModified</span>
    <span class="directive">private</span> <span class="directive">final</span> K k;

    <span class="annotation">@IgnoreModifications</span>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">AtomicInteger</span> counter = <span class="keyword">new</span> <span class="predefined-type">AtomicInteger</span>();

    <span class="directive">public</span> CountAccess(K k) {
        <span class="local-variable">this</span>.k = k;
    }

    <span class="annotation">@NotModified</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="directive">public</span> K getK() {
        counter.getAndIncrement(); <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="keyword">return</span> k;
    }

    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">int</span> countAccessToK() {
        <span class="keyword">return</span> counter.get();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The effects of the modifying method <code>getAndIncrement</code> are ignored.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that when the modification takes place inside the constructor, it is still not ignored, because for static fields, static code blocks act as the constructor:</p>
</div>
<div class="listingblock">
<div class="title">Example 42, modification of static field can occur inside constructor</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E1Container</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">HasUniqueIdentifier</span>&lt;K&gt; {

    <span class="directive">public</span> <span class="directive">final</span> K k;
    <span class="directive">public</span> <span class="directive">final</span> <span class="type">int</span> identifier;

    <span class="annotation">@Modified</span>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">AtomicInteger</span> generator = <span class="keyword">new</span> <span class="predefined-type">AtomicInteger</span>();

    <span class="directive">public</span> HasUniqueIdentifier(K k) {
        <span class="local-variable">this</span>.k = k;
        identifier = generator.getAndIncrement();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Only modifications in a static code block are ignored:</p>
</div>
<div class="listingblock">
<div class="title">Example 43, static code blocks are the constructors of static fields</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">CountAccess</span>&lt;K&gt; {
    ...
    private <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">AtomicInteger</span> counter;

    <span class="directive">static</span> {
        counter = <span class="keyword">new</span> <span class="predefined-type">AtomicInteger</span>();
        counter.getAndIncrement(); <i class="conum" data-value="1"></i><b>(1)</b>
    }
    ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Modification, part of the construction process.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Nevertheless, we introduce the following rule which does distinguish between modifications on static and instance types:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>When static modifying methods are called, on a field not belonging to the primary type or any of the parent types, or directly on a type expression which does not refer to any of the types in the primary type or parent types, we will make an exception to this rule, and classify the modification as a <em>static side effect</em>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>This is still consistent with the rules of level 2 immutable types, which only look at the fields and assume that when methods do not modify the fields, they are actually non-modifying.
Without an  <code>@IgnoreModifications</code>  annotation on the field <code>System.out</code> (which we would typically add), printing to the console results in</p>
</div>
<div class="listingblock">
<div class="title">Example 44, static side effects annotation</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@StaticSideEffects</span>
<span class="annotation">@NotModified</span>
<span class="directive">public</span> K getK() {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Getting </span><span class="delimiter">&quot;</span></span>+k);
    <span class="keyword">return</span> k;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We leave it up to the programmer or designer to determine whether static calls deserve a  <code>@StaticSideEffects</code>  warning, or not.
In almost all instances, we prefer a singleton instance (see <a href="#singleton-classes">Singleton classes</a>) over a class with modifying static methods.
In singletons the normal modification rules apply, unless  <code>@IgnoreModifications</code>  decorates the static field giving access to the singleton.</p>
</div>
</div>
<div class="sect2">
<h3 id="value-based-classes">9.6. Value-based classes</h3>
<div class="paragraph">
<p>Quoting from the JDK 8 documentation, value-based classes are</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>final and immutable (though may contain references to mutable objects);</p>
</li>
<li>
<p>have implementations of equals, hashCode, and toString which are computed solely from the instance&#8217;s state and not from its identity or the state of any other object or variable;</p>
</li>
<li>
<p>make no use of identity-sensitive operations such as reference equality (==) between instances, identity hash code of instances, or synchronization on an instances&#8217;s intrinsic lock;</p>
</li>
<li>
<p>are considered equal solely based on equals(), not based on reference equality (==);</p>
</li>
<li>
<p>do not have accessible constructors, but are instead instantiated through factory methods which make no commitment as to the identity of returned instances;</p>
</li>
<li>
<p>are freely substitutable when equal, meaning that interchanging any two instances x and y that are equal according to equals() in any computation or method invocation should produce no visible change in behavior.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Item 1 requires level 1 immutability (all fields are  <code>@Final</code> ) but does not specify any of the restrictions we require for level 2 immutability.
Item 2 implies that should <code>equals</code>, <code>hashCode</code> or <code>toString</code> make a modification to the object, its state changes, which would then change the object with respect to other objects.
We could conclude that these three methods cannot be modifying.</p>
</div>
<div class="paragraph">
<p>Loosely speaking, objects of a value-based class can be identified by the values of their fields.
Level 2 immutability (or deeper) is not a requirement to be a value-based class.
However, we expect many level 2 immutable types will become value-classes.
Revisiting the example from the previous section, we can construct a counter-example:</p>
</div>
<div class="listingblock">
<div class="title">Example 45, level 2 immutable type which is not value-based</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">HasUniqueIdentifier</span>&lt;K&gt; {
    <span class="directive">public</span> <span class="directive">final</span> K k;
    <span class="directive">public</span> <span class="directive">final</span> <span class="type">int</span> identifier;

    <span class="annotation">@NotModified</span>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">AtomicInteger</span> generator = <span class="keyword">new</span> <span class="predefined-type">AtomicInteger</span>();

    <span class="directive">public</span> HasUniqueIdentifier(K k) {
        <span class="local-variable">this</span>.k = k;
        identifier = generator.getAndIncrement();
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> equals(<span class="predefined-type">Object</span> other) {
        <span class="keyword">if</span>(<span class="local-variable">this</span> == other) <span class="keyword">return</span> <span class="predefined-constant">true</span>;
        <span class="keyword">if</span>(other <span class="keyword">instanceof</span> HasUniqueIdentifier&lt;?&gt; hasUniqueIdentifier) {
            <span class="keyword">return</span> identifier == hasUniqueIdentifier.identifier;
        }
        <span class="keyword">return</span> <span class="predefined-constant">false</span>;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>equals</code> method violates item 2 of the value-class definition, maybe not to the letter but at least in its spirit: the field <code>k</code> is arguably the most important field, and its value is not taken into account when computing equality.</p>
</div>
</div>
<div class="sect2">
<h3 id="dynamic-type-annotations">9.7. Dynamic type annotations</h3>
<div class="paragraph">
<p>When it is clear a method returns an immutable set, but the formal type is <code>java.util.Set</code>, the  <code>@E2Immutable</code>  annotation can 'travel':</p>
</div>
<div class="listingblock">
<div class="title">Example 46, revisiting <code>SetBasedContainer6</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>
<span class="type">class</span> <span class="class">SetBasedContainer6</span>&lt;T&gt; {
    <span class="annotation">@E2Container</span>
    <span class="directive">public</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;T&gt; data;

    <span class="directive">public</span> SetBasedContainer4(<span class="predefined-type">Set</span>&lt;T&gt; ts) {
        <span class="local-variable">this</span>.data = <span class="predefined-type">Set</span>.copyOf(ts);
    }

    <span class="annotation">@E2Container</span>
    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;T&gt; getSet() {
        <span class="keyword">return</span> data;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Whilst <code>Set</code> in general is not  <code>@E2Immutable</code> , the <code>data</code> field itself is.</p>
</div>
<div class="paragraph">
<p>The computations that the analyser needs to track dynamic type annotations, are similar to those it needs to compute eventual immutability.
We introduce them in the next chapter.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="eventual-immutability">10. Eventual immutability</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section we explore types which follow a two-phase life cycle: the start off as mutable, then somehow become immutable.</p>
</div>
<div class="sect2">
<h3 id="_builders">10.1. Builders</h3>
<div class="paragraph">
<p>We start with the well-established <em>builder</em> paradigm.</p>
</div>
<div class="listingblock">
<div class="title">Example 47, static nested builder type</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>
<span class="type">class</span> <span class="class">Point</span> {
    <span class="directive">public</span> <span class="directive">final</span> <span class="type">double</span> x;
    <span class="directive">public</span> <span class="directive">final</span> <span class="type">double</span> y;

    <span class="directive">public</span> <span class="predefined-type">Point</span>(<span class="type">double</span> x, <span class="type">double</span> y) {
        <span class="local-variable">this</span>.x = x;
        <span class="local-variable">this</span>.y = y;
    }
}

<span class="annotation">@E2Container</span>
<span class="type">class</span> <span class="class">Polygon</span> {

    <span class="annotation">@E2Container</span>
    <span class="directive">public</span> <span class="directive">final</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">Point</span>&gt; points;

    <span class="directive">private</span> <span class="predefined-type">Polygon</span>(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Point</span>&gt; points) { <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="local-variable">this</span>.points = points;
    }

    <span class="annotation">@E1Container</span>(builds=<span class="predefined-type">Polygon</span>.class)
    <span class="directive">static</span> <span class="type">class</span> <span class="class">Builder</span> {

        <span class="annotation">@Modified</span>
        <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">Point</span>&gt; points = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;();

        <span class="annotation">@Modified</span>
        <span class="directive">public</span> <span class="type">void</span> addPoint(<span class="predefined-type">Point</span> point) {
            points.add(point);
        }

        <span class="annotation">@NotModified</span>
        <span class="directive">public</span> <span class="predefined-type">Polygon</span> build() {
            <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">Polygon</span>(<span class="predefined-type">List</span>.copyOf(points));
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The private constructor combined with the construction of an immutable copy in the <code>build</code> method guarantees level 2 immutability.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If your code can live with two different types (<code>Polygon.Builder</code>, <code>Polygon</code>) to represent polygons in their different stages (mutable, immutable), the builder paradigm is great.
If, on the other hand, you want to hold polygons in a type that spans both stages of the polygon lifecycle, it becomes difficult to do this with an eye on immutability.
One solution is the use of an interface that is implemented both by the builder and the immutable type.</p>
</div>
<div class="paragraph">
<p>The <a href="#support-firstthen">FirstThen</a> type can also assist in this situation: it holds an initial object (the <em>first</em>) until a state change occurs, and it is forced to hold a second object (the <em>then</em>).
Once it is in the final state, it cannot change anymore.
It is <em>eventually immutable</em>:</p>
</div>
<div class="listingblock">
<div class="title">Example 48, use of <code>FirstThen</code> to make a type eventually immutable</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">PolygonManager</span> {
    <span class="comment">// initially, the polygon is in builder phase</span>
    <span class="directive">public</span> <span class="directive">final</span> FirstThen&lt;<span class="predefined-type">Polygon</span>.Builder, <span class="predefined-type">Polygon</span>&gt; polygon =
        <span class="keyword">new</span> FirstThen&lt;&gt;(<span class="keyword">new</span> <span class="predefined-type">Polygon</span>.Builder());

    <span class="comment">// ...</span>

    <span class="directive">public</span> <span class="type">void</span> construct() {
        <span class="comment">// in builder phase ...</span>
        polygon.getFirst().add(point);
        <span class="comment">// transition</span>
        polygon.set(polygon.getFirst().build());
        <span class="comment">// from here on, polygon is immutable!</span>
    }

    <span class="directive">public</span> <span class="predefined-type">Point</span> firstPoint() {
        <span class="keyword">return</span> polygon.get().points.get(<span class="integer">0</span>);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_definition">10.2. Definition</h3>
<div class="paragraph">
<p>We propose a system of eventual immutability based on a single transition of state inside an object.</p>
</div>
<div class="listingblock">
<div class="title">Example 49, state change in a boolean field</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">frozen</span><span class="delimiter">&quot;</span></span>)
<span class="type">class</span> <span class="class">SimpleImmutableSet1</span>&lt;T&gt; {
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;T&gt; set = <span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;&gt;();
    <span class="directive">private</span> <span class="type">boolean</span> frozen;

    <span class="annotation">@Only</span>(before=<span class="string"><span class="delimiter">&quot;</span><span class="content">frozen</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">boolean</span> add(T t) {
        <span class="keyword">if</span>(frozen) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>();
        set.add(t);
    }

    <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">frozen</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">void</span> freeze() {
        <span class="keyword">if</span>(frozen) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>();
        frozen = <span class="predefined-constant">true</span>;
    }

    <span class="annotation">@Only</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">frozen</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> Stream&lt;T&gt; stream() {
        <span class="keyword">if</span>(!frozen) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>();
        <span class="keyword">return</span> set.stream();
    }

    <span class="annotation">@TestMark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">frozen</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">boolean</span> isFrozen() { <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="keyword">return</span> frozen;
    }

    <span class="directive">public</span> <span class="type">int</span> size() { <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="keyword">return</span> set.size();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>These methods can be called any time.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The analyser has no problem detecting the presence of preconditions, and observing that one method changes its own precondition.
The rules, however, are sufficiently general to support arbitrary preconditions, as shown in the following variant.
This example does not require an additional field, but relies on the empty/not-empty state change:</p>
</div>
<div class="listingblock">
<div class="title">Example 50, state change going from empty to non-empty</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">set</span><span class="delimiter">&quot;</span></span>)
<span class="type">class</span> <span class="class">SimpleImmutableSet2</span>&lt;T&gt; {
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;T&gt; set = <span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;&gt;();

    <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">set</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">void</span> initialize(<span class="predefined-type">Set</span>&lt;T&gt; data) {
        <span class="keyword">if</span>(!set.isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>();
        <span class="keyword">if</span>(data.isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>();
        set.addAll(data);
    }

    <span class="annotation">@Only</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">set</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> Stream&lt;T&gt; stream() {
        <span class="keyword">if</span>(set.isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>();
        <span class="keyword">return</span> set.stream();
    }

    <span class="directive">public</span> <span class="type">int</span> size() {
        <span class="keyword">return</span> set.size();
    }

    <span class="annotation">@TestMark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">set</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">boolean</span> hasBeenInitialised() {
        <span class="keyword">return</span> !set.isEmpty();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let us summarize the annotations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The  <code>@Mark</code>  annotation marks methods that change the state from <em>before</em> to <em>after</em>.</p>
</li>
<li>
<p>The  <code>@Only</code>  annotation identifies methods that, because of their precondition, can only be executed without raising an exception before (when complemented with a <code>before="&#8230;&#8203;"</code> parameter) or after (with a <code>after="&#8230;&#8203;"</code> parameter) the transition.</p>
</li>
<li>
<p>The analyser computes the  <code>@TestMark</code>  annotation on methods which return the state as a boolean.
There is a parameter to indicate that instead of returning <code>true</code> when the object is <em>after</em>, the method actually returns <code>true</code> on <em>before</em>.</p>
</li>
<li>
<p>Finally, the eventuality of the type shows in the <code>after="&#8230;&#8203;"</code> parameter of  <code>@E1Immutable</code> ,  <code>@E2Immutable</code>  or their container versions.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In each of these annotations, the actual value of the <code>&#8230;&#8203;</code> in the <code>after=</code> or <code>before=</code> parameters is the name of the field.</p>
</div>
<div class="paragraph">
<p>In case there are multiple fields involved, their names are represented in a comma-separated fashion.</p>
</div>
<div class="paragraph">
<p>The  <code>@Mark</code>  and  <code>@Only</code>  annotations can also be assigned to parameters, in the event that marked methods are called on a parameter of eventually immutable type.
Consider the following utility method for <a href="#support-eventuallyfinal">EventuallyFinal</a>, frequently used in the analyser:</p>
</div>
<div class="listingblock">
<div class="title">Example 51, utility method for <code>EventuallyFinal</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> &lt;T&gt; <span class="type">void</span> setFinalAllowEquals(
        <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">isFinal</span><span class="delimiter">&quot;</span></span>) EventuallyFinal&lt;T&gt; eventuallyFinal, T t) {
    <span class="keyword">if</span> (eventuallyFinal.isVariable() || !Objects.equals(eventuallyFinal.get(), t)) {
        eventuallyFinal.setFinal(t);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the <code>setFinal</code> method&#8217;s  <code>@Mark</code>  annotation travels to the parameter, where it is applied to the argument each time the static method is applied.</p>
</div>
</div>
<div class="sect2">
<h3 id="_propagation">10.3. Propagation</h3>
<div class="paragraph">
<p>The support types detailed in <a href="#support-classes">Support classes</a> can be used as building blocks to make ever more complex eventually immutable classes.
Effectively final fields of eventually immutable type will at some point hold objects that are in their final or <code>after</code> state, in which case they act as level 2 immutable fields.</p>
</div>
<div class="paragraph">
<p>The analyser itself consists of many eventually immutable classes; we show some examples in <a href="#in-the-analyser">Support classes in the analyser</a>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
For everyday use of eventual immutability, this is probably the most important consequence of all definitions up to now.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_before_the_mark">10.4. Before the mark</h3>
<div class="paragraph">
<p>A method can return an eventually immutable object, guaranteed to be in its initial or <code>before</code> state.
This can be annotated with  <code>@BeforeMark</code> .
Employing <code>SimpleImmutableSet1</code> from the example above,</p>
</div>
<div class="listingblock">
<div class="title">Example 52, <code>@BeforeMark</code> annotation</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@BeforeMark</span>
<span class="directive">public</span> SimpleImmutableSet1 create() {
    <span class="keyword">return</span> <span class="keyword">new</span> SimpleImmutableSet1();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, the analyser can compute a parameter to be  <code>@BeforeMark</code> , when in the method, at least one before-mark methods is called on the parameter.</p>
</div>
<div class="paragraph">
<p>Finally, a field can even be  <code>@BeforeMark</code> , when it is created or arrives in the type as  <code>@BeforeMark</code> , and stays in this state.
This situation must occur in a type with a  <code>@Finalizer</code> , as explained in <a href="#finalizers">Finalizers</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_extensions_of_annotations">10.5. Extensions of annotations</h3>
<div class="paragraph">
<p>When a type is eventually level 1 immutable, should the field(s) of the state transition be  <code>@Variable</code>  or  <code>@Final</code> ?
Similarly, when a type is eventually level 2 immutable, should the analyser mark the initially mutable or assignable fields  <code>@Modified</code>  or  <code>@NotModified</code>?</p>
</div>
<div class="paragraph">
<p>Basically, we propose to mark with the end state, qualifying with the parameter <code>after</code>:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">property</th>
<th class="tableblock halign-left valign-top">not present</th>
<th class="tableblock halign-left valign-top">eventually</th>
<th class="tableblock halign-left valign-top">effectively</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">finality of field</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"> <code>@Variable</code> </p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Final(after="mark")</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"> <code>@Final</code> </p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">non-modification of field</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"> <code>@Modified</code> </p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@NotModified(after="mark")</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"> <code>@NotModified</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Since in an IDE it is not too easy to have multiple visual markers, it seems best to use the same visuals as the end state.</p>
</div>
<div class="paragraph">
<p>When a type is effectively level 1 immutable (not eventually), all fields are effectively final.
The analyser wants to emphasise the rules needed to obtain (eventual) level 2 immutability, by clearly indicating which fields break the level 2 immutability rules.</p>
</div>
<div class="paragraph">
<p>Eventual finality simply adds a  <code>@Final(after="mark")</code> annotation to each of these situations.</p>
</div>
</div>
<div class="sect2">
<h3 id="_frameworks_and_contracts">10.6. Frameworks and contracts</h3>
<div class="paragraph">
<p>A fair number of Java frameworks introduce dependency injection and initializer methods.
This concept is, in many cases, compatible with the idea of eventual immutability: once dependency injection has taken place, and an initializing method has been called, the framework stops intervening in the value of the fields.</p>
</div>
<div class="paragraph">
<p>It is therefore not difficult to imagine, and implement in the analyser, a <em>before</em> state (initialization still ongoing) and an <em>after</em> state (initialization done) associated with the particular framework.
The example below shows how this could be done for the <code>Verticle</code> interface of the <a href="https://vertx.io" target="_blank" rel="noopener">vertx.io framework</a>.</p>
</div>
<div class="listingblock">
<div class="title">Example 53, excerpts and annotations of <code>Verticle.java</code> and <code>AbstractVerticle.java</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E1Container</span>(after = <span class="string"><span class="delimiter">&quot;</span><span class="content">init</span><span class="delimiter">&quot;</span></span>)
<span class="type">interface</span> <span class="class">Verticle</span> {

    <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">init</span><span class="delimiter">&quot;</span></span>)
    <span class="type">void</span> init(Vertx vertx, <span class="predefined-type">Context</span> context);

    <span class="annotation">@Only</span>(after = <span class="string"><span class="delimiter">&quot;</span><span class="content">init</span><span class="delimiter">&quot;</span></span>)
    Vertx getVertx();

    <span class="annotation">@Only</span>(after = <span class="string"><span class="delimiter">&quot;</span><span class="content">init</span><span class="delimiter">&quot;</span></span>)
    <span class="type">void</span> start(Promise&lt;<span class="predefined-type">Void</span>&gt; startPromise) <span class="directive">throws</span> <span class="exception">Exception</span>;

    <span class="annotation">@Only</span>(after = <span class="string"><span class="delimiter">&quot;</span><span class="content">init</span><span class="delimiter">&quot;</span></span>)
    <span class="type">void</span> stop(Promise&lt;<span class="predefined-type">Void</span>&gt; startPromise) <span class="directive">throws</span> <span class="exception">Exception</span>;
}

<span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">AbstractVerticle</span> <span class="directive">implements</span> Verticle {
    <span class="annotation">@Final</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">init</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">protected</span> Vertx vertx;

    <span class="annotation">@Final</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">init</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">protected</span> <span class="predefined-type">Context</span> context;

    <span class="annotation">@Override</span>
    <span class="directive">public</span> Vertx getVertx() {
        <span class="keyword">return</span> vertx;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> init(Vertx vertx, <span class="predefined-type">Context</span> context) {
        <span class="local-variable">this</span>.vertx = vertx;
        <span class="local-variable">this</span>.context = context;
    }
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Currently, mid 2021, contracted eventual immutability has not been implemented yet in the analyser.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="modification-part2">11. Modification, part 2</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section goes deeper into modification, linking and independence.
We start with cyclic references.</p>
</div>
<div class="sect2">
<h3 id="_cyclic_references">11.1. Cyclic references</h3>
<div class="paragraph">
<p>We need to study the situation of seemingly non-modifying methods with modifying parameters.
Up to now, a method is only modifying when it assigns to a field, calls a modifying method on one of the fields, or directly calls a modifying method on <code>this</code>.
However, there could be indirect modifications, as in:</p>
</div>
<div class="listingblock">
<div class="title">Example 54, indirect modifications</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">CyclicReferences</span> {

    <span class="annotation">@MutableModifiesArguments</span>
    <span class="directive">static</span> <span class="type">class</span> <span class="class">C1</span> {

        <span class="annotation">@Variable</span>
        <span class="directive">private</span> <span class="type">int</span> i;

        <span class="annotation">@Modified</span>
        <span class="directive">public</span> <span class="type">int</span> incrementAndGet() {
            <span class="keyword">return</span> ++i;
        }

        <span class="annotation">@Modified</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="directive">public</span> <span class="type">int</span> useC2(<span class="annotation">@Modified</span> C2 c2) {
            <span class="keyword">return</span> i + c2.incrementAndGetWithI();
        }

    }

    <span class="annotation">@E1Immutable</span>
    <span class="directive">static</span> <span class="type">class</span> <span class="class">C2</span> {

        <span class="directive">private</span> <span class="directive">final</span> <span class="type">int</span> j;

        <span class="annotation">@Modified</span>
        <span class="directive">private</span> <span class="directive">final</span> C1 c1;

        <span class="directive">public</span> C2(<span class="type">int</span> j, <span class="annotation">@Modified</span> C1 c1) {
            <span class="local-variable">this</span>.c1 = c1;
            <span class="local-variable">this</span>.j = j;
        }

        <span class="annotation">@Modified</span>
        <span class="directive">public</span> <span class="type">int</span> incrementAndGetWithI() {
            <span class="keyword">return</span> c1.incrementAndGet() + j;
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>useC2</code> does not directly modify <code>i</code>, but <code>incrementAndGetWithI</code> does so indirectly.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This observation forces us to tighten the definition of a non-modifying method: on top of the definition given above, we have to ensure that none of the modifying methods called on a parameter which is  <code>@Modified</code> , call one of 'our' modifying methods.
These rules are mostly, but not easily, enforceable when all code is visible.</p>
</div>
<div class="paragraph">
<p>An additional interface can help to remove the circular dependency between the types.
This has the advantage of simplicity, both for the programmer and the analyser, which at this point doesn&#8217;t handle circular dependencies very well.
It imposes more annotation work on the programmer, however, because the interface&#8217;s methods need contracts.</p>
</div>
</div>
<div class="sect2">
<h3 id="computing-dependence">11.2. How to compute linking</h3>
<div class="paragraph">
<p>To compute linking, the analyser tries to track actual objects, with the aim of knowing if a field links to another field or a parameter.
It computes a dependency graph of variables depending on other variables, with the following four basic rules:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Rule 1: in an assignment <code>v = w</code>, variable <code>v</code> links to variable <code>w</code>.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Rule 2: in an assignment <code>v = a.method(b)</code>,<code>v</code> potentially links to <code>a</code> and <code>b</code>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that saying <code>v</code> links to <code>a</code> is the same as saying that the return value of <code>method</code> links to some field inside <code>A</code>, the type of <code>a</code>.
This is especially clear when <code>a == this</code>.</p>
</div>
<div class="paragraph">
<p>We discern a number of special cases:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>When <code>v</code> is of  <code>@E2Immutable</code>  type, there cannot be any linking; <code>v</code> does not link to <code>a</code> nor <code>b</code>.</p>
</li>
<li>
<p>If <code>b</code> is of  <code>@E2Immutable</code>  type, <code>v</code> cannot link to <code>b</code>.</p>
</li>
<li>
<p>When <code>method</code> has the annotation  <code>@Independent</code> , <code>v</code> cannot link to <code>a</code>.</p>
</li>
<li>
<p>If <code>a</code> is of  <code>@Independent</code>  type (as defined in <a href="#independent-type">Independence of types</a>, it includes all  <code>@E2Immutable</code>  types), all its methods are independent; therefore, <code>v</code> cannot link to <code>a</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Recall that primitives, <code>java.lang.Object</code>, <code>java.lang.String</code>, and unbound parameter types, are  <code>@E2Immutable</code> .</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Rule 3: in an assignment <code>v = new A(b)</code>, <code>v</code> potentially links to <code>b</code>.</p>
</div>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>When the constructor <code>A</code> is independent, <code>v</code> cannot link to <code>b</code>.</p>
</li>
<li>
<p>When <code>b</code> is of  <code>@E2Immutable</code>  type, <code>v</code> cannot link to <code>b</code>.</p>
</li>
<li>
<p>If <code>A</code> is  <code>@E2Immutable</code> , then <code>v</code> cannot link to <code>b</code> nor <code>c</code>, because all constructors are independent.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Most of the other linking computations are consequences of the basic rules above.
For example,</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>in an assignment <code>v = condition ? a : b</code>, <code>v</code> links to both <code>a</code> and <code>b</code>.</p>
</li>
<li>
<p>type casting does not prevent linking: in <code>v = (Type)w</code>, <code>v</code> links to <code>w</code></p>
</li>
<li>
<p>Binary operators return primitives or <code>java.lang.String</code>, which prevents linking: in <code>v = a + b</code>, <code>v</code> does not link to <code>a</code> nor <code>b</code>.</p>
</li>
</ol>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Rule 4: in an array access <code>v = a[index]</code>, <code>v</code> links to <code>a</code>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Note: in a method call <code>v=a.method(b, c, d)</code>, links between <code>b</code>, <code>c</code>, and <code>d</code> are possible.
They are covered by the  <code>@Modified</code>  annotation:
when a parameter is  <code>@NotModified</code>, no modifications at all are possible, not even indirectly.</p>
</div>
</div>
<div class="sect2">
<h3 id="_locally_implemented_abstract_methods">11.3. Locally implemented abstract methods</h3>
<div class="paragraph">
<p>Abstract methods are present in interfaces, and abstract classes.
Their very definition is that no implementation is present at the place of definition: only the ins (parameters) and outs (return type) are pre-defined.</p>
</div>
<div class="paragraph">
<p>Functional interfaces are interfaces with a single abstract method; any other methods in the interface are required to have a <code>default</code> implementation.
The following table lists some frequently used ones:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">single abstract method (SAM)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Consumer&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void accept(T t);</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Function&lt;T,R&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>R apply(T t);</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BiFunction&lt;T, U, R&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>R apply(T t, U u);</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Supplier&lt;R&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>R get();</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Predicate&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean test(T t);</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>It is important not to forget that <em>any</em> interface defining a single abstract method can be seen as a functional interface.
While the examples above all employ generics (more specifically, unbound type parameters), generics are not a requirement for functional interfaces.
The Java language offers syntactic sugar for functional programming, but the types remain abstract Java types.</p>
</div>
<div class="paragraph">
<p>We will not make any distinction between a functional interface and an abstract type.
If one were forced to make one, the <em>intention to hold data</em> would be the dividing line between a functional interface, which conveys no such intention, and an abstract type, which does.</p>
</div>
<div class="paragraph">
<p>In this section we want to discuss a limited application of functional interfaces: the one where the SAMs have a local implementation.
The general case, where objects of abstract types come in via a parameter, will be addressed in <a href="#hidden-content">Hidden content</a>.
Consider the following example:</p>
</div>
<div class="listingblock">
<div class="title">Example 55, concrete implementation of suppliers</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E1Container</span>
<span class="type">class</span> <span class="class">ApplyLocalFunctions</span> {

    <span class="annotation">@Container</span>
    <span class="directive">static</span> <span class="type">class</span> <span class="class">Counter</span> {
        <span class="directive">private</span> <span class="type">int</span> counter;

        <span class="annotation">@Modified</span>
        <span class="directive">public</span> <span class="type">int</span> increment() {
            <span class="keyword">return</span> ++counter;
        }
    }

    <span class="annotation">@Modified</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="directive">private</span> <span class="directive">final</span> Counter myCounter = <span class="keyword">new</span> Counter();

    <span class="annotation">@Modified</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="directive">private</span> <span class="directive">final</span> Supplier&lt;<span class="predefined-type">Integer</span>&gt; getAndIncrement = myCounter::increment;

    <span class="annotation">@Modified</span>
    <span class="directive">private</span> <span class="directive">final</span> Supplier&lt;<span class="predefined-type">Integer</span>&gt; explicitGetAndIncrement = <span class="keyword">new</span> Supplier&lt;<span class="predefined-type">Integer</span>&gt;() {
        <span class="annotation">@Override</span> <span class="annotation">@Modified</span>
        <span class="directive">public</span> <span class="predefined-type">Integer</span> get() {
            <span class="keyword">return</span> myCounter.increment();
        }
    };

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">int</span> myIncrementer() {
        <span class="keyword">return</span> getAndIncrement.get();
    }

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">int</span> myExplicitIncrementer() {
        <span class="keyword">return</span> explicitGetAndIncrement.get();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Modified in <code>getAndIncrement</code> and <code>explicitGetAndIncrement</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Modified because its modifying method (<code>get</code>) is called in <code>myIncrementer</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The fields <code>getAndIncrement</code> and <code>explicitGetAndIncrement</code> hold instances of anonymous <em>inner classes</em> of <code>ApplyLocalFunctions</code>: these inner classes hold data, they have access to the <code>myCounter</code> field.
Their concrete implementations of <code>get</code> each modify <code>myCounter</code>.
A straightforward application of the rules of modification of fields makes  <code>getAndIncrement</code> and <code>explicitGetAndIncrement</code>  <code>@Modified</code> :
in <code>myIncrementer</code>, a modifying method is applied to <code>getAndIncrement</code>, and in <code>myExplicitIncrementer</code>, a modifying method is applied to <code>explicitGetAndIncrement</code>.</p>
</div>
<div class="paragraph">
<p>Given that <code>ApplyLocalFunctions</code> is clearly  <code>@E1Container</code> , and the inner classes hold no other data, the inner classes are  <code>@E1Container</code>  as well.</p>
</div>
<div class="paragraph">
<p>Now, if we move away from suppliers, but use consumers, we can discuss:</p>
</div>
<div class="listingblock">
<div class="title">Example 56, concrete implementation of consumers</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">ApplyLocalFunctions2</span> {

    <span class="annotation">@Container</span>
    <span class="directive">static</span> <span class="type">class</span> <span class="class">Counter</span> {
        <span class="directive">private</span> <span class="type">int</span> counter;

        <span class="annotation">@NotModified</span>
        <span class="directive">public</span> <span class="type">int</span> getCounter() {
            <span class="keyword">return</span> counter;
        }

        <span class="annotation">@Modified</span>
        <span class="directive">public</span> <span class="type">int</span> increment() {
            <span class="keyword">return</span> ++counter;
        }
    }

    <span class="annotation">@NotModified</span>
    <span class="directive">private</span> <span class="directive">final</span> Counter myCounter = <span class="keyword">new</span> Counter();

    <span class="annotation">@E2Immutable</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> Consumer&lt;Counter&gt; incrementer = Counter::increment;

    <span class="annotation">@E2Immutable</span>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> Consumer&lt;Counter&gt; explicitIncrementer = <span class="keyword">new</span> Consumer&lt;Counter&gt;() {
        <span class="annotation">@Override</span>
        <span class="annotation">@NotModified</span>
        <span class="directive">public</span> <span class="type">void</span> accept(<span class="annotation">@Modified</span> Counter counter) { <i class="conum" data-value="2"></i><b>(2)</b>
            counter.increment();
        }
    };

    <span class="annotation">@E2Container</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> Consumer&lt;Counter&gt; printer = counter -&gt;
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Have </span><span class="delimiter">&quot;</span></span> + counter.getCounter());

    <span class="annotation">@E2Container</span>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> Consumer&lt;Counter&gt; explicitPrinter = <span class="keyword">new</span> Consumer&lt;Counter&gt;() {
        <span class="annotation">@Override</span>
        <span class="annotation">@NotModified</span>
        <span class="directive">public</span> <span class="type">void</span> accept(<span class="annotation">@NotModified</span> Counter counter) { <i class="conum" data-value="4"></i><b>(4)</b>
            <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Have </span><span class="delimiter">&quot;</span></span> + counter.getCounter());
        }
    };

    <span class="directive">private</span> <span class="type">void</span> apply(<span class="annotation">@Container</span>(contract = <span class="predefined-constant">true</span>) Consumer&lt;Counter&gt; consumer) { <i class="conum" data-value="5"></i><b>(5)</b>
        consumer.accept(myCounter);
    }

    <span class="directive">public</span> <span class="type">void</span> useApply() {
        apply(printer); <span class="comment">// should be fine</span>
        apply(explicitPrinter);
        apply(incrementer); <span class="comment">// should cause an ERROR </span><i class="conum" data-value="6"></i><b>(6)</b>
        apply(explicitIncrementer); <span class="comment">// should cause an ERROR</span>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The anonymous type is static, has no fields, so is at least  <code>@E2Immutable</code> .
It is not a container.
This is clearly visible in the explicit variant&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Here we see why <code>incrementer</code> is not a container: the method modifies its parameters.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Now, we have a container, because in the anonymous type does not modify its parameters.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Explicitly visible here in <code>explicitPrinter</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>If we insist that all parameters are containers, &#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>We can use the annotations to detect errors.
Here, <code>incrementer</code> is not a container.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Using the  <code>@Container</code>  annotation in a dynamic way allows us to control which abstract types can use the method:
when only containers are allowed, then the abstract types must not have implementations which change their parameters.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hidden-content">12. Hidden content</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section, we consider modifications to the hidden content of a type, and when they are of importance.
We give a formal definition of deeply or recursively immutable, and a sliding scale between level 2 and recursively immutable.</p>
</div>
<div class="sect2">
<h3 id="_visitors">12.1. Visitors</h3>
<div class="paragraph">
<p>Let&#8217;s start by going back to <code>NonEmptyImmutableList</code>, first defined in <a href="#abstract-methods">Abstract methods</a>:</p>
</div>
<div class="listingblock">
<div class="title">Example 57, revisiting <code>NonEmptyImmutableList</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>
<span class="type">interface</span> <span class="class">NonEmptyImmutableList</span>&lt;T&gt; <span class="directive">extends</span> HasSize {

    <span class="comment">// implicitly present: @NotModified</span>
    <span class="annotation">@Independent</span>
    T first();

    <span class="comment">// implicitly present: @NotModified</span>
    <span class="type">void</span> visit(Consumer&lt;T&gt; consumer); <span class="comment">// @IgnoreModifications</span>

    <span class="annotation">@Constant</span>
    <span class="annotation">@NotModified</span>
    <span class="annotation">@Override</span>
    <span class="keyword">default</span> <span class="type">boolean</span> isEmpty() {
        <span class="keyword">return</span> <span class="predefined-constant">false</span>;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We start the discussion with the following level 2 immutable implementation of this interface:</p>
</div>
<div class="listingblock">
<div class="title">Example 58, level 2 immutable implementation of <code>NonEmptyImmutableList</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>
<span class="type">class</span> <span class="class">ImmutableOne</span>&lt;T&gt; <span class="directive">implements</span> NonEmptyImmutableList&lt;T&gt; {
    <span class="directive">private</span> <span class="directive">final</span> T t;

    <span class="directive">public</span> ImmutableOne(<span class="annotation">@Dependent1</span> T t) { <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="local-variable">this</span>.t = t;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">int</span> size() {
        <span class="keyword">return</span> <span class="integer">1</span>;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> T first() {
        <span class="keyword">return</span> t;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> visit(Consumer&lt;T&gt; consumer) {
        consumer.accept(t);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Annotation will be explained shortly.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>We need the <code>visit</code> method (1) to be non-modifying, and (2) not to modify its parameter <code>consumer</code>.
However, following the normal definitions of modification, the following two statements hold:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Because <code>accept</code> is  <code>@Modified</code> , we should mark the parameter <code>consumer</code> as  <code>@Modified</code> .</p>
</li>
<li>
<p>Because <code>t</code>, the parameter of <code>accept</code>, is  <code>@Modified</code> , we should mark <code>visit</code> as  <code>@Modified</code> .</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The result of the first statement would violate the <code>@Container</code> property on <code>ImmutableOne</code>, and we&#8217;d be very reluctant to do that:
according to the intuitive definition in <a href="#containers">Containers</a>, <code>ImmutableOne</code> is a type that holds data, but does not change it.
This statement still holds in the presence of a <code>visit</code> method, which is nothing but a way of exposing the object in a way similar to the method <code>first</code>.
The second one would make <code>visit</code> modifying, which again goes against our intuition: looping over elements is, in itself, not modifying.</p>
</div>
<div class="paragraph">
<p>Luckily, there are two observations that come to the rescue.</p>
</div>
<div class="paragraph">
<p>First, we believe it is correct to assume that concrete implementations of <code>Consumer</code> can be semantically unrelated to <code>ImmutableOne</code>.
As a consequence, we could say that the only modifications that concern us in this <code>visit</code> method are the modifications to <code>accept</code> 's parameter <code>t</code>.
Other modifications, for example those to the fields of the type in which the implementation is present, may be considered to be outside our scope.
However, if we replace <code>Consumer</code> with <code>Set</code> and <code>accept</code> with <code>add</code>, we encounter a modification that we really do not want to ignore, in an otherwise equal setting.
Therefore, it does not look like we can reason away potential modifications by <code>accept</code>.
We will have to revert to a contracted  <code>@IgnoreModifications</code>  annotation on the parameter <code>consumer</code>, if we want to avoid <code>ImmutableOne</code> losing the <code>@Container</code> property.</p>
</div>
<div class="paragraph">
<p>The second modification, however, is one we will ignore in the <code>ImmutableOne</code> type, and <em>defer</em> or <em>propagate</em> to the place where a concrete implementation of the consumer is presented.
We can ignore it here, because <code>t</code> is of level 2 immutable type; what happens to its content happens outside the zone of control of <code>ImmutableOne</code>.
The fact that <em>immutable content</em> (properly defined shortly) is passed on as an argument to a method of <code>consumer</code> will be reflected by a {dependent1} annotation.
It will take care of the propagation of modifications from the concrete implementation into the immutable content.</p>
</div>
<div class="paragraph">
<p>This results in the following annotations for <code>visit</code> in <code>ImmutableOne</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example 59, the <code>visit</code> method in <code>ImmutableOne</code>, fully annotated</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@NotModified</span>
<span class="directive">public</span> <span class="type">void</span> visit(<span class="annotation">@IgnoreModifications</span> <span class="annotation">@Dependent1</span> Consumer&lt;T&gt; consumer) {
    consumer.accept(t);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that we assume that we will need  <code>@IgnoreModifications</code>  for almost every use of a functional interface from <code>java.util.function</code> occurring as a parameter.
These types are for generic use; one should never use them to represent some specific data type where modifications are of concern to the current type.
Therefore, we make this annotation implicit in exactly this context.</p>
</div>
<div class="paragraph">
<p>Looking at the more general case of a <code>forEach</code> implementation iterating over a list or array, we therefore end up with:</p>
</div>
<div class="listingblock">
<div class="title">Example 60, a generic <code>forEach</code> implementation</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@NotModified</span>
<span class="directive">public</span> <span class="type">void</span> forEach(<span class="annotation">@Dependent1</span> Consumer&lt;T&gt; consumer) {
    <span class="keyword">for</span>(T t: list) consumer.accept(t);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Modifications to the parameter, made by the concrete implementation, are propagated into the immutable content of <code>list</code>, as described in the next section.
The {dependent1} annotation appears because immutable content in <code>list</code> is exposed to the <code>consumer</code> parameter.
This annotation does not appear for the modifiable content of the level 2 immutable type.
Parameters of modifiable type are already shielded from external modification by the  <code>@Independent</code>  annotation, which is "trivial" for level 2 immutable types.</p>
</div>
</div>
<div class="sect2">
<h3 id="_modifiable_vs_immutable_content">12.2. Modifiable vs immutable content</h3>
<div class="paragraph">
<p>In the following example, a field of level 2 immutable type holds explicitly mutable data:</p>
</div>
<div class="listingblock">
<div class="title">Example 61, a field of more complex type</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>
<span class="type">class</span> <span class="class">EncapsulatedImmutableArrayOfHasSize</span> <span class="directive">implements</span> NonEmptyImmutableList&lt;HasSize&gt; {

    <span class="directive">private</span> <span class="directive">final</span> ImmutableOne&lt;HasSize<span class="type">[]</span>&gt; one;

    <span class="directive">public</span> EncapsulatedImmutableArrayOfHasSize(<span class="type">int</span> size,
            <span class="annotation">@Dependent1</span> Supplier&lt;HasSize&gt; generator) { <i class="conum" data-value="1"></i><b>(1)</b>
        HasSize<span class="type">[]</span> elements = <span class="keyword">new</span> HasSize[size];
        <span class="predefined-type">Arrays</span>.setAll(elements, i -&gt; generator.get());
        one = <span class="keyword">new</span> ImmutableOne&lt;&gt;(elements);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">int</span> size() {
        <span class="keyword">return</span> <span class="predefined-type">Arrays</span>.stream(one.first()).mapToInt(HasSize::size).sum();
    }

    <span class="annotation">@Override</span>
    <span class="annotation">@Dependent1</span>
    <span class="directive">public</span> HasSize first() {
        <span class="keyword">return</span> one.first()[<span class="integer">0</span>];
    }

    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> HasSize get(<span class="type">int</span> index) {
        <span class="keyword">return</span> one.first()[index];
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> visit(<span class="annotation">@Dependent1</span> Consumer&lt;HasSize&gt; consumer) {
        <span class="keyword">for</span> (HasSize element : one.first()) consumer.accept(element);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>See further, in <a href="#immutable-content-linking">Immutable content linking</a>: the immutable content of this type links to the <code>generator</code> parameter.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The object graph of the field <code>one</code> consists of a level 2 immutable type (<code>ImmutableOne</code>), which in turn holds an array of level 2 immutable type objects (<code>HasSize</code>).</p>
</div>
<div class="paragraph">
<p>As an aside, we note that arrays are essentially level 1 immutable constructs: a chunk of memory is held in an effectively final field, and array access reads and writes from this memory object.
Indeed, consider the following semi-realistic implementation:</p>
</div>
<div class="listingblock">
<div class="title">Example 62, an array is a level 1 immutable container</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E1Container</span>
<span class="type">interface</span> <span class="class">Array</span>&lt;T&gt; {
    <span class="type">int</span> length();

    T get(<span class="type">int</span> index);

    <span class="annotation">@Modified</span>
    <span class="type">void</span> set(<span class="type">int</span> index, T t);
}

<span class="annotation">@E1Container</span>
<span class="type">interface</span> <span class="class">ConsecutiveBytes</span> {
    <span class="type">int</span> size();

    <span class="type">byte</span><span class="type">[]</span> get(<span class="type">int</span> pos, <span class="type">int</span> n);

    <span class="annotation">@Modified</span>
    <span class="type">void</span> set(<span class="type">int</span> pos, <span class="type">byte</span><span class="type">[]</span> bytes);
}

<span class="annotation">@E1Container</span>
<span class="type">class</span> <span class="class">ArrayImpl</span>&lt;T&gt; <span class="directive">implements</span> <span class="predefined-type">Array</span>&lt;T&gt; {
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="type">int</span> bytesInObject = <span class="integer">4</span>;
    <span class="directive">private</span> <span class="directive">final</span> ConsecutiveBytes bytes;

    <span class="directive">public</span> ArrayImpl(<span class="type">int</span> size) {
        bytes = <span class="keyword">new</span> ConsecutiveBytes(size * bytesInObject);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">int</span> length() { <span class="keyword">return</span> bytes.size() / bytesInObject; }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> T get(<span class="type">int</span> i) {
        <span class="keyword">return</span> (T) bytes.get(i * bytesInObject, bytesInObject);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> set(<span class="type">int</span> index, T t) {
        bytes.set(index * bytesInObject, bytesInObject);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returning the to initial topic, we see that the array is not transparent (see <a href="#generics">Generics</a>) in <code>EncapsulatedImmutableArrayOfHasSize</code>:
its values are set in the constructor, and read in almost all methods.
The array clearly is modifiable, and its content is clearly level 2 immutable.</p>
</div>
<div class="paragraph">
<p>It is clear that the array belongs to the modifiable data, whilst the content of the array is part of the immutable content of the type <code>EncapsulatedImmutableArrayOfHasSize</code>.
In general,</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>The <strong>immutable content</strong> of a level 1 immutable type are those parts of the object graphs of the fields that are level 2 immutable, and do not contain accessible, modifiable sub-fields.
The rest of the content is called the <strong>modifiable content</strong> of the level 1 immutable type.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Why do we say level 1 immutable here?
We want to be able to use the concept of immutable content, {dependent1}, and propagation of modification in types like <code>Collection</code>, <code>Set</code> and <code>List</code>!
They will often not be level 2 immutable, yet they have a <code>forEach</code> or <code>visit</code> independent of their immutable status.
It is the modifiable content which is insufficiently shielded, or which is actively modified, that prevents a level 1 immutable type from becoming level 2 immutable.
The immutable content cannot be the differentiator between level 1 and level 2 immutable.</p>
</div>
</div>
<div class="sect2">
<h3 id="_deeply_immutable_types">12.3. Deeply immutable types</h3>
<div class="paragraph">
<p>We briefly note that the point of propagating modifications to the immutable content, the topic of this chapter, is not relevant when this immutable content is <em>deeply immutable</em>.
We have used the latter concept a few times already; now is a good time to define it formally.</p>
</div>
<div class="paragraph">
<p>A first, necessary restriction for a type to be deeply immutable is that it cannot be extended, i.e., it should be marked as <code>final</code>.
This prevents the creation of sub-types which hold data that is inaccessible to the formal parent type, yet potentially modifiable when exposed in a concrete situation, exactly as we are discussing in this chapter.
Note that the Java types that have literals associated with them, the primitives and <code>java.lang.String</code>, cannot be extended.
They will form the basis of a recursive definition.
Also note that by definition, a Java 16 <code>record</code> type cannot be extended.</p>
</div>
<div class="paragraph">
<p>The rest of the restrictions follow the rules of level 2 immutability in a remarkably similar way.
Loosely speaking, we still allow for modifiable content, as long as it is properly shielded and not modified, but we require the immutable content to be deeply immutable.
More formally,</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>A type is <em>deeply immutable</em> when the following restrictions hold at the same time:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>the type cannot be extended (it is explicitly marked <code>final</code>)</p>
</li>
<li>
<p>its fields are effectively final ( <code>@Final</code> )</p>
</li>
<li>
<p>its fields are not modified ( <code>@NotModified</code>)</p>
</li>
<li>
<p>its fields are either private, or of deeply immutable type</p>
</li>
<li>
<p>its non-private methods and constructors do not expose the non-deeply immutable content of the fields</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>It is straightforward to see that deeply immutable types are also level 2 immutable.
We will not spend more time on deeply immutable constructs, hence not elaborate on the details of rule 5.</p>
</div>
</div>
<div class="sect2">
<h3 id="_propagating_modifications">12.4. Propagating modifications</h3>
<div class="paragraph">
<p>Let us apply the <code>visit</code> method of <code>NonEmptyImmutableList</code> to <code>StringBuilder</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example 63, propagating the modification of <code>visit</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">static</span> <span class="type">void</span> print(<span class="annotation">@NotModified</span> NonEmptyImmutableList&lt;<span class="predefined-type">StringBuilder</span>&gt; list) {
    one.visit(<span class="predefined-type">System</span>.out::println); <i class="conum" data-value="1"></i><b>(1)</b>
}

<span class="directive">static</span> <span class="type">void</span> addNewLine(<span class="annotation">@Modified</span> NonEmptyImmutableList&lt;<span class="predefined-type">StringBuilder</span>&gt; list) {
    one.visit(sb -&gt; sb.append(<span class="string"><span class="delimiter">&quot;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>)); <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Non-modifying method implies no modification on the immutable content of <code>list</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Parameter-modifying lambda propagates a modification to <code>list</code> 's immutable content.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is the second method, <code>addNewLine</code>, that is of importance here.
Thanks to the {dependent1} annotation, we know of a modification to <code>list</code>, even if <code>list</code> is of level 2 immutable type!
It may help to see the for-loop written out, if we temporarily assume that we have added an implementation of <code>Iterable</code> to <code>NonEmptyImmutableList</code>, functionally identical to <code>visit</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example 64, alternative implementation of <code>addNewLine</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">static</span> <span class="type">void</span> addNewLine(<span class="annotation">@Modified</span> NonEmptyImmutableList&lt;<span class="predefined-type">StringBuilder</span>&gt; list) {
    <span class="keyword">for</span>(<span class="predefined-type">StringBuilder</span> sb: list) {
      sb.append(<span class="string"><span class="delimiter">&quot;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We really need the link between <code>sb</code> and <code>list</code> for the modification on <code>sb</code> to propagate to <code>list</code>.
Without this propagation, we would not be able to implement the full definition of modification of parameters, as stipulated in <a href="#modification">Modification</a>, in this relatively straightforward, and probably frequently occurring situation.</p>
</div>
<div class="paragraph">
<p>Moving from <code>NonEmptyImmutableList</code> to <code>NonEmptyList</code>, defined <a href="#NonEmptyList">here</a>, which has a modifying method, allows us to contrast two different modifications:</p>
</div>
<div class="listingblock">
<div class="title">Example 65, contrasting the modification on the parameter <code>sb</code> to that on <code>list</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">static</span> <span class="type">void</span> addNewLine(<span class="annotation">@Modified</span> NonEmptyList&lt;<span class="predefined-type">StringBuilder</span>&gt; list) {
    list.visit(sb -&gt; sb.append(<span class="string"><span class="delimiter">&quot;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>)); <i class="conum" data-value="1"></i><b>(1)</b>
}

<span class="directive">static</span> <span class="type">void</span> replace(<span class="annotation">@Modified</span> NonEmptyList&lt;<span class="predefined-type">StringBuilder</span>&gt; list) {
    list.setFirst(<span class="keyword">new</span> <span class="predefined-type">StringBuilder</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">?</span><span class="delimiter">&quot;</span></span>)); <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Modification to the immutable content of <code>list</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Modification to the modifiable content of <code>list</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Without storing additional information (e.g., using an as yet undefined annotation like <code>@Modified1</code> on <code>list</code> in <code>addNewLine</code>), however, we cannot make the distinction between a modification to the string builders inside <code>list</code>, or a modification to <code>list</code> itself.
In other words, applying the two methods further on, we cannot</p>
</div>
<div class="listingblock">
<div class="title">Example 66, using <code>print</code> and <code>addNewLine</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">static</span> <span class="predefined-type">String</span> useAddNewLine(<span class="annotation">@NotModified</span> <span class="predefined-type">StringBuilder</span> input) { <i class="conum" data-value="1"></i><b>(1)</b>
    NonEmptyList&lt;<span class="predefined-type">StringBuilder</span>&gt; list = <span class="keyword">new</span> One&lt;&gt;();
    list.setFirst(input);
    addNewLine(list);
    <span class="keyword">return</span> list.getFirst().toString();
}

<span class="directive">static</span> <span class="predefined-type">String</span> useReplace(<span class="annotation">@NotModified</span> <span class="predefined-type">StringBuilder</span> input) {
    NonEmptyList&lt;<span class="predefined-type">StringBuilder</span>&gt; list = <span class="keyword">new</span> One&lt;&gt;();
    list.setFirst(input);
    replace(list); <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="keyword">return</span> list.getFirst().toString();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Should be  <code>@Modified</code> , however, in the 3rd statement we cannot know that the modification is to <code>input</code> rather than to <code>list</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This action discards <code>input</code> from <code>list</code> without modifying it.</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>The example shows that the introduction of {dependent1} only gets us so far: from the concrete, modifying implementation, to the parameter (or field).
We do not plan to keep track of the distinction between modification of immutable content vs modification of modifiable content to a further extent.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Finally, we mention again the modification to a field from a concrete lambda:</p>
</div>
<div class="listingblock">
<div class="title">Example 67, modification of a field outside the scope</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; strings = ...
<span class="annotation">@Modified</span>
<span class="type">void</span> addToStrings(<span class="annotation">@NotModified</span> NonEmptyList&lt;<span class="predefined-type">StringBuilder</span>&gt; list) {
  list.visit(sb -&gt; strings.add(sb.toString()));
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="immutable-content-linking">12.5. Immutable content linking</h3>
<div class="paragraph">
<p>Going back to <code>ImmutableOne</code>, we see that the constructor links the parameter <code>t</code> to the instance&#8217;s field by means of assignment.
Let us call this binding of parameters of immutable content to the field <em>content linking</em>, and mark it using {dependent1}, <em>content dependence</em>:</p>
</div>
<div class="listingblock">
<div class="title">Example 68, constructor of <code>ImmutableOne</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">private</span> <span class="directive">final</span> T t;

<span class="directive">public</span> ImmutableOne(<span class="annotation">@Dependent1</span> T t) {
    <span class="local-variable">this</span>.t = t;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returning a part of the immutable content of the type, or exposing it as argument, both warrants a {dependent1} annotation:</p>
</div>
<div class="listingblock">
<div class="title">Example 69, more methods of <code>ImmutableOne</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Dependent1</span>
<span class="annotation">@Override</span>
<span class="directive">public</span> T first() {
    <span class="keyword">return</span> t;
}

<span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">void</span> visit(<span class="annotation">@Dependent1</span> Consumer&lt;T&gt; consumer) {
    consumer.accept(t);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Observe that content dependence implies 'normal' independence, as described in <a href="#linking-and-independence">Linking, independence</a> and <a href="#computing-dependence">How to compute linking</a>, exactly because we are dealing with parameters of level 2 immutable type.</p>
</div>
<div class="paragraph">
<p>Another place where the immutable content linking can be seen, is the <em>for-each</em> statement:</p>
</div>
<div class="listingblock">
<div class="title">Example 70, for-each loop and immutable content linking</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ImmutableList&lt;<span class="predefined-type">StringBuilder</span>&gt; list = ...;
<span class="predefined-type">List</span>&lt;<span class="predefined-type">StringBuilder</span>&gt; builders = ...;
<span class="keyword">for</span>(<span class="predefined-type">StringBuilder</span> sb: list) {
    builders.add(sb);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because the <code>Collection</code> API contain an <code>add</code> method annotated as:</p>
</div>
<div class="listingblock">
<div class="title">Example 71, <code>add</code> in <code>Collection</code> annotated</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Modified</span>
<span class="type">boolean</span> add(<span class="annotation">@NotNull</span> <span class="annotation">@Dependent1</span> E e);</code></pre>
</div>
</div>
<div class="paragraph">
<p>indicating that after calling <code>add</code>, the argument will become part of the immutable content of the collection, we conclude that the local loop variable <code>sb</code> gets content linked to the <code>builders</code> list.
Similarly, this loop variable contains immutable content from the <code>list</code> object.</p>
</div>
<div class="paragraph">
<p>We reuse the annotation {dependent1} to indicate that the immutable content of two objects are linked.
Let us look at a possible implementation of <code>Collection.addAll</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example 72, a possible implementation of <code>addAll</code> in <code>Collection</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Modified</span>
<span class="type">boolean</span> addAll(<span class="annotation">@NotNull1</span> <span class="annotation">@Dependent1</span> <span class="predefined-type">Collection</span>&lt;? <span class="directive">extends</span> E&gt; collection) {
    <span class="type">boolean</span> modified = <span class="predefined-constant">false</span>;
    <span class="keyword">for</span> (E e : c) <span class="keyword">if</span> (add(e)) modified = <span class="predefined-constant">true</span>;
    <span class="keyword">return</span> modified;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The call to <code>add</code> content links <code>e</code> to <code>this</code>.
Because <code>e</code> is also content linked to <code>c</code>, the parameter <code>collection</code> holds immutable content linked to the immutable content of the instance.</p>
</div>
<div class="paragraph">
<p>We are now properly armed to see how a for-each loop can be implemented using an iterator whose immutable content links to that of a level 1 immutable container.</p>
</div>
</div>
<div class="sect2">
<h3 id="_iterator_iterable_loops">12.6. Iterator, Iterable, loops</h3>
<div class="paragraph">
<p>Let us start with the simplest definition of an iterator, without <code>remove</code> method:</p>
</div>
<div class="listingblock">
<div class="title">Example 73, the <code>Iterator</code> type, without <code>remove</code> method</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E1Container</span>
<span class="type">interface</span> <span class="class">Iterator</span>&lt;T&gt; {

    <span class="annotation">@Modified</span>
    <span class="annotation">@Dependent1</span>
    T next();

    <span class="annotation">@Modified</span>
    <span class="type">boolean</span> hasNext();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Either the <code>next</code> method, or the <code>hasNext</code> method, must make a change to the iterator, because it has to keep track of the next element.
As such, we make both  <code>@Modified</code> .
Following the discussion in the previous section, <code>next</code> is {dependent1}, because it returns part of the immutable content held by the iterator.</p>
</div>
<div class="paragraph">
<p>The interface <code>Iterable</code> is a supplier of iterators:</p>
</div>
<div class="listingblock">
<div class="title">Example 74, the <code>Iterable</code> type</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>
<span class="type">interface</span> <span class="class">Iterable</span>&lt;T&gt; {

    <span class="annotation">@Dependent1</span>
    <span class="predefined-type">Iterator</span>&lt;T&gt; iterator();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>First, creating an iterator should never be a modifying operation on a type.
Typically, as we explore in the next section, it implies creating a sub-type, static or not, of the type implementing <code>Iterable</code>.
Second, the iterator itself is independent of the fields of the implementing type, but has the ability to return its immutable content.</p>
</div>
<div class="paragraph">
<p>The loop, on a variable <code>list</code> of type implementing <code>Iterable&lt;T&gt;</code>, is expressed as <code>for(T t: list) { &#8230;&#8203; }</code>, and can be interpreted as</p>
</div>
<div class="listingblock">
<div class="title">Example 75, implementation of for-each using an <code>Iterator</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Iterator</span>&lt;T&gt; it = list.iterator();
<span class="keyword">while</span>(it.hasNext()) {
    T t = it.next();
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The iterator <code>it</code> content-links to <code>list</code>; via the <code>next</code> method, it content-links the immutable content of the <code>list</code> to <code>t</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="independent-type">12.7. Independence of types</h3>
<div class="paragraph">
<p>A concrete implementation of an iterator is often a nested type, static or not (inner class), of the iterable type:</p>
</div>
<div class="listingblock">
<div class="title">Example 76, implementation of an <code>Iterator</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ImmutableArray</span>&lt;T&gt; <span class="directive">implements</span> <span class="predefined-type">Iterable</span>&lt;T&gt; {

    <span class="annotation">@NotNull1</span>
    <span class="directive">private</span> <span class="directive">final</span> T<span class="type">[]</span> elements;

    <span class="annotation">@SuppressWarnings</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">unchecked</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> ImmutableArray(<span class="predefined-type">List</span>&lt;T&gt; input) {
        <span class="local-variable">this</span>.elements = (T<span class="type">[]</span>) input.toArray();
    }

    <span class="annotation">@Override</span>
    <span class="annotation">@Independent</span>
    <span class="directive">public</span> <span class="predefined-type">Iterator</span>&lt;T&gt; iterator() {
        <span class="keyword">return</span> <span class="keyword">new</span> IteratorImpl();
    }

    <span class="annotation">@Container</span>
    <span class="annotation">@Independent</span>
    <span class="type">class</span> <span class="class">IteratorImpl</span> <span class="directive">implements</span> <span class="predefined-type">Iterator</span>&lt;T&gt; {
        <span class="directive">private</span> <span class="type">int</span> i;

        <span class="annotation">@Override</span>
        <span class="directive">public</span> <span class="type">boolean</span> hasNext() {
            <span class="keyword">return</span> i &lt; elements.length;
        }

        <span class="annotation">@Override</span>
        <span class="annotation">@NotNull</span>
        <span class="directive">public</span> T next() {
            <span class="keyword">return</span> elements[i++];
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For <code>ImmutableArray</code> to be level 2 immutable, the <code>iterator()</code> method must be independent of the field <code>elements</code>.
How do we know this?
The implementation type <code>IteratorImpl</code> cannot be level 2 immutable, because it needs to hold the state of the iterator.
However, it should protect the fields owned by its enclosing type.
We propose to add a definition for the independence of a type, very similar to the definition of level 2 immutability:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition</strong>: A type is <strong>independent</strong> when it follows these three rules:</p>
</div>
<div class="paragraph">
<p><strong>Rule 1</strong>: All constructor parameters linked to fields, and therefore all fields linked to constructor parameters, must be  <code>@NotModified</code>;</p>
</div>
<div class="paragraph">
<p><strong>Rule 2</strong>: All fields linked to constructor parameters must be either private or level 2 immutable;</p>
</div>
<div class="paragraph">
<p><strong>Rule 3</strong>: All return values of methods must be independent of the fields linked to constructor parameters.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The static variant of <code>IteratorImpl</code> makes rules 1 and 2 more obvious:</p>
</div>
<div class="listingblock">
<div class="title">Example 77, implementation of an <code>Iterator</code> as a static nested type</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ImmutableArray</span>&lt;T&gt; <span class="directive">implements</span> <span class="predefined-type">Iterable</span>&lt;T&gt; {
    ...

    <span class="annotation">@Container</span>
    <span class="annotation">@Independent</span>
    <span class="directive">static</span> <span class="type">class</span> <span class="class">IteratorImpl</span> <span class="directive">implements</span> <span class="predefined-type">Iterator</span>&lt;T&gt; {
        <span class="annotation">@Modified</span>
        <span class="directive">private</span> <span class="type">int</span> i;

        <span class="directive">private</span> <span class="directive">final</span> T<span class="type">[]</span> elements;

        <span class="directive">private</span> IteratorImpl(T<span class="type">[]</span> elements) {
            <span class="local-variable">this</span>.elements = elements;
        }

        <span class="annotation">@Override</span>
        <span class="directive">public</span> <span class="type">boolean</span> hasNext() {
            <span class="keyword">return</span> i &lt; elements.length;
        }

        <span class="annotation">@Override</span>
        <span class="annotation">@NotNull</span>
        <span class="annotation">@Modified</span>
        <span class="directive">public</span> T next() {
            <span class="keyword">return</span> elements[i++];
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The rules enforce that the data received from, or owned by, the enclosing type, remains properly shielded.</p>
</div>
</div>
<div class="sect2">
<h3 id="_immutable_content_and_eventual_immutability">12.8. Immutable content and eventual immutability</h3>
<div class="paragraph">
<p>How does the whole story of eventual level 1 or level 2 immutability mix with immutable content?
At some point, once a necessary precondition has been met, the immutable content will be well-defined, and modifying methods become unavailable.
Before that, fields that will eventually contain the immutable content may still be <code>null</code>, or may be re-assigned.
This should not have any effect, however, on the computation of immutable content linking, {dependent1} annotations, and the propagation of modifications, since the actual types do not change.
The two concepts are sufficiently perpendicular to each other, and can easily co-exist.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="support-classes">13. Support classes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>e2immu-support-1.0.0.jar</code> library (in whichever version it comes) essentially contains the annotations of the analyser, and a small selection of support types.
They are the eventually immutable building blocks that you can use in your project, irrespective of whether you want analyser support or not.</p>
</div>
<div class="paragraph">
<p>We discuss a selection of the building blocks here.</p>
</div>
<div class="sect2">
<h3 id="support-flipswitch">13.1. FlipSwitch</h3>
<div class="paragraph">
<p>Simpler than <code>FlipSwitch</code> is not possible for an eventually immutable type: it consists solely of a single boolean, which is at the same time the data and the guard:</p>
</div>
<div class="listingblock">
<div class="title">Example 78, most of <code>org.e2immu.support.FlipSwitch</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>(after = <span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">FlipSwitch</span> {

    <span class="annotation">@Final</span>(after = <span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">private</span> <span class="directive">volatile</span> <span class="type">boolean</span> t;

    <span class="directive">private</span> <span class="type">boolean</span> set<span class="error">$</span>Precondition() { <span class="keyword">return</span> !t; } <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> set() {
        <span class="keyword">if</span> (t) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Already set</span><span class="delimiter">&quot;</span></span>);
        t = <span class="predefined-constant">true</span>;
    }

    <span class="annotation">@TestMark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="type">boolean</span> isSet() {
        <span class="keyword">return</span> t;
    }

    <span class="directive">private</span> <span class="type">boolean</span> copy<span class="error">$</span>Precondition() { <span class="keyword">return</span> !t; } <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> copy(FlipSwitch other) {
        <span class="keyword">if</span> (other.isSet()) set();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This companion method is present in the code to validate the computation of the precondition.
See <a href="#preconditions-and-instance-state">Preconditions and instance state</a> for more details.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The  <code>@Mark</code>  is present, even if it is executed conditionally.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The obvious use case for this helper class is to indicate whether a certain job has been done, or not.</p>
</div>
</div>
<div class="sect2">
<h3 id="support-setonce">13.2. SetOnce</h3>
<div class="paragraph">
<p>One step up from <code>FlipSwitch</code> is <code>SetOnce</code>: a place-holder for one object which can be filled exactly once:</p>
</div>
<div class="listingblock">
<div class="title">Example 79, parts of <code>org.e2immu.support.SetOnce</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>(after = <span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">SetOnce</span>&lt;T&gt; {

    <span class="annotation">@Final</span>(after = <span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">private</span> <span class="directive">volatile</span> T t;

    <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> set(<span class="annotation">@NotNull</span> T t) {
        <span class="keyword">if</span> (t == <span class="predefined-constant">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">NullPointerException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Null not allowed</span><span class="delimiter">&quot;</span></span>);
        <span class="keyword">if</span> (<span class="local-variable">this</span>.t != <span class="predefined-constant">null</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Already set: have </span><span class="delimiter">&quot;</span></span> + <span class="local-variable">this</span>.t + <span class="string"><span class="delimiter">&quot;</span><span class="content">, try to set </span><span class="delimiter">&quot;</span></span> + t);
        }
        <span class="local-variable">this</span>.t = t;
    }

    <span class="annotation">@Only</span>(after = <span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@NotNull</span>
    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> T get() {
        <span class="keyword">if</span> (t == <span class="predefined-constant">null</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Not yet set</span><span class="delimiter">&quot;</span></span>);
        }
        <span class="keyword">return</span> t;
    }

    <span class="annotation">@TestMark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="type">boolean</span> isSet() {
        <span class="keyword">return</span> t != <span class="predefined-constant">null</span>;
    }

    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> T getOrDefault(T defaultValue) {
        <span class="keyword">if</span> (isSet()) <span class="keyword">return</span> get();
        <span class="keyword">return</span> defaultValue;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The analyser relies heavily on this type, with additional support to allow setting multiple times, with exactly the same value.
This can be ascertained with a helper method, which, as noted in the previous section, also gets the  <code>@Mark</code>  annotation.</p>
</div>
</div>
<div class="sect2">
<h3 id="support-eventuallyfinal">13.3. EventuallyFinal</h3>
<div class="paragraph">
<p>Slightly more flexible than <code>SetOnce</code> is <code>EventuallyFinal</code>: the type allows you to keep writing objects using the <code>setVariable</code>
method, until you write using <code>setFinal</code>.
Then, the state changes and the type becomes level 2 immutable:</p>
</div>
<div class="listingblock">
<div class="title">Example 80, <code>org.e2immu.support.EventuallyFinal</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>(after = <span class="string"><span class="delimiter">&quot;</span><span class="content">isFinal</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">EventuallyFinal</span>&lt;T&gt; {
    <span class="directive">private</span> T value;
    <span class="directive">private</span> <span class="type">boolean</span> isFinal;

    <span class="directive">public</span> T get() {
        <span class="keyword">return</span> value;
    }

    <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">isFinal</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">void</span> setFinal(T value) {
        <span class="keyword">if</span> (<span class="local-variable">this</span>.isFinal) {
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Trying to overwrite a final value</span><span class="delimiter">&quot;</span></span>);
        }
        <span class="local-variable">this</span>.isFinal = <span class="predefined-constant">true</span>;
        <span class="local-variable">this</span>.value = value;
    }

    <span class="annotation">@Only</span>(before = <span class="string"><span class="delimiter">&quot;</span><span class="content">isFinal</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">void</span> setVariable(T value) {
        <span class="keyword">if</span> (<span class="local-variable">this</span>.isFinal) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Value is already final</span><span class="delimiter">&quot;</span></span>);
        <span class="local-variable">this</span>.value = value;
    }

    <span class="annotation">@TestMark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">isFinal</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">boolean</span> isFinal() {
        <span class="keyword">return</span> isFinal;
    }

    <span class="annotation">@TestMark</span>(value = <span class="string"><span class="delimiter">&quot;</span><span class="content">isFinal</span><span class="delimiter">&quot;</span></span>, before = <span class="predefined-constant">true</span>)
    <span class="directive">public</span> <span class="type">boolean</span> isVariable() {
        <span class="keyword">return</span> !isFinal;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note the occurrence of a negated  <code>@TestMark</code>  annotation: <code>isVariable</code> returns the negation of the normal <code>iFinal</code> mark test.</p>
</div>
</div>
<div class="sect2">
<h3 id="support-freezable">13.4. Freezable</h3>
<div class="paragraph">
<p>The previous support class, <code>EventuallyFinal</code>, forms the template for a more general approach to eventual immutability:
allow free modifications, until the type is <em>frozen</em> and no modifications can be allowed anymore.</p>
</div>
<div class="listingblock">
<div class="title">Example 81, <code>org.e2immu.support.Freezable</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>(after = <span class="string"><span class="delimiter">&quot;</span><span class="content">frozen</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">Freezable</span> {

    <span class="annotation">@Final</span>(after = <span class="string"><span class="delimiter">&quot;</span><span class="content">frozen</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">private</span> <span class="directive">volatile</span> <span class="type">boolean</span> frozen;

    <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">frozen</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">void</span> freeze() {
        ensureNotFrozen();
        frozen = <span class="predefined-constant">true</span>;
    }

    <span class="annotation">@TestMark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">frozen</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">boolean</span> isFrozen() {
        <span class="keyword">return</span> frozen;
    }

    <span class="directive">private</span> <span class="type">boolean</span> ensureNotFrozen<span class="error">$</span>Precondition() { <span class="keyword">return</span> !frozen; } <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="directive">public</span> <span class="type">void</span> ensureNotFrozen() {
        <span class="keyword">if</span> (frozen) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Already frozen!</span><span class="delimiter">&quot;</span></span>);
    }

    <span class="directive">private</span> <span class="type">boolean</span> ensureFrozen<span class="error">$</span>Precondition() { <span class="keyword">return</span> frozen; } <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="directive">public</span> <span class="type">void</span> ensureFrozen() {
        <span class="keyword">if</span> (!frozen) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Not yet frozen!</span><span class="delimiter">&quot;</span></span>);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This companion method is present in the code to validate the computation of the precondition.
See <a href="#preconditions-and-instance-state">Preconditions and instance state</a> for more details.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that as discussed in <a href="#inheritance">Inheritance</a>, it is important for <code>Freezable</code>, as an abstract class, to be level 2 immutable:
derived classes can only go <em>down</em> the immutability scale, not up!</p>
</div>
</div>
<div class="sect2">
<h3 id="support-setoncemap">13.5. SetOnceMap</h3>
<div class="paragraph">
<p>We discuss one example that makes use of (derives from) <code>Freezable</code>: a freezable map where no objects can be overwritten:</p>
</div>
<div class="listingblock">
<div class="title">Example 82, part of <code>org.e2immu.support.SetOnceMap</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>(after = <span class="string"><span class="delimiter">&quot;</span><span class="content">frozen</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">SetOnceMap</span>&lt;K, V&gt; <span class="directive">extends</span> Freezable {

    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Map</span>&lt;K, V&gt; map = <span class="keyword">new</span> <span class="predefined-type">HashMap</span>&lt;&gt;();

    <span class="annotation">@Only</span>(before = <span class="string"><span class="delimiter">&quot;</span><span class="content">frozen</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">void</span> put(<span class="annotation">@NotNull</span> K k, <span class="annotation">@NotNull</span> V v) {
        Objects.requireNonNull(k);
        Objects.requireNonNull(v);
        ensureNotFrozen();
        <span class="keyword">if</span> (isSet(k)) {
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Already decided on </span><span class="delimiter">&quot;</span></span> + k + <span class="string"><span class="delimiter">&quot;</span><span class="content">: have </span><span class="delimiter">&quot;</span></span> +
                get(k) + <span class="string"><span class="delimiter">&quot;</span><span class="content">, want to write </span><span class="delimiter">&quot;</span></span> + v);
        }
        map.put(k, v);
    }

    <span class="annotation">@NotNull</span>
    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> V get(K k) {
        <span class="keyword">if</span> (!isSet(k)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Not yet decided on </span><span class="delimiter">&quot;</span></span> + k);
        <span class="keyword">return</span> Objects.requireNonNull(map.get(k)); <i class="conum" data-value="1"></i><b>(1)</b>
    }

    <span class="directive">public</span> <span class="type">boolean</span> isSet(K k) {
        <span class="keyword">return</span> map.containsKey(k);
    }

    ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The analyser will warn for a potential null pointer exception here, not (yet) making the connection between
<code>isSet</code> and <code>containsKey</code>.
This connection can be implemented using the techniques described in <a href="#preconditions-and-instance-state">Preconditions and instance state</a>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The code analyser makes frequent use of this type, often with an additional guard that allows repeatedly putting the same value to a key.</p>
</div>
</div>
<div class="sect2">
<h3 id="support-lazy">13.6. Lazy</h3>
<div class="paragraph">
<p><code>Lazy</code> implements a lazily-initialized immutable field, of unbound generic type <code>T</code>.
Properly implemented, it is an eventually level 2 immutable type:</p>
</div>
<div class="listingblock">
<div class="title">Example 83, <code>org.e2immu.support.Lazy</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>(after = <span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">Lazy</span>&lt;T&gt; {

    <span class="annotation">@Dependent1</span>
    <span class="annotation">@NotNull1</span>
    <span class="directive">private</span> <span class="directive">final</span> Supplier&lt;T&gt; supplier;

    <span class="annotation">@Final</span>(after = <span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">private</span> <span class="directive">volatile</span> T t;

    <span class="directive">public</span> Lazy(<span class="annotation">@NotNull1</span> <span class="annotation">@Dependent1</span> Supplier&lt;T&gt; supplier) { <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="local-variable">this</span>.supplier = supplier;
    }

    <span class="annotation">@NotNull</span>
    <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="directive">public</span> T get() {
        <span class="keyword">if</span> (t != <span class="predefined-constant">null</span>) <span class="keyword">return</span> t;
        t = Objects.requireNonNull(supplier.get()); <i class="conum" data-value="3"></i><b>(3)</b>
        <span class="keyword">return</span> t;
    }

    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="type">boolean</span> hasBeenEvaluated() {
        <span class="keyword">return</span> t != <span class="predefined-constant">null</span>;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The annotation has travelled from the field to the parameter; so the parameter has {dependent1}.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The  <code>@Mark</code>  annotation is conditional; the transition is triggered by nullity of <code>t</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Here <code>t</code> content links to <code>supplier</code>, as explained in <a href="#immutable-content-linking">Immutable content linking</a>, which causes the field <code>supplier</code> to be marked {dependent1}.
The statement also causes the  <code>@NotNull1</code>  annotation, as defined in <a href="#nullable-section">Nullable, not null</a>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>After calling the marker method <code>get()</code>, <code>t</code> cannot be assigned anymore, and it becomes  <code>@Final</code> .</p>
</div>
</div>
<div class="sect2">
<h3 id="support-firstthen">13.7. FirstThen</h3>
<div class="paragraph">
<p>A variant on <code>SetOnce</code> is <code>FirstThen</code>, an eventually level 2 immutable container which starts off with one value, and transitions to another:</p>
</div>
<div class="listingblock">
<div class="title">Example 84, <code>org.e2immu.support.FirstThen</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>(after = <span class="string"><span class="delimiter">&quot;</span><span class="content">mark</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">FirstThen</span>&lt;S, T&gt; {
    <span class="directive">private</span> <span class="directive">volatile</span> S first;
    <span class="directive">private</span> <span class="directive">volatile</span> T then;

    <span class="directive">public</span> FirstThen(<span class="annotation">@NotNull</span> S first) {
        <span class="local-variable">this</span>.first = Objects.requireNonNull(first);
    }

    <span class="annotation">@TestMark</span>(value = <span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>, before = <span class="predefined-constant">true</span>)
    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="type">boolean</span> isFirst() {
        <span class="keyword">return</span> first != <span class="predefined-constant">null</span>;
    }

    <span class="annotation">@TestMark</span>(value = <span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="type">boolean</span> isSet() {
        <span class="keyword">return</span> first == <span class="predefined-constant">null</span>;
    }

    <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">mark</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">void</span> set(<span class="annotation">@NotNull</span> T then) {
        Objects.requireNonNull(then);
        <span class="directive">synchronized</span> (<span class="local-variable">this</span>) {
            <span class="keyword">if</span> (first == <span class="predefined-constant">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Already set</span><span class="delimiter">&quot;</span></span>);
            <span class="local-variable">this</span>.then = then;
            first = <span class="predefined-constant">null</span>;
        }
    }

    <span class="annotation">@Only</span>(before = <span class="string"><span class="delimiter">&quot;</span><span class="content">mark</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@NotModified</span>
    <span class="annotation">@NotNull</span>
    <span class="directive">public</span> S getFirst() {
        <span class="keyword">if</span> (first == <span class="predefined-constant">null</span>)
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Then has been set</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="1"></i><b>(1)</b>
        S s = first;
        <span class="keyword">if</span> (s == <span class="predefined-constant">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">NullPointerException</span>();
        <span class="keyword">return</span> s;
    }

    <span class="annotation">@Only</span>(after = <span class="string"><span class="delimiter">&quot;</span><span class="content">mark</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@NotModified</span>
    <span class="annotation">@NotNull</span>
    <span class="directive">public</span> T get() {
        <span class="keyword">if</span> (first != <span class="predefined-constant">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Not yet set</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="2"></i><b>(2)</b>
        T t = then;
        <span class="keyword">if</span> (t == <span class="predefined-constant">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">NullPointerException</span>();
        <span class="keyword">return</span> t;
    }

    <span class="annotation">@Override</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="directive">public</span> <span class="type">boolean</span> equals(<span class="annotation">@Nullable</span> <span class="predefined-type">Object</span> o) {
        <span class="keyword">if</span> (<span class="local-variable">this</span> == o) <span class="keyword">return</span> <span class="predefined-constant">true</span>;
        <span class="keyword">if</span> (o == <span class="predefined-constant">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="predefined-constant">false</span>;
        FirstThen&lt;?, ?&gt; firstThen = (FirstThen&lt;?, ?&gt;) o;
        <span class="keyword">return</span> Objects.equals(first, firstThen.first) &amp;&amp;
                Objects.equals(then, firstThen.then);
    }

    <span class="annotation">@Override</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="directive">public</span> <span class="type">int</span> hashCode() {
        <span class="keyword">return</span> Objects.hash(first, then);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is a bit convoluted.
The precondition is on the field <code>first</code>, and the current implementation of the precondition analyser requires an explicit check on the field.
Because this field is not final, we cannot assume that it is still null after the initial check; therefore, we assign it to a local variable, and do another null check to guarantee that the result that we return is <code>@NotNull</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Largely in line with the previous comment: we stick to the precondition on <code>first</code>, and have to check <code>then</code> to guarantee that the result is <code>@NotNull</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>equals</code> and <code>hashCode</code> methods inherit the  <code>@NotModified</code> annotation from <code>java.lang.Object</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that if we were to annotate the methods as contracts, rather than relying on the analyser to detect them, we could have a slightly more efficient implementation.</p>
</div>
</div>
<div class="sect2">
<h3 id="in-the-analyser">13.8. Support classes in the analyser</h3>
<div class="paragraph">
<p>Practice what you preach, and all that.
The  <em>e2immu</em>  analyser relies heavily on support classes such as <code>SetOnce</code>, and on the builder pattern described in the previous section.
Almost all public types are containers.
Because we intend to use the analyser&#8217;s code as a showcase for this project, one important class (<code>ExpressionContext</code>) was intentionally kept as a non-container.</p>
</div>
<div class="paragraph">
<p>A good example of our aim for eventual immutability is <code>TypeInfo</code>, the primary container holding a type.
Initially, a type is nothing but a reference, with a fully qualified name.
Source code or byte code inspection augments it with information about its methods and fields.
Whilst during inspection information is writable, after inspection this information becomes immutable.
We use the builder pattern for <code>TypeInspection</code>, using <code>TypeInspectionImpl.Builder</code> first and <code>TypeInspectionImpl</code> later.
The inspection information is stored using <code>SetOnce</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example 85, explaining <code>org.e2immu.analyser.model.TypeInfo</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">TypeInfo</span> {
    <span class="directive">public</span> <span class="directive">final</span> <span class="predefined-type">String</span> fullyQualifiedName;
    <span class="directive">public</span> <span class="directive">final</span> SetOnce&lt;TypeInspection&gt; typeInspection = <span class="keyword">new</span> SetOnce&lt;&gt;();
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once inspection is over, the code analyser takes over.
Results are temporarily stored in <code>TypeAnalysisImpl.Builder</code>, then copied into the immutable <code>TypeAnalysisImpl</code> class.
Both classes implement the <code>TypeAnalysis</code> interface to shield off the build phase.
Once the immutable type is ready, it is stored in <code>TypeInfo</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example 86, explaining <code>org.e2immu.analyser.model.TypeInfo</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">typeAnalysis,typeInspection</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">TypeInfo</span> {
    <span class="directive">public</span> <span class="directive">final</span> <span class="predefined-type">String</span> fullyQualifiedName;

    <span class="directive">public</span> <span class="directive">final</span> SetOnce&lt;TypeInspection&gt; typeInspection = <span class="keyword">new</span> SetOnce&lt;&gt;();
    <span class="directive">public</span> <span class="directive">final</span> SetOnce&lt;TypeAnalysis&gt; typeAnalysis = <span class="keyword">new</span> SetOnce&lt;&gt;();

    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this way, if we keep playing by the book recursively downward, <code>TypeInfo</code> will become an eventually level 2 immutable type.
Software engineers writing applications which use the  <em>e2immu</em>  analyser as a library, can feel secure that once the analysis phase is over, all the inspected and analysed information remains stable.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_other_annotations">14. Other annotations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The  <em>e2immu</em>  project defines a whole host of annotations complementary to the ones required for immutability.
We discuss them briefly, and refer to the user manual for an in-depth analysis.</p>
</div>
<div class="sect2">
<h3 id="nullable-section">14.1. Nullable, not null</h3>
<div class="paragraph">
<p>Nullability is a standard static code analyser topic, which we approach from a computational side: the analyser infers where possible, the user adds annotations to abstract methods.
The complement of not-null (marked  <code>@NotNull</code> ) is nullable (marked  <code>@Nullable</code> ).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A method marked  <code>@NotNull</code>  will never return a null result.
This is very standard.</p>
</li>
<li>
<p>Calling a parameter marked  <code>@NotNull</code>  will result in a null pointer exception at some point during the object life-cycle.</p>
</li>
<li>
<p>A  <code>@NotNull</code>  or  <code>@Nullable</code>  annotation on a field is a consequence of not-null computations on the assignments to the field.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To be able to compute the not-null of parameters, we must specify some sort of flow or direction to break chicken-and-egg situations.
We compute in the following order:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>context not-null of parameters.</p>
</li>
<li>
<p>field not-null</p>
</li>
<li>
<p>external not-null of parameters linked to fields</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>First, we examine the parameter&#8217;s usage in the method.
Its occurrence in a not-null context directly influences the not-null of the parameter.</p>
</div>
<div class="sect3">
<h4 id="_higher_order_not_null">14.1.1. Higher order not-null</h4>
<div class="paragraph">
<p>We use the annotation  <code>@NotNull1</code>  to indicate that none of the object&#8217;s fields can be null.
This concept is useful when working with collections.</p>
</div>
<div class="paragraph">
<p>Consider the following  <code>@NotNull</code>  variants on the <code>List</code> API:</p>
</div>
<div class="listingblock">
<div class="title">Example 87,  <code>@NotNull</code>  annotations on <code>Collection</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">boolean</span> add(<span class="annotation">@NotNull</span> E e);
<span class="type">boolean</span> addAll(<span class="annotation">@NotNull1</span> <span class="predefined-type">Collection</span>&lt;? <span class="directive">extends</span> E&gt; collection);
<span class="annotation">@NotNull1</span> <span class="directive">static</span> &lt;E&gt; <span class="predefined-type">List</span>&lt;E&gt; copyOf(<span class="annotation">@NotNull1</span> <span class="predefined-type">Collection</span>&lt;? <span class="directive">extends</span> E&gt; collection);
<span class="annotation">@NotNull1</span> <span class="predefined-type">Iterator</span>&lt;E&gt; iterator();</code></pre>
</div>
</div>
<div class="paragraph">
<p>They effectively block the use of null elements in the collection.
As a consequence, looping over the elements will not give potential null pointer warnings.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is purely an opinion: we&#8217;d rather not use null as elements of a collection.
You are free to annotate differently!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Higher orders are possible as well.
A second level would be useful when working with entry sets:</p>
</div>
<div class="listingblock">
<div class="title">Example 88,  <code>@NotNull</code>  annotations on <code>Map</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">V put(<span class="annotation">@NotNull</span> K key, <span class="annotation">@NotNull</span> V value);
<span class="annotation">@NotNull</span> <span class="directive">static</span> &lt;K, V&gt; <span class="predefined-type">Map</span>&lt;K, V&gt; copyOf(<span class="annotation">@NotNull</span> <span class="predefined-type">Map</span>&lt;? <span class="directive">extends</span> K, ? <span class="directive">extends</span> V&gt; map);
<span class="annotation">@NotNull2</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Map</span>.Entry&lt;K, V&gt;&gt; entrySet();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how the map copy is only  <code>@NotNull</code> , while the entry set is not null, the entries in this set are not null, and the keys and values are neither.
There is currently no plan to implement beyond  <code>@NotNull1</code> , however.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="identity-and-fluent">14.2. Identity and fluent methods</h3>
<div class="paragraph">
<p>The analyser marks methods which returns their first parameter with <code>@Identity</code>, and methods which return <code>this</code> with <code>@Fluent</code>.
The former are convenient to introduce preconditions, the latter occur frequently when chaining methods in builders.
Here is an integrated example:</p>
</div>
<div class="listingblock">
<div class="title">Example 89, methods marked  <code>@Identity</code>  and  <code>@Fluent</code> </div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E1Container</span>(builds=<span class="predefined-type">List</span>.class)
<span class="type">class</span> <span class="class">Builder</span> {

    <span class="annotation">@NotNull</span>
    <span class="annotation">@NotModified</span>
    <span class="annotation">@Identity</span>
    <span class="directive">private</span> <span class="directive">static</span> &lt;T&gt; T requireNonNull(<span class="annotation">@NotNull</span> T t) {
        <span class="keyword">if</span>(t == <span class="predefined-constant">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>();
        <span class="keyword">return</span> t;
    }

    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; list = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;();

    <span class="annotation">@Fluent</span>
    <span class="directive">public</span> Builder add(<span class="annotation">@NotNull</span> <span class="predefined-type">String</span> s) {
        list.add(requireNonNull(s));
        <span class="keyword">return</span> <span class="local-variable">this</span>;
    }

    <span class="annotation">@Fluent</span>
    <span class="directive">public</span> Builder add(<span class="type">int</span> i) {
        list.add(<span class="predefined-type">Integer</span>.toString(i));
        <span class="keyword">return</span> <span class="local-variable">this</span>;
    }

    <span class="annotation">@E2Container</span>
    <span class="directive">public</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; build() {
        <span class="keyword">return</span> <span class="predefined-type">List</span>.copyOf(list);
    }

    <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt; one23 = <span class="keyword">new</span> Builder().add(<span class="integer">1</span>).add(<span class="integer">2</span>).add(<span class="integer">3</span>).add(<span class="string"><span class="delimiter">&quot;</span><span class="content">go</span><span class="delimiter">&quot;</span></span>).build();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="finalizers">14.3. Finalizers</h3>
<div class="paragraph">
<p>Up to now, we have focused on the distinction between the building phase of an object&#8217;s life-cycle, and its subsequent immutable phase.
We have ignored the destruction of objects: critically important for some applications, but often completely ignored by Java programmers because of the silent background presence of the garbage collector.
In this section we introduce an annotation,  <code>@Finalizer</code> , with the goal of being able to mark that calling a certain method means that the object has reached the end of its life-cycle:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Once a method marked  <code>@Finalizer</code>  has been called, no other methods may be subsequently applied.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Why is this useful?
The most obvious use-case for immutability is the meaning of the <code>build()</code> method in a builder: can you call it once, or is the builder somehow incremental?</p>
</div>
<div class="paragraph">
<p>How can the analyser enforce the sequence of method calling on an object?
The simplest way is by some severe restrictions:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>The following need to be true at all times when using types with finalizer methods:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Any field of a type with finalizers must be effectively final (marked with  <code>@Final</code> ).</p>
</li>
<li>
<p>A finalizer method can only be called on a field inside a method which is marked as a finalizer as well.</p>
</li>
<li>
<p>A finalizer method can never be called on a parameter or any variable linked to it, with linking as defined throughout this document (see <a href="#linking-and-independence">Linking, independence</a>).</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>Interestingly, these restrictions are such that they help you control the life-cycle of objects with a  <code>@Finalizer</code> , by not letting them out of sight.</p>
</div>
<div class="paragraph">
<p>Note that the  <code>@Finalizer</code>  annotation is always contracted; it cannot be computed.</p>
</div>
<div class="paragraph">
<p>Let us start from the following example, using <a href="#support-eventuallyfinal">EventuallyFinal</a>:</p>
</div>
<div class="listingblock">
<div class="title">Example 90, a type with a  <code>@Finalizer</code>  method</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">ExampleWithFinalizer</span> {
    <span class="annotation">@BeforeMark</span>
    <span class="directive">private</span> <span class="directive">final</span> EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; data = <span class="keyword">new</span> EventuallyFinal&lt;&gt;();

    <span class="annotation">@Fluent</span>
    <span class="directive">public</span> ExampleWithFinalizer set(<span class="predefined-type">String</span> string) {
        data.setVariable(string);
        <span class="keyword">return</span> <span class="local-variable">this</span>;
    }

    <span class="annotation">@Fluent</span>
    <span class="directive">public</span> ExampleWithFinalizer doSomething() {
        <span class="predefined-type">System</span>.out.println(data.toString());
        <span class="keyword">return</span> <span class="local-variable">this</span>;
    }

    <span class="annotation">@Finalizer</span>
    <span class="annotation">@BeforeMark</span>
    <span class="directive">public</span> EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; getData() {
        <span class="keyword">return</span> data;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using  <code>@Fluent</code>  methods to go from construction to finalizer is definitely allowed according to the rules:</p>
</div>
<div class="listingblock">
<div class="title">Example 91, calling the finalizer method</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>
<span class="directive">public</span> <span class="directive">static</span> EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; fluent() {
    EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; d = <span class="keyword">new</span> ExampleWithFinalizer()
        .set(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).doSomething().set(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).doSomething().getData();
    d.setFinal(<span class="string"><span class="delimiter">&quot;</span><span class="content">x</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">return</span> d;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Passing on these objects as arguments is permitted, but the recipient should not call the finalizer.
Actually, given our strong preference for containers, the recipient should not even modify the object!
Consider:</p>
</div>
<div class="listingblock">
<div class="title">Example 92, illegal call</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@E2Container</span>
<span class="directive">public</span> <span class="directive">static</span> EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; stepWise() {
    ExampleWithFinalizer ex = <span class="keyword">new</span> ExampleWithFinalizer();
    ex.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>);
    ex.doSomething();
    ex.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>);
    doSthElse(ex); <i class="conum" data-value="1"></i><b>(1)</b>
    EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; d = ex.getData();
    d.setFinal(<span class="string"><span class="delimiter">&quot;</span><span class="content">x</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">return</span> d;
}

<span class="directive">private</span> <span class="directive">static</span> <span class="type">void</span> doSthElse(<span class="annotation">@NotModified</span> ExampleWithFinalizer ex) {
    ex.doSomething(); <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>here we pass on the object</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>forbidden to call the finalizer; other methods allowed.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Rules 1 and 2 allow you to store a finalizer type inside a field, but only when finalization is attached to the destruction of the holding type.
Examples follow immediately, in the context of the  <code>@BeforeMark</code>  annotation.</p>
</div>
<div class="sect3">
<h4 id="_processors_and_finishers">14.3.1. Processors and finishers</h4>
<div class="paragraph">
<p>It is worth observing that finalizers play well with the  <code>@BeforeMark</code>  annotation.
They allow us to introduce the concepts of <em>processors</em> and <em>finishers</em> for eventually immutable types in their <em>before</em> state.</p>
</div>
<div class="paragraph">
<p>The purpose of a <em>processor</em> is to receive an object in the  <code>@BeforeMark</code>  state, hold it, use a lot of temporary data in the meantime, and then release it again, modified but still in the  <code>@BeforeMark</code>  state.</p>
</div>
<div class="listingblock">
<div class="title">Example 93, conceptual example of a processor</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Processor</span> {
    <span class="directive">private</span> <span class="type">int</span> count; <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="annotation">@BeforeMark</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="directive">private</span> <span class="directive">final</span> EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; eventuallyFinal;

    <span class="directive">public</span> Processor(<span class="annotation">@BeforeMark</span> EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; eventuallyFinal) {
        <span class="local-variable">this</span>.eventuallyFinal = eventuallyFinal;
    }

    <span class="directive">public</span> <span class="type">void</span> set(<span class="predefined-type">String</span> s) { <i class="conum" data-value="3"></i><b>(3)</b>
        eventuallyFinal.setVariable(s);
        count++;
    }

    <span class="annotation">@Finalizer</span>
    <span class="annotation">@BeforeMark</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="directive">public</span> EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; done(<span class="predefined-type">String</span> last) {
        eventuallyFinal.setVariable(last + <span class="string"><span class="delimiter">&quot;</span><span class="content">; tried </span><span class="delimiter">&quot;</span></span> + count);
        <span class="keyword">return</span> eventuallyFinal;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>symbolises the temporary data to be destroyed after processing</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>the field is private, not passed on, no  <code>@Mark</code>  method is called on it, and it is exposed only in a  <code>@Finalizer</code> </td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>symbolises the modifications that act as processing</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>the result of processing: an eventually immutable object in the same initial state.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The purpose of a <em>finisher</em> is to receive an object in the  <code>@BeforeMark</code>  state, and return it in the final state.
In the meantime, it gets modified (finished), while there is other temporary data around.
Once the final state is reached, the analyser guarantees that the temporary data is destroyed by severely limiting the scope of the finisher object.</p>
</div>
<div class="listingblock">
<div class="title">Example 94, conceptual example of finisher</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Finisher</span> {
    <span class="directive">private</span> <span class="type">int</span> count; <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="annotation">@BeforeMark</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="directive">private</span> <span class="directive">final</span> EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; eventuallyFinal;

    <span class="directive">public</span> Finisher(<span class="annotation">@BeforeMark</span> EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; eventuallyFinal) {
        <span class="local-variable">this</span>.eventuallyFinal = eventuallyFinal;
    }

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> set(<span class="predefined-type">String</span> s) { <i class="conum" data-value="3"></i><b>(3)</b>
        eventuallyFinal.setVariable(s);
        count++;
    }

    <span class="annotation">@Finalizer</span>
    <span class="annotation">@E2Container</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="directive">public</span> EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; done(<span class="predefined-type">String</span> last) {
        eventuallyFinal.setFinal(last + <span class="string"><span class="delimiter">&quot;</span><span class="content">; tried </span><span class="delimiter">&quot;</span></span> + count);
        <span class="keyword">return</span> eventuallyFinal;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>symbolises the temporary data to be destroyed.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>only possible because the transition occurs in a  <code>@Finalizer</code>  method</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>symbolises the modifications that act as finishing</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>the result of finishing: an eventually immutable object in its end-state.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_utility_classes">14.4. Utility classes</h3>
<div class="paragraph">
<p>We use the simple and common definition:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition</strong>: a <strong>utility class</strong> is a level 2 immutable class which cannot be instantiated.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>These definitions imply</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>a utility class has no non-static fields,</p>
</li>
<li>
<p>it has a single, private, unused constructor,</p>
</li>
<li>
<p>and its static fields (if it has any) are sufficiently immutable.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_extension_classes">14.5. Extension classes</h3>
<div class="paragraph">
<p>In Java, many classes cannot easily be extended.
Implementations of extensions typically use a utility class with the convention that the first parameter of the static method is the object of the extended method call:</p>
</div>
<div class="listingblock">
<div class="title">Example 95, an extension class</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ExtensionClass</span>(of=<span class="predefined-type">String</span><span class="type">[]</span>.class)
<span class="type">class</span> <span class="class">ExtendStringArray</span> {
    <span class="directive">private</span> ExtendStringArray() { <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">UnsupportedOperationException</span>(); }

    <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">String</span> weave(<span class="annotation">@NotModified</span> <span class="predefined-type">String</span><span class="type">[]</span> strings) {
        <span class="comment">// generate a new string by weaving the given strings (concat 1st chars, etc.)</span>
    }

    <span class="directive">public</span> <span class="directive">static</span> <span class="type">int</span> appendEach(<span class="annotation">@Modified</span> <span class="predefined-type">String</span><span class="type">[]</span> strings, <span class="predefined-type">String</span> append) {
        <span class="comment">// append the parameter 'append' to each of the strings in the array</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We use the following criteria to designate a class as an extension:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>A class is an extension class of a type <code>E</code> when</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the class is level 2 immutable;</p>
</li>
<li>
<p>all non-private static methods with parameters must have a  <code>@NotNull</code>  1st parameter of type <code>E</code>, the type being extended.
There must be at least one such method;</p>
</li>
<li>
<p>non-private static methods without parameters must return a value of type <code>E</code>, and must also be  <code>@NotNull</code> .</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Static classes can be used to 'extend' closed types, as promoted by the <a href="https://www.eclipse.org/xtend/" target="_blank" rel="noopener">Xtend</a> project.
Level 2 immutable classes can also play the role of extension facilitators, with the additional benefit of having some immutable data to be used as a context.</p>
</div>
<div class="paragraph">
<p>Note that extension classes will often not be  <code>@Container</code> , since the first parameter will be  <code>@Modified</code>  in many cases.</p>
</div>
</div>
<div class="sect2">
<h3 id="singleton-classes">14.6. Singleton classes</h3>
<div class="paragraph">
<p>A singleton class is a class which has a mechanism to limit the creation of instances to a maximum of one.
The term 'singleton' then refers to this unique instance.</p>
</div>
<div class="paragraph">
<p>The  <em>e2immu</em>  analyser currently recognizes two systems for limiting the number of instances:
the creation of an instance in a single static field with a static constructor, and a precondition on a constructor using a private static boolean field.</p>
</div>
<div class="paragraph">
<p>An example of the first strategy is:</p>
</div>
<div class="listingblock">
<div class="title">Example 96, first mechanism recognized to enforce a singleton</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Singleton</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SingletonExample</span> {

    <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> SingletonExample SINGLETON = <span class="keyword">new</span> SingletonExample(<span class="integer">123</span>);

    <span class="directive">private</span> <span class="directive">final</span> <span class="type">int</span> k;

    <span class="directive">private</span> SingletonExample(<span class="type">int</span> k) {
        <span class="local-variable">this</span>.k = k;
    }

    <span class="directive">public</span> <span class="type">int</span> multiply(<span class="type">int</span> i) {
        <span class="keyword">return</span> k * i;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An example of the second strategy is:</p>
</div>
<div class="listingblock">
<div class="title">Example 97, second mechanism recognized to enforce a singleton</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Singleton</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SingletonWithPrecondition</span> {

    <span class="directive">private</span> <span class="directive">final</span> <span class="type">int</span> k;
    <span class="directive">private</span> <span class="directive">static</span> <span class="type">boolean</span> created;

    <span class="directive">public</span> SingletonWithPrecondition(<span class="type">int</span> k) {
        <span class="keyword">if</span> (created) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>();
        created = <span class="predefined-constant">true</span>;
        <span class="local-variable">this</span>.k = k;
    }

    <span class="directive">public</span> <span class="type">int</span> multiply(<span class="type">int</span> i) {
        <span class="keyword">return</span> k * i;
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="preconditions-and-instance-state">15. Preconditions and instance state</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The  <em>e2immu</em>  analyser needs pretty strong support for determining preconditions on methods to be able to compute eventual immutability.
A lot of the mechanics involved can be harnessed in other ways as well, for example, to detect common mistakes in the use of collection classes.</p>
</div>
<div class="paragraph">
<p>We have implemented a system where the value of a variable can be augmented with <em>instance state</em> each time a method operates on the variable.
In the case of Java collections and <code>StringBuilder</code>, size-based instance state is low-hanging fruit.
Let&#8217;s start with an example:</p>
</div>
<div class="listingblock">
<div class="title">Example 98, creating an empty list</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; list = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;();
<span class="keyword">if</span> (list.size() &gt; <span class="integer">0</span>) { <span class="comment">// WARNING: evaluates to constant</span>
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When creating a new <code>ArrayList</code> using the empty constructor, we can store in the variable&#8217;s value that its size is 0.
First, let us look at the annotations for the <code>size</code> method:</p>
</div>
<div class="listingblock">
<div class="title">Example 99, annotations of <code>List.size</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> size<span class="error">$</span>Aspect<span class="error">$</span>Size() {}
<span class="type">boolean</span> size<span class="error">$</span>Invariant<span class="error">$</span>Size(<span class="type">int</span> i) { <span class="keyword">return</span> i &gt;= <span class="integer">0</span>; }
<span class="annotation">@NotModified</span>
<span class="type">int</span> size() { <span class="keyword">return</span> <span class="integer">0</span>; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The method has two <em>companion methods</em>.
The first registers <code>Size</code> as a numeric <em>aspect</em> linked to the <code>size</code> method.
The second adds an invariant (an assertion that is always true) in relation to the aspect: the size is never negative.</p>
</div>
<div class="paragraph">
<p>Looking at the annotations for the empty constructor,</p>
</div>
<div class="listingblock">
<div class="title">Example 100, annotations of empty <code>ArrayList</code> constructor</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">boolean</span> <span class="predefined-type">ArrayList</span><span class="error">$</span>Modification<span class="error">$</span>Size(<span class="type">int</span> post) { <span class="keyword">return</span> post == <span class="integer">0</span>; }
<span class="directive">public</span> <span class="predefined-type">ArrayList</span><span class="error">$</span>() { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>we see another companion method, that expresses the effect of the construction in terms of the <code>Size</code> aspect.
(The dollar sign at the end of the constructor is an artifact of the annotated API system; please refer to the  <em>e2immu</em>  manual.) Internally, we represent the value of <code>list</code> after the assignment as</p>
</div>
<div class="listingblock">
<div class="title">Example 101, internal representation of an empty list</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;()<span class="comment">/*0==this.size()*/</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression in the companion results in the fact that the <code>Size</code> aspect post-modification is 0.
This then gets added to the evaluation state, which allows the analyser to conclude that the expression in the if-statement is a constant true.</p>
</div>
<div class="paragraph">
<p>This approach is sufficiently strong to catch a number of common problems when working with collections.
After adding one element to the empty list, as in:</p>
</div>
<div class="listingblock">
<div class="title">Example 102, adding an element to an empty list</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; list = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;();
list.add(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>the value of <code>list</code> becomes</p>
</div>
<div class="listingblock">
<div class="title">Example 103, internal representation after adding an element</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">instance type <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">String</span>&gt;<span class="comment">/*this.contains(&quot;a&quot;)&amp;&amp;1==this.size()*/</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The boolean expression in the comments is added to the evaluation state, so that expressions such as <code>list.isEmpty()</code>, defined as:</p>
</div>
<div class="listingblock">
<div class="title">Example 104, <code>List.isEmpty</code> and its companion method</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">boolean</span> isEmpty<span class="error">$</span>Value<span class="error">$</span>Size(<span class="type">int</span> i, <span class="type">boolean</span> retVal) { <span class="keyword">return</span> i == <span class="integer">0</span>; }
<span class="annotation">@NotModified</span>
<span class="type">boolean</span> isEmpty() { <span class="keyword">return</span> <span class="predefined-constant">true</span>; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>can be evaluated by the analyser.
We refer to the manual for a more in-depth treatment of companion methods and instance state.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_copyright_and_license">16. Copyright and License</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Copyright &#169; 2020, 2021, Bart Naudts, <a href="https://www.e2immu.org" class="bare">https://www.e2immu.org</a></p>
</div>
<div class="paragraph">
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
You should have received a copy of the GNU Lesser General Public License along with this program.  If not, see <a href="http://www.gnu.org/licenses/" class="bare">http://www.gnu.org/licenses/</a>.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2021-10-09 10:44:27 UTC
</div>
</div>
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
pre.CodeRay{background:#f7f7f8}
.CodeRay .line-numbers{border-right:1px solid currentColor;opacity:.35;padding:0 .5em 0 0}
.CodeRay span.line-numbers{display:inline-block;margin-right:.75em}
.CodeRay .line-numbers strong{color:#000}
table.CodeRay{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.CodeRay td{vertical-align:top;line-height:inherit}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.code{padding:0 0 0 .75em}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</body>
</html>