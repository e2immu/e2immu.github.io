<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="description" content="A walk-through of the concepts and definitions of _e2immu_">
<meta name="author" content="Bart Naudts &lt;bart.naudts@e2immu.org&gt;">
<title>The Road to Immutability</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>The Road to Immutability</h1>
<div class="details">
<span id="author" class="author">Bart Naudts &lt;bart.naudts@e2immu.org&gt;</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_dedication">Dedication</a></li>
<li><a href="#_introduction">1. Introduction</a></li>
<li><a href="#assumptions">2. Assumptions</a></li>
<li><a href="#_the_purpose_of_annotations">3. The purpose of annotations</a></li>
<li><a href="#_final_fields">4. Final fields</a></li>
<li><a href="#modification">5. Modification</a></li>
<li><a href="#containers">6. Containers</a></li>
<li><a href="#linking-and-independence">7. Linking, dependence</a></li>
<li><a href="#accessible-hidden-content">8. Accessible and hidden content</a></li>
<li><a href="#_immutability">9. Immutability</a>
<ul class="sectlevel2">
<li><a href="#_definition_and_examples">9.1. Definition and examples</a></li>
<li><a href="#inheritance">9.2. Inheritance</a></li>
<li><a href="#generics">9.3. Generics</a></li>
<li><a href="#abstract-methods">9.4. Abstract methods</a></li>
<li><a href="#static-side-effects">9.5. Static side effects</a></li>
<li><a href="#value-based-classes">9.6. Value-based classes</a></li>
<li><a href="#dynamic-type-annotations">9.7. Dynamic type annotations</a></li>
</ul>
</li>
<li><a href="#eventual-immutability">10. Eventual immutability</a>
<ul class="sectlevel2">
<li><a href="#_builders">10.1. Builders</a></li>
<li><a href="#_definition">10.2. Definition</a></li>
<li><a href="#_propagation">10.3. Propagation</a></li>
<li><a href="#_before_the_mark">10.4. Before the mark</a></li>
<li><a href="#_extensions_of_annotations">10.5. Extensions of annotations</a></li>
<li><a href="#_frameworks_and_contracts">10.6. Frameworks and contracts</a></li>
</ul>
</li>
<li><a href="#modification-part2">11. Modification, part 2</a>
<ul class="sectlevel2">
<li><a href="#_cyclic_references">11.1. Cyclic references</a></li>
<li><a href="#computing-dependence">11.2. How to compute linking</a></li>
<li><a href="#_locally_implemented_abstract_methods">11.3. Locally implemented abstract methods</a></li>
</ul>
</li>
<li><a href="#hidden-content">12. More on hidden content</a>
<ul class="sectlevel2">
<li><a href="#_visitors">12.1. Visitors</a></li>
<li><a href="#_propagating_modifications">12.2. Propagating modifications</a></li>
<li><a href="#content-linking">12.3. Content linking</a></li>
<li><a href="#_iterator_iterable_loops">12.4. Iterator, Iterable, loops</a></li>
<li><a href="#independent-type">12.5. Independence of types</a></li>
</ul>
</li>
<li><a href="#_further_notes_on_immutability">13. Further notes on immutability</a>
<ul class="sectlevel2">
<li><a href="#extendability">13.1. Extendability of types</a></li>
<li><a href="#_eventual_immutability">13.2. Eventual immutability</a></li>
<li><a href="#_constant_types">13.3. Constant types</a></li>
<li><a href="#_field_access_restrictions">13.4. Field access restrictions</a></li>
</ul>
</li>
<li><a href="#support-classes">14. Support classes</a>
<ul class="sectlevel2">
<li><a href="#support-flipswitch">14.1. FlipSwitch</a></li>
<li><a href="#support-setonce">14.2. SetOnce</a></li>
<li><a href="#support-eventuallyfinal">14.3. EventuallyFinal</a></li>
<li><a href="#support-freezable">14.4. Freezable</a></li>
<li><a href="#support-setoncemap">14.5. SetOnceMap</a></li>
<li><a href="#support-lazy">14.6. Lazy</a></li>
<li><a href="#support-firstthen">14.7. FirstThen</a></li>
<li><a href="#in-the-analyser">14.8. Support classes in the analyser</a></li>
</ul>
</li>
<li><a href="#_other_annotations">15. Other annotations</a>
<ul class="sectlevel2">
<li><a href="#nullable-section">15.1. Nullable, not null</a></li>
<li><a href="#identity-and-fluent">15.2. Identity and fluent methods</a></li>
<li><a href="#finalizers">15.3. Finalizers</a></li>
<li><a href="#_utility_classes">15.4. Utility classes</a></li>
<li><a href="#_extension_classes">15.5. Extension classes</a></li>
<li><a href="#singleton-classes">15.6. Singleton classes</a></li>
</ul>
</li>
<li><a href="#preconditions-and-instance-state">16. Preconditions and instance state</a></li>
<li><a href="#_appendix">17. Appendix</a>
<ul class="sectlevel2">
<li><a href="#_default_annotations">17.1. Default annotations</a></li>
</ul>
</li>
<li><a href="#_copyright_and_license">18. Copyright and License</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Effective and eventual immutability with <em>e2immu</em>, a static code analyser for Java.</p>
</div>
<div class="paragraph">
<p>Main website: <a href="https://www.e2immu.org" class="bare">https://www.e2immu.org</a>.
Fifth iteration, October 2023.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_dedication">Dedication</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This work is dedicated to those who have had, or are still having, a difficult pandemic.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction">1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This document aims to be a logical walk through of the concepts of the  <em>e2immu</em>  project.
It does not intend to be complete, and is not structured for reference.</p>
</div>
<div class="paragraph">
<p>The overarching aim of the  <em>e2immu</em>  project is to improve every day programming by making code more readable, more
robust, and more future-proof.
More concretely, the project focuses on adding various forms of immutability protections to your Java code base, by
making the immutable nature of the types more visible.</p>
</div>
<div class="paragraph">
<p><em>Why Java?</em> As a widely used object-oriented programming language, it has evolved over the years, and it has been
increasingly equipped with functional programming machinery.
It is therefore possible to write Java code in different styles, from overly object-oriented to almost fully functional.
Combine this with lots of legacy code, both in house and in libraries, and many large software projects will end up
mixing styles a lot.
This adds to the complexity of understanding and maintaining the code base.</p>
</div>
<div class="paragraph">
<p><em>Why immutability?</em> An important aspect of understanding the code of large software projects is to try to assess the
<em>object lifecycle</em> of the data it manages: when and how are these objects modified?
In object-oriented programming, full of public getters and setters, objects can be modified all the time.
In many a functional set-up, objects are immutable but new immutable versions pop up all the time.
Java allows for the whole scala from object-oriented to functional, and the whole ecosystem reflects this choice.</p>
</div>
<div class="paragraph">
<p>An easy way to envisage the life cycle of an object is to assume that it consists of a building phase, followed by an
immutable phase.
We set out to show that there are different forms of immutability, from very strict deep immutability to weak guarantees
of non-modification, that can be made visible in the code.
We believe that code complexity can be greatly reduced when the software engineer is permanently aware of the
modification state of objects.</p>
</div>
<div class="paragraph">
<p>The  <em>e2immu</em>  project consists of a set of definitions, a static code analyser to compute and enforce rules and
definitions, and IDE support to visualize the results without cluttering.
Using  <em>e2immu</em>  in your project will help to maintain higher coding standards, the ultimate beneficiary being code
that will survive longer.</p>
</div>
<div class="paragraph">
<p>A <em>lack of references to academic literature</em> in this version of the document is explained by the fact that this is
my first foray into the world of static code analysers, and theory of software engineering and programming languages.
Academically coming from the theory of machine learning, I spent a decade and a half writing software and managing
teams of software engineers.
This work builds on that practical experience alone.
I did not consult or research the literature, and I realise I may be duplicating quite a lot here.
I only want to mention JetBrain&#8217;s brilliant <a href="https://www.jetbrains.com/idea/" target="_blank" rel="noopener">IntelliJ IDEA</a>, which acts as my g
old standard.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="assumptions">2. Assumptions</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We discuss the Java language, version 8 and higher.
We have already indicated that we believe that Java offers too much freedom to programmers.
In this section, we impose some limits that are not critical to the substance of the discussion, but facilitate
reasoning.
Think of them as low-hanging fruit programming guidelines:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Exceptions do not belong to the normal programming flow; they are meant to raise situations that the program does
not want to deal with.</p>
</li>
<li>
<p>Parameters of a method cannot be assigned to; we act as if they always have the <code>final</code> modifier.
The simple way around is to create a new local variable, and assign the parameter to it.</p>
</li>
<li>
<p>We make no distinction between the various non-private access modifiers (package-private, protected, public).
Either a field, method or type is private, or it is not.</p>
</li>
<li>
<p>Synchronization is orthogonal to the data flow of the program; whilst it may have an influence on <em>when</em> certain
code runs, it should not be used to influence the semantics of the code.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The  <em>e2immu</em>  code analyser warns for many other doubtful practices, as detailed in the user manual.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_the_purpose_of_annotations">3. The purpose of annotations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this document we will add many annotations to the code fragments shown.
We are acutely aware annotations may clutter the code and can make it less readable.
Some IDEs, however, like JetBrains' IntelliJ IDEA, have extensive support to make working with annotations visually
pleasing.</p>
</div>
<div class="paragraph">
<p>The  <em>e2immu</em>  code analyser computes almost all the annotations that we add to the code fragments in this document.
The complementary IDE plugin uses them to color code types, methods and fields.
Except when the annotations act as a contract, in interfaces, they do not have to be present in your code.</p>
</div>
<div class="paragraph">
<p>Explicitly adding the annotations to classes can be helpful during software development, however.
Say you intend for a class to be immutable, then you can add the corresponding annotation to the type.
Each time the code analyser runs, and the computation finds the type is not immutable, it will raise an error.</p>
</div>
<div class="paragraph">
<p>Explicit annotations also act as a safe-guard against the changing of semantics by overriding methods.
Making the method <code>final</code>, or the type <code>final</code>, merely <em>prohibits</em> overriding, which is typically too strong a mechanism.</p>
</div>
<div class="paragraph">
<p>The final situation where explicit annotations in the code are important, is for the development of the analyser.
We add them to the code as a means of verification: the analyser will check if it generates the same annotation at
that location.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_final_fields">4. Final fields</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let us start with a definition:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition</strong>: We say a field is <strong>effectively final</strong> when it either has the modifier <code>final</code>, or it is not assigned to
in methods that can be transitively called from non-private (non-constructor) methods.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The analyser annotates with  <code>@Final</code>  in the latter case; there is no point in cluttering with an annotation when the
modifier is already there.
Fields that are not effectively final are called <em>variable</em>, they can optionally be annotated with  <code>@Final(absent=true)</code> .</p>
</div>
<div class="paragraph">
<p>This definition allows effectively final fields to be assigned in methods accessible only from the constructor:</p>
</div>
<div class="listingblock">
<div class="title">Example 1, effectively final, but not with the <code>final</code> modifier</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">EffectivelyFinal1</span> {
    <span class="annotation">@Final</span>
    <span class="directive">private</span> <span class="predefined-type">Random</span> random;

    <span class="directive">public</span> EffectivelyFinal1() {
        initialize(<span class="integer">3L</span>);
    }

    <span class="directive">private</span> <span class="type">void</span> initialize(<span class="type">long</span> seed) {
        random = <span class="keyword">new</span> <span class="predefined-type">Random</span>(seed);
    }

    <span class="comment">// no methods in the class call initialize()</span>

    <span class="directive">public</span> <span class="type">int</span> nextInt() {
        <span class="keyword">return</span> random.nextInt();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Obviously, if the same method can be called after construction, the field becomes variable:</p>
</div>
<div class="listingblock">
<div class="title">Example 2, the method setting the field is accessible after construction</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">EffectivelyFinal2</span> {
    <span class="annotation">@Final</span>(absent = <span class="predefined-constant">true</span>)
    <span class="directive">private</span> <span class="predefined-type">Random</span> random;

    <span class="directive">public</span> EffectivelyFinal2() {
        reset();
    }

    <span class="directive">public</span> <span class="type">void</span> reset() {
        initialize(<span class="integer">3L</span>);
    }

    <span class="directive">private</span> <span class="type">void</span> initialize(<span class="type">long</span> seed) {
        random = <span class="keyword">new</span> <span class="predefined-type">Random</span>(seed);
    }

    <span class="directive">public</span> <span class="type">int</span> nextInt() {
        <span class="keyword">return</span> random.nextInt();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that it is perfectly possible to rewrite the first example in such a way that the <code>final</code> modifier can be used.
From the point of view of the analyser, this does not matter.
The wider definition will allow for more situations to be recognized for what they really are.</p>
</div>
<div class="paragraph">
<p>When an object consists solely of primitives, or deeply immutable objects such as <code>java.lang.String</code>, having all
fields effectively final is sufficient to generate an object that is again deeply immutable.</p>
</div>
<div id="deeply-immutable1" class="listingblock">
<div class="title">Example 1, an object consisting of primitives and a string.</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">DeeplyImmutable1</span> {
    <span class="directive">public</span> <span class="directive">final</span> <span class="type">int</span> x;
    <span class="directive">public</span> <span class="directive">final</span> <span class="type">int</span> y;
    <span class="directive">public</span> <span class="directive">final</span> <span class="predefined-type">String</span> message;

    <span class="directive">public</span> DeeplyImmutable1(<span class="type">int</span> x, <span class="type">int</span> y, <span class="predefined-type">String</span> message) {
        <span class="local-variable">this</span>.message = message;
        <span class="local-variable">this</span>.x = x;
        <span class="local-variable">this</span>.y = y;
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Example 3, another way of being effectively final</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">DeeplyImmutable2</span> {
    <span class="annotation">@Final</span>
    <span class="directive">private</span> <span class="type">int</span> x;
    <span class="annotation">@Final</span>
    <span class="directive">private</span> <span class="type">int</span> y;
    <span class="annotation">@Final</span>
    <span class="directive">private</span> <span class="predefined-type">String</span> message;

    <span class="directive">public</span> DeeplyImmutable2(<span class="type">int</span> x, <span class="type">int</span> y, <span class="predefined-type">String</span> message) {
        <span class="local-variable">this</span>.message = message;
        <span class="local-variable">this</span>.x = x;
        <span class="local-variable">this</span>.y = y;
    }

    <span class="directive">public</span> <span class="predefined-type">String</span> getMessage() {
        <span class="keyword">return</span> message;
    }

    <span class="directive">public</span> <span class="type">int</span> getX() {
        <span class="keyword">return</span> x;
    }

    <span class="directive">public</span> <span class="type">int</span> getY() {
        <span class="keyword">return</span> y;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Examples 3 and 4 are functionally equivalent: there is no way of changing the values of the fields once they have been
set.
In the real world there may be a reason why someone requires the getters.
Or, you may be given code as in Example 2, but you are not allowed to change it.
Whatever the reason, the analyser should recognize effective finality.</p>
</div>
<div class="paragraph">
<p>Note that we will not make a distinction between any of the different non-private access modes in Java.
Only the private modifier gives sufficient guarantees that no reassignment to the fields is possible.</p>
</div>
<div class="paragraph">
<p>We now have observed that for the purpose of defining immutability, having all your fields effectively final can be
sufficient in certain, limited circumstances.</p>
</div>
<div class="paragraph">
<p>The analyser annotates types which are not immutable, but whose fields are all effectively final, with  <code>@FinalFields</code> .
Types that have at least one variable field are never immutable, and are optionally annotated with  <code>@FinalFields(absent=true)</code> .</p>
</div>
<div class="paragraph">
<p>Note that as of more recent versions of Java, the <code>record</code> type enforces explicitly final fields, along with additional
support for equality and visibility.
Any <code>record</code> will be at least  <code>@FinalFields</code> .</p>
</div>
<div class="paragraph">
<p>We will in this work make a distinction between a property being <em>effectively</em> or <em>eventually</em> present.
The former indicates a property as computed after construction of the object, which is potentially a little broader
than the definition of the language.
The latter is used when this property can only be obtained after the code reaches a certain state.
More on this later, but here is a first example of type with eventually final fields:</p>
</div>
<div class="listingblock">
<div class="title">Example 4, simplified version of <code>SetOnce</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">import</span> <span class="include">java.util.Random</span>;

<span class="annotation">@FinalFields</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">random</span><span class="delimiter">&quot;</span></span>)
<span class="type">class</span> <span class="class">OneRandom</span> {
    <span class="directive">private</span> <span class="predefined-type">Random</span> random;

    <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">random</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">void</span> set(<span class="predefined-type">Random</span> r) {
        <span class="keyword">if</span>(r == <span class="predefined-constant">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">NullPointerException</span>();
        <span class="keyword">if</span>(<span class="local-variable">this</span>.random != <span class="predefined-constant">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Already set</span><span class="delimiter">&quot;</span></span>);
        <span class="local-variable">this</span>.random = r;
    }

    <span class="annotation">@Only</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">random</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="predefined-type">Random</span> get() {
        <span class="keyword">if</span>(<span class="local-variable">this</span>.random == <span class="predefined-constant">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Not yet set</span><span class="delimiter">&quot;</span></span>);
        <span class="keyword">return</span> <span class="local-variable">this</span>.random;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once a value has been set, the field <code>random</code> cannot be assigned anymore.</p>
</div>
<div class="paragraph">
<p>We have just observed that if one restricts to primitives and types like <code>java.lang.String</code>, final fields are sufficient
to guarantee deep immutability.
It is not feasible, and we do not wish to, work <em>only</em> with deeply immutable objects.
Moreover, it is easy to see that final fields alone not enough to guarantee what we intuitively may think immutability
stands for:</p>
</div>
<div class="listingblock">
<div class="title">Example 5, final fields do not guarantee intuitive immutability</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@FinalFields</span>
<span class="type">class</span> <span class="class">StringsInArray</span> {
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">String</span><span class="type">[]</span> data;

    <span class="directive">public</span> StringsInArray(<span class="predefined-type">String</span><span class="type">[]</span> strings) {
        <span class="local-variable">this</span>.data = strings;
    }

    <span class="directive">public</span> <span class="predefined-type">String</span> getFirst() {
        <span class="keyword">return</span> data[<span class="integer">0</span>];
    }
}

...
String<span class="type">[]</span> strings = { <span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>, <span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span> };
StringsInArray sia = <span class="keyword">new</span> StringsInArray(strings);
Assert.assertEquals(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>, sia.getFirst());
strings[<span class="integer">0</span>] = <span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>; <i class="conum" data-value="1"></i><b>(1)</b>
Assert.assertEquals(<span class="string"><span class="delimiter">&quot;</span><span class="content">c</span><span class="delimiter">&quot;</span></span>, sia.getFirst()); <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>External modification of the array.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>As a consequence, the data structure has been modified.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To continue, we must first understand the notion of modification.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="modification">5. Modification</h2>
<div class="sectionbody">
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition</strong>: a <strong>method is modifying</strong> if it causes an assignment in the object graph of the fields of the object it is
applied to.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>We use the term 'object graph' to denote the fields of the object, the fields of these fields, etc., to arbitrary depth.</p>
</div>
<div class="paragraph">
<p>Consequently, a method is not modifying if it only reads from the object graph of the fields.
The analyser uses the annotations  <code>@NotModified</code> and  <code>@Modified</code> .
They are exclusive, and the analyser will compute one or the other for every method of the type.
All non-trivial constructors are modifying, so we avoid clutter by not annotating them.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Why not <code>@Modifying</code> and <code>@NotModifying</code>? The analyser will compute modifications of fields and parameters as well.
They will either be <em>modified</em> or <em>not modified</em> by the code. To avoid
confusion, we only use one set of annotations.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It follows from the definition that directly assigning to the fields also causes the  <code>@Modified</code>  mark for methods.
As a consequence, setters are  <code>@Modified</code> , while getters are  <code>@NotModified</code>.
Consider</p>
</div>
<div class="listingblock">
<div class="title">Example 6, modifying and non-modifying methods</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Counter</span> {
    <span class="comment">// variable</span>
    <span class="directive">private</span> <span class="type">int</span> counter;

    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="type">int</span> getCounter() {
        <span class="keyword">return</span> counter;
    }

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">int</span> increment() {
        counter += <span class="integer">1</span>;
        <span class="keyword">return</span> counter;
    }
}

<span class="annotation">@FinalFields</span>
<span class="type">class</span> <span class="class">CountedInfo</span> {
    <span class="annotation">@Modified</span>
    <span class="directive">private</span> <span class="directive">final</span> Counter counter = <span class="keyword">new</span> Counter();

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> printInfo(<span class="predefined-type">String</span> info) {
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Message </span><span class="delimiter">&quot;</span></span> + counter.increment() + <span class="string"><span class="delimiter">&quot;</span><span class="content">: </span><span class="delimiter">&quot;</span></span>+info);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We also see in the example that the <code>printInfo</code> method is  <code>@Modified</code> .
This is because it calls a modifying method on one of its fields, <code>increment</code>.</p>
</div>
<div class="paragraph">
<p>Moving from methods to parameters and fields, keeping the same two annotations,</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition</strong>:
The analyser marks a <strong>parameter</strong> as <strong>modified</strong> when the parameter&#8217;s method applies an assignment or modifying methods
to the object that enters the method via the parameter.
This definition holds with respect to the parameter&#8217;s entire object graph.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>We will apply a similar reasoning to a field:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition</strong>:
The analyser marks a <strong>field</strong> as <strong>modified</strong> when at least one of the type&#8217;s methods, transitively reachable from a
non-private non-constructor method, applies at least one assignment to or modifying method to this field.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Let us start by agreeing that the methods of <code>Object</code> and <code>String</code> are all  <code>@NotModified</code>.
This is pretty obvious in the case of <code>toString</code>, <code>hashCode</code>, <code>getClass</code>.
It is less obvious for the <code>wait</code> and other synchronization-related methods, but remember that as discussed in
the <a href="#assumptions">Assumptions</a>, we exclude synchronization support from this discussion.</p>
</div>
<div class="paragraph">
<p>Note also that we cannot add modifying methods to the type <code>DeeplyImmutable1</code> defined <a href="#deeply-immutable1">earlier</a>.</p>
</div>
<div class="paragraph">
<p>Proceeding, let us also look at (a part of) the <code>Collection</code> interface, where we have restricted the annotations
to  <code>@NotModified</code> and  <code>@Modified</code> &#8201;&#8212;&#8201; others will be introduced later.
An abstract method without  <code>@Modified</code>  is assumed to be non-modifying, i.e.,  <code>@NotModified</code> is implicitly present.
(The reason for this choice is explained later, in <a href="#abstract-methods">Abstract methods</a>.) While in normal classes the analyser
computes the annotations, in interfaces the user stipulates or <em>contracts</em> behaviour by annotating:</p>
</div>
<div class="listingblock">
<div class="title">Example 7, <a id="collection-interface"></a> modification aspects of the <code>Collection</code> interface</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">interface</span> <span class="class">Collection</span>&lt;E&gt; <span class="directive">extends</span> <span class="predefined-type">Iterable</span>&lt;E&gt; {
    <span class="annotation">@Modified</span>
    <span class="type">boolean</span> add(E e);

    <span class="annotation">@Modified</span>
    <span class="type">boolean</span> addAll(<span class="annotation">@NotModified</span> <span class="predefined-type">Collection</span>&lt;? <span class="directive">extends</span> E&gt; collection);

    <span class="type">boolean</span> contains(<span class="predefined-type">Object</span> object);

    <span class="type">boolean</span> containsAll(<span class="annotation">@NotModified</span> <span class="predefined-type">Collection</span>&lt;?&gt; c);

    <span class="type">void</span> forEach(Consumer&lt;? <span class="local-variable">super</span> E&gt; action);

    <span class="type">boolean</span> isEmpty();

    <span class="annotation">@Modified</span>
    <span class="type">boolean</span> remove(<span class="predefined-type">Object</span> object);

    <span class="annotation">@Modified</span>
    <span class="type">boolean</span> removeAll(<span class="annotation">@NotModified</span> <span class="predefined-type">Collection</span>&lt;?&gt; c);

    <span class="type">int</span> size();

    Stream&lt;E&gt; stream();

    <span class="predefined-type">Object</span><span class="type">[]</span> toArray();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Adding an object to a collection (set, list) will cause some assignment somewhere inside the data structure.
Returning the size of the collection should not.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Under supervision of the analyser, you will not be able to create an implementation of this interface
which violates the modification rules.
This is intentional: no implementation should modify the data structure when <code>size</code> is called.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Adding all elements of a collection to the object (in <code>addAll</code>) should not modify the input collection, whence the  <code>@NotModified</code>.
Other types in the parameters have not been annotated with  <code>@NotModified</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Object</code> because it is immutable;</p>
</li>
<li>
<p><code>E</code> because it is of an unbound generic type, it has the same methods available as <code>Object</code>.
No code visible to implementations of <code>Collection</code> can make modifications to <code>E</code> without explicit down-casting;</p>
</li>
<li>
<p><code>Consumer</code> because it is a functional interface (an interface with a single abstract method) in <code>java.util.function</code>;
they are  <code>@IgnoreModifications</code>  by convention, as explained later.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In order to keep the narrative going, we defer a discussion of modification in the context of parameters of abstract
types to the sections <a href="#abstract-methods">Abstract methods</a> and <a href="#hidden-content">More on hidden content</a>.
Here, we continue with the first use case of modification: containers.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="containers">6. Containers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Loosely speaking, a container is a type to which you can safely pass on your objects, it will not modify them.
This is the formal rule:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition</strong>: a type is a <strong>container</strong> when no non-private method or constructor modifies its arguments.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Whatever else the container does, storing the arguments in fields or not, it will not change the objects
you pass to it.
You obviously remain free to change them elsewhere; then the container may hold on to the changed object.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
We will use the term <em>argument</em> to denote the value passed to a <em>parameter</em>.
The latter is the variable, bound to a specific method, that receives this value.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Containers are complementary to immutable objects, and we will find that many immutable objects are containers,
while some containers are the precursors to immutable types.
There are two archetypes for containers: collections and builders.</p>
</div>
<div class="paragraph">
<p>The simple but useful utility type <code>Pair</code> trivially satisfies the container requirements:</p>
</div>
<div class="listingblock">
<div class="title">Example 8, a <code>Pair</code> of objects</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Container</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">Pair</span>&lt;K,V&gt; {
    <span class="directive">public</span> <span class="directive">final</span> K k;
    <span class="directive">public</span> <span class="directive">final</span> V v;

    <span class="directive">public</span> Pair(K k, V v) {
        <span class="local-variable">this</span>.k = k;
        <span class="local-variable">this</span>.v = v;
    }

    <span class="directive">public</span> K getK() {
        <span class="keyword">return</span> k;
    }

    <span class="directive">public</span> V getV() {
        <span class="keyword">return</span> v;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>While its fields are clearly final, it will remain to be seen if it satisfies all criteria for intuitive immutability.
However, it is easily recognized as a container: a type you use and trust to hold objects.</p>
</div>
<div class="paragraph">
<p>Containers occur frequently as static nested types to build immutable objects.
Examples of these will follow later, after the definition of immutability.</p>
</div>
<div class="paragraph">
<p>In the following example, the first class is computed to be a container, the second is a container according to the
contract, and the third is a class which cannot be a container:</p>
</div>
<div class="listingblock">
<div class="title">Example 9, two containers and a type that is not a container</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Container</span>
<span class="type">class</span> <span class="class">ErrorMessage</span> {
    <span class="comment">// variable</span>
    <span class="directive">private</span> <span class="predefined-type">String</span> message;

    <span class="directive">public</span> ErrorMessage(<span class="predefined-type">String</span> message) {
        <span class="local-variable">this</span>.message = message;
    }

    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="predefined-type">String</span> getMessage() {
        <span class="keyword">return</span> message;
    }

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> setMessage(<span class="predefined-type">String</span> message) {
        <span class="local-variable">this</span>.message = message;
    }
}

<span class="annotation">@Container</span>
<span class="type">interface</span> <span class="class">ErrorRegistry</span> {
    <span class="comment">// @NotModified implicitly</span>
    <span class="predefined-type">List</span>&lt;ErrorMessage&gt; getErrors();

    <span class="annotation">@Modified</span>
    <span class="type">void</span> addError(<span class="annotation">@NotModified</span> ErrorMessage errorMessage); <i class="conum" data-value="1"></i><b>(1)</b>
}

<span class="type">class</span> <span class="class">BinaryExpression</span> <span class="directive">extends</span> <span class="predefined-type">Expression</span> {
    <span class="directive">public</span> <span class="directive">final</span> <span class="predefined-type">Expression</span> lhs;
    <span class="directive">public</span> <span class="directive">final</span> <span class="predefined-type">Expression</span> rhs;

    <span class="comment">// ...</span>

    <span class="directive">public</span> <span class="type">void</span> evaluate(<span class="annotation">@Modified</span> ErrorRegistry errorRegistry) {
        <span class="comment">// ...</span>
        <span class="keyword">if</span>(lhs <span class="keyword">instanceof</span> NullConstant || rhs <span class="keyword">instanceof</span> NullConstant) {
            errorRegistry.addError(<span class="keyword">new</span> ErrorMessage(...)); <i class="conum" data-value="2"></i><b>(2)</b>
        }
        <span class="comment">// ...</span>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Implementations of <code>ErrorRegistry</code> will not be allowed to use the <code>setMessage</code> setter in <code>addError</code>, or in any
other method not mentioned here, if the <code>errorMessage</code> has been assigned or added to any of the fields.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Here a modifying method call takes place.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>BinaryExpression</code> class is not a container, because it uses one of the parameters of a public method,
<code>errorRegistry</code> of <code>evaluate</code>, as a writable container.</p>
</div>
<div class="paragraph">
<p>Arrays are essentially containers holding the  <code>@FinalFields</code>  property: a chunk of memory is held in an effectively final
field, and array access reads and writes from this memory object.
Indeed, consider the following semi-realistic implementation of an <code>Integer</code> array based on a <code>ByteBuffer</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example 10, an array is a container with final fields</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Container</span>
<span class="type">interface</span> <span class="class">Array</span>&lt;T&gt; {
    <span class="type">int</span> length();

    T get(<span class="type">int</span> index);

    <span class="annotation">@Modified</span>
    <span class="type">void</span> set(<span class="type">int</span> index, T t);
}

<span class="annotation">@FinalFields</span> <span class="annotation">@Container</span>
<span class="directive">static</span> <span class="type">class</span> <span class="class">IntArray</span> <span class="directive">implements</span> <span class="predefined-type">Array</span>&lt;<span class="predefined-type">Integer</span>&gt; {
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">ByteBuffer</span> byteBuffer;
    <span class="directive">private</span> <span class="directive">final</span> <span class="type">int</span> size;

    <span class="directive">public</span> IntArray(<span class="type">int</span> size) {
        <span class="local-variable">this</span>.size = size;
        byteBuffer = <span class="predefined-type">ByteBuffer</span>.wrap(<span class="keyword">new</span> <span class="type">byte</span>[size * <span class="predefined-type">Integer</span>.BYTES]);
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">int</span> length() {
        <span class="keyword">return</span> size;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="predefined-type">Integer</span> get(<span class="type">int</span> index) {
        <span class="keyword">return</span> byteBuffer.getInt(index * <span class="predefined-type">Integer</span>.BYTES);
    }

    <span class="annotation">@Override</span>
    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> set(<span class="type">int</span> index, <span class="predefined-type">Integer</span> i) {
        byteBuffer.putInt(index * <span class="predefined-type">Integer</span>.BYTES, i);
    }
}

<span class="annotation">@Test</span>
<span class="directive">public</span> <span class="type">void</span> test() {
    IntArray ia = <span class="keyword">new</span> IntArray(<span class="integer">5</span>);
    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="integer">0</span>; i &lt; <span class="integer">5</span>; i++) ia.set(i, i + <span class="integer">1</span>);
    assertEquals(<span class="integer">3</span>, ia.get(<span class="integer">2</span>));
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>It would have been better to show an <code>ErrorMessage</code> array, because, contrary to <code>Integer</code>, the former is
mutable (it has a modifying method <code>setMessage</code>). The technical aspect of storing and
retrieving the reference to the object, which is not normally available, prevents us from doing this here.</p>
</div>
<div class="paragraph">
<p>To conclude this section, note that the definition of <code>@Container</code> carefully words
<em>&#8230;&#8203; modifies its arguments</em>. This is almost equivalent
to ensuring that all non-private methods have all their parameters marked as  <code>@NotModified</code>. However, under those
conditions, it is still possible to change the object graph of the arguments, as the following example shows:</p>
</div>
<div class="listingblock">
<div class="title">Example 11, an instance where  <code>@NotModified</code> on the parameters is not enough to ensure  <code>@Container</code> </div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">ErrorRegistry</span> {
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">List</span>&lt;ErrorMessage&gt; messages = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;();

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> add(<span class="annotation">@NotModified</span> ErrorMessage message) {
        messages.add(message);
    }

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> changeFirst() {
        <span class="keyword">if</span>(!messages.isEmpty()) {
            messages.get(<span class="integer">0</span>).setMessage(<span class="string"><span class="delimiter">&quot;</span><span class="content">changed!</span><span class="delimiter">&quot;</span></span>);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, objects passed on to the <code>ErrorRegistry</code> are not modified by the <code>add</code> method, but they may be modified later
by a call to the <code>changeFirst</code> method, violating the idea that <em>all objects passed to the container are safe
from modification</em>.
The analyser will need to guard against this; and its tool to this end is <em>linking</em>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="linking-and-independence">7. Linking, dependence</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let us now elaborate on how we will compute modifications, in a path towards immutability.
Consider the following example:</p>
</div>
<div class="listingblock">
<div class="title">Example 12, a field assigned to a constructor parameter</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">LinkExample1</span>&lt;X&gt; {
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;X&gt; set;

    <span class="directive">public</span> LinkExample1(<span class="predefined-type">Set</span>&lt;X&gt; xs) {
        <span class="local-variable">this</span>.set = xs;
    }

    <span class="directive">public</span> <span class="type">void</span> add(X x) {
        set.add(x);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>After construction, an instance of <code>LinkExample1</code> contains a reference to the set that was passed on as an argument
to its constructor.
We say the field <code>set</code> links to the parameter <code>xs</code> of the constructor.
In this example, this is an expensive way of saying that there is an assignment from one to the other.
However, linking can become more complicated.</p>
</div>
<div class="paragraph">
<p>The  <em>e2immu</em>  analyser will add modification annotations to <code>LinkExample1</code> as follows:</p>
</div>
<div class="listingblock">
<div class="title">Example 13, a field linked to a constructor parameter, with annotations</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">LinkExample1</span>&lt;X&gt; {
    <span class="annotation">@Modified</span>
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;X&gt; set;

    <span class="directive">public</span> LinkExample1(<span class="annotation">@Modified</span> <span class="predefined-type">Set</span>&lt;X&gt; xs) {
        <span class="local-variable">this</span>.set = xs;
    }

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> add(X x) {
        set.add(x);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The parameter <code>x</code> of <code>LinkExample1.add</code> is  <code>@NotModified</code> because the first parameter of <code>Set.add</code> is  <code>@NotModified</code>.
The <code>LinkExample1.add</code> method modifies the field, which causes the annotation first on the method,
then on the field, and finally on the parameter of the constructor.
Because of the latter, <code>LinkExample1</code> cannot be marked  <code>@Container</code> .</p>
</div>
<div class="paragraph">
<p>Linking looks at the underlying object, and not at the variable.
Consider the following alternative <code>add</code> method:</p>
</div>
<div class="listingblock">
<div class="title">Example 14, alternative <code>add</code> method for <code>LinkExample1</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Modified</span>
<span class="directive">public</span> <span class="type">void</span> add(X x) {
    <span class="predefined-type">Set</span>&lt;X&gt; theSet = <span class="local-variable">this</span>.set;
    X theX = x;
    theSet.add(theX);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nothing has changed, obviously.
Finally, as an example of how linking can become more complicated than following assignments, consider a typical
<em>view</em> on a collection:</p>
</div>
<div class="listingblock">
<div class="title">Example 15, linking using a method call</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;X&gt; list = createSomeLargeList();
<span class="predefined-type">List</span>&lt;X&gt; sub = list.subList(<span class="integer">1</span>, <span class="integer">5</span>);
sub.set(<span class="integer">0</span>, x); <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The modifying method call <code>set</code> will modify <code>sub</code>, and <code>list</code> as well!</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>On the other side of the spectrum, linking does not work on objects that cannot be modified, like primitives or deeply
immutable objects such as the primitives, or <code>java.lang.String</code>.</p>
</div>
<div class="paragraph">
<p>Let us summarize by:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition</strong>: Two objects are not linked to each other when no modification to the first can imply a modification to
the second.</p>
</div>
<div class="paragraph">
<p>Conversely, two objects are dependent (or linked) when a modification to the first may imply a modification to the
second.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Linked objects must share a common sub-object: the object returned by <code>subList</code>, for example, is "backed" by the
original list, in other words, it maintains a reference to the original list.</p>
</div>
<div class="paragraph">
<p>We will discuss linking in more detail in <a href="#computing-dependence">How to compute linking</a>.
For now, assume that a field links to another field, or to a parameter, if there is a possibility that both variables
represent (part of) the same object (their object graphs overlap).</p>
</div>
<div class="paragraph">
<p>Linking between fields and parameters, and fields and return values of methods, is important to us:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition</strong>:
A method or constructor parameter is not linked when it is not linked to any of the fields of the type.
A method is <strong>not linked</strong> when its return value is not linked to any of the fields of the type.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>When a constructor parameter is linked, any modification made to the object presented to this parameter as an argument
may have an influence on the object graph of the fields of the constructor&#8217;s type.
But do all these modifications matter to the type?</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="accessible-hidden-content">8. Accessible and hidden content</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We will try to make our case using two examples.
First, consider <code>Counter</code> and <code>Counters</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example 16, Counter, Counters</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">Counter</span> {

  <span class="annotation">@Modified</span>
  <span class="type">void</span> increment();

  <span class="type">int</span> getValue();

  <span class="predefined-type">String</span> getName();
}

<span class="annotation">@FinalFields</span> <span class="annotation">@Container</span>
<span class="type">class</span> <span class="class">Counters</span> {
  <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, Counter&gt; counters;

  <span class="directive">public</span> Counters(<span class="predefined-type">Collection</span>&lt;Counter&gt; counterCollection) {
    <span class="local-variable">this</span>.counters = counterCollection.stream().collect
      (Collectors.toUnmodifiableMap(Counter::getName, c -&gt; c));
  }

  <span class="directive">public</span> Counter getCounter(<span class="predefined-type">String</span> name) {
    <span class="keyword">return</span> counters.get(name);
  }

  <span class="directive">public</span> <span class="type">int</span> getValue(<span class="predefined-type">String</span> name) {
    <span class="keyword">return</span> getCounter(name).getValue();
  }

  <span class="directive">public</span> <span class="type">void</span> increment(<span class="predefined-type">String</span> name) {
    getCounter(name).increment();
  }

  <span class="directive">public</span> <span class="type">void</span> incrementAll() {
    counters.values().forEach(Counter::increment);
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The constructor <code>Counters</code> copies every counter in the <code>counterCollection</code> into a new, unmodifiable map.
Clearly, external modifications to the collection itself (i.e., adding, removing a new <code>Counter</code> element) made after
creation of the <code>Counters</code> object, will have no effect on the object graph of the field <code>counters</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;Counter&gt; list = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;();
<span class="predefined-type">Collections</span>.addAll(list, <span class="keyword">new</span> CounterImpl(<span class="string"><span class="delimiter">&quot;</span><span class="content">sunny days</span><span class="delimiter">&quot;</span></span>), <span class="keyword">new</span> CounterImpl(<span class="string"><span class="delimiter">&quot;</span><span class="content">rainy days</span><span class="delimiter">&quot;</span></span>));
Counters counters = <span class="keyword">new</span> Counters(list);
Counter sunnyDays = list.remove(<span class="integer">0</span>);
<span class="keyword">assert</span> <span class="string"><span class="delimiter">&quot;</span><span class="content">sunny days</span><span class="delimiter">&quot;</span></span>.equals(sunnyDays.getName());
<span class="keyword">assert</span> sunnyDays == counters.getCounter(<span class="string"><span class="delimiter">&quot;</span><span class="content">sunny days</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, consider the following statements executed after creating a <code>Counters</code> object:</p>
</div>
<div class="listingblock">
<div class="title">Example 17, after creating a Counters object</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">int</span> rainyDays = counters.getValue(<span class="string"><span class="delimiter">&quot;</span><span class="content">rainy days</span><span class="delimiter">&quot;</span></span>);
Counter c = counters.get(<span class="string"><span class="delimiter">&quot;</span><span class="content">rainy days</span><span class="delimiter">&quot;</span></span>);
c.increment();
<span class="keyword">assert</span> c.getValue() == rainyDays + <span class="integer">1</span>;
<span class="keyword">assert</span> counters.getValue(<span class="string"><span class="delimiter">&quot;</span><span class="content">rainy days</span><span class="delimiter">&quot;</span></span>) == rainyDays + <span class="integer">1</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An external modification (<code>c.increment()</code>) to an object presented to the constructor as part of the collection has an
effect on the object graph of the fields, to the extent that an identical, non-modifying method call returns a
different value!</p>
</div>
<div class="paragraph">
<p>We must conclude that the parameter of the constructor <code>counterCollection</code> is linked to the field <code>counters</code>, even if
modifications at the collection level have no effect.</p>
</div>
<div class="paragraph">
<p>Now we put the <code>Counters</code> example in contrast with the <code>Levels</code> example, where the modifying method <code>increment()</code>
has been removed from <code>Counter</code> to obtain <code>Level</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example 18, Level, Levels</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">interface</span> <span class="class">Level</span> {
  <span class="type">int</span> getValue();
  <span class="predefined-type">String</span> getName();
}

<span class="type">class</span> <span class="class">Levels</span> {
  <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Map</span>&lt;<span class="predefined-type">String</span>, <span class="predefined-type">Level</span>&gt; levels;

  <span class="directive">public</span> Levels(<span class="predefined-type">Collection</span>&lt;<span class="predefined-type">Level</span>&gt; levelCollection) {
    <span class="local-variable">this</span>.levels = levelCollection.stream().collect
      (Collectors.toUnmodifiableMap(<span class="predefined-type">Level</span>::getName, c -&gt; c));
  }

  <span class="directive">public</span> <span class="predefined-type">Level</span> getLevel(<span class="predefined-type">String</span> name) {
    <span class="keyword">return</span> levels.get(name);
  }

  <span class="directive">public</span> <span class="type">int</span> getValue(<span class="predefined-type">String</span> name) {
    <span class="keyword">return</span> getLevel(name).getValue();
  }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As a consequence of the absence of <code>increment()</code> in <code>Level</code>, we had to remove <code>increment()</code> and <code>incrementAll()</code> from
<code>Levels</code> as well.
In fact, whether the <code>Level</code> instances are modifiable or not, does not seem to matter anymore to <code>Levels</code>.</p>
</div>
<div class="paragraph">
<p>We propose to split the object graph of a field into two parts: its accessible part, and its hidden part.</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition:</strong> A type <code>A</code>, part of the object graph of the fields of type <code>T</code>, is <strong>accessible</strong> inside the type <code>T</code> when
any of its methods or fields is accessed.
The methods of <code>java.lang.Object</code> are excluded from this definition.</p>
</div>
<div class="paragraph">
<p>A type that is part of the object graph of the fields, but is not accessible, is <strong>hidden</strong> (when it is an unbound type
parameter) or <strong>transparent</strong> (when it is not).</p>
</div>
</div>
</div>
<div class="paragraph">
<p>A type which is transparent can be replaced by an unbound type parameter, which is why we will use the term <em>hidden</em>
from now on.
Note: if it were not for transparent types, which are clearly accessible but are never accessed, we would not define
something "accessible" in terms of "accessed".
But we can argue that having transparent types in the code is poor programming practice
(to the extent that the analyser can be configured to raise an error when they are present),
and "hidden" is the complement of "accessible".</p>
</div>
<div class="paragraph">
<p>When a type <code>C</code> extends from a parent type <code>P</code>, we see an instance of <code>C</code> as being composed of two parts: the methods
and fields of <code>P</code>, augmented by the methods and fields of <code>C</code>.
Whilst the part of the parent, <code>P</code>, can be accessible, the part of the child <code>C</code> may remain hidden.
Similarly, when <code>T</code> implements the interface <code>I</code>, but the interface is used as the formal type, then the methods
and fields of <code>I</code> are accessible, but the ones augmented by the implementation <code>T</code> remain hidden.
In the example of <code>Level</code>, implementation or extensions may be modifiable (such as <code>Counter</code>), but when presented
with <code>Level</code> only, there are no modifications to be made.
Inside <code>Levels</code>, where we are limited to <code>Level</code>, no such extensions are accessible.</p>
</div>
<div class="paragraph">
<p>Armed with this definition, we split the combined object graph of the fields of a type into the accessible content,
and the hidden content:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition:</strong> The <strong>accessible content</strong> of a type are those objects of the object graph of the fields that are of
accessible type.</p>
</div>
<div class="paragraph">
<p>The <strong>hidden content</strong> of a type are those objects of the object graph of the fields that are of hidden (or transparent)
type.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that we must make this distinction, because every interface is meant to be implemented, and every type,
unless explicitly marked <code>final</code> or <code>sealed</code> can be extended in Java.
These extensions could be completely outside the control of the current implementation (even though we can use the
analyser to constrain them).</p>
</div>
<div class="paragraph">
<p>In the first example of this section, <code>LinkExample1</code>, objects of the type <code>X</code> form the hidden content of <code>LinkExample1</code>,
while the <code>Set</code> instance is the accessible content.
In <code>Counters</code>, <code>Map</code>, <code>String</code> and <code>Counter</code> are accessible, but whatever augments to <code>Counter</code> by implementing it r
emains hidden.
Exactly the same applies to <code>Levels</code>: <code>Map</code>, <code>String</code> and <code>Level</code> are accessible, but whatever augments <code>Level</code> by
implementing it remains hidden.</p>
</div>
<div class="paragraph">
<p>One of the central tenets of our definition of immutability will be that</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>A type is not responsible for modifications to its hidden content.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Recall that by definition, any modifications to the hidden content must be external to the type.</p>
</div>
<div class="paragraph">
<p>We end this section by defining what linking means with respect to the accessible and hidden content of the fields.
The definition of linking given in the previous section is absolute, in the sense that it covers the whole object graph
of the objects being linked.</p>
</div>
<div class="paragraph">
<p>When a parameter is linked to a field, we could try to find out if the modifications affect the accessible content,
given that we state that modifications to the hidden content are outside the scope of the type anyway.
In other words, we could distinguish between different forms of linking:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition:</strong> a parameter or method return value is</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>dependent</strong> on the fields if and only if it is linked to the accessible content of the type.</p>
</li>
<li>
<p><strong>independent</strong> of the fields if and only if it is at most linked to the hidden content of the type</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>In other words, a parameter or method return value is dependent when a modification on the argument or returned value
has the possibility to cause a modification in the accessible part of the fields.</p>
</div>
<div class="paragraph">
<p>Linking between parameters or return value and fields which does not involve the accessible part of the fields, is
called independence.
We will elaborate in <a href="#hidden-content">More on hidden content</a>.
In the following sections, we will often use the term 'independent' when we mean 'not-dependent', i.e., when there is
no linking or only linking to the hidden part of the object graph of the fields.</p>
</div>
<div class="paragraph">
<p>In terms of annotations, dependence will be the default state for objects of types where dependence is possible.
We will not annotate it most of the time; if we do, we use the annotation <code>@Independent(absent=true)</code>.
The annotation  <code>@Independent</code>  on parameters and methods will be used for absence of linking.
When a type is deeply immutable,  <code>@Independent</code>  is the default state, and therefore it will be omitted.
We use <code>@Independent(hc=true)</code> to stress the linking to the hidden part.</p>
</div>
<div class="paragraph">
<p>Now, all pieces of the puzzle are available to introduce immutability of types.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_immutability">9. Immutability</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_definition_and_examples">9.1. Definition and examples</h3>
<div class="paragraph">
<p>First, what do we want intuitively?
A useful form of immutability, less strong than deeply immutable, but stronger than final fields for many situations.
We propose the following description:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>After construction, an immutable type holds a number of objects; the type will not change their content, nor will i
t exchange these objects for other objects, or allow others to do so.
The type is not responsible for what others do to the content of the objects it was given.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Technically, immutability is much harder to define than final fields.
We identify three rules, on top of the obvious final fields requirement.
The first one prevents the type from making changes to its own fields:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition</strong>: the <strong>first rule of immutability</strong> is that all fields must be  <code>@NotModified</code>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Our friend the <code>Pair</code> satisfies this first rule:</p>
</div>
<div id="type-pair" class="listingblock">
<div class="title">Example 2, the class <code>Pair</code>, revisited</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">Pair</span>&lt;K,V&gt; {
    <span class="directive">public</span> <span class="directive">final</span> K k;
    <span class="directive">public</span> <span class="directive">final</span> V v;

    <span class="directive">public</span> Pair(K k, V v) {
        <span class="local-variable">this</span>.k = k;
        <span class="local-variable">this</span>.v = v;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that since <code>K</code> and <code>V</code> are unbound generic types, it is not even possible to modify their content from inside `
Pair`, since there are no modifying methods one can call on unbound types.
The types <code>K</code> and <code>V</code> are hidden in <code>Pair</code>; it does not have any accessible content.</p>
</div>
<div class="paragraph">
<p>How does it fit the intuitive rule for immutability?
The type <code>Pair</code> holds two objects.
The type does not change their content, nor will it exchange these two objects for others, or allow others to do so.
It is clear the users of <code>Pair</code> may be able to change the content of the objects they put in the <code>Pair</code>.
Summarizing: <code>Pair</code> fits the intuitive definition nicely.</p>
</div>
<div class="paragraph">
<p>Here is an example which shows the necessity of the first rule more explicitly:</p>
</div>
<div id="point-and-line" class="listingblock">
<div class="title">Example 3: the types <code>Point</code> and <code>Line</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Container</span>
<span class="type">class</span> <span class="class">Point</span> {
    <span class="comment">// variable</span>
    <span class="directive">private</span> <span class="type">double</span> x;

    <span class="comment">// variable</span>
    <span class="directive">private</span> <span class="type">double</span> y;

    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="type">double</span> getX() {
        <span class="keyword">return</span> x;
    }

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> setX(<span class="type">double</span> x) {
        <span class="local-variable">this</span>.x = x;
    }

    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="type">double</span> getY() {
        <span class="keyword">return</span> y;
    }

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> setY(<span class="type">double</span> y) {
        <span class="local-variable">this</span>.y = y;
    }
}

<span class="annotation">@Container</span> <span class="annotation">@FinalFields</span>
<span class="type">class</span> <span class="class">Line</span> {
    <span class="annotation">@Final</span>
    <span class="annotation">@Modified</span>
    <span class="directive">private</span> <span class="predefined-type">Point</span> point1;

    <span class="annotation">@Final</span>
    <span class="annotation">@Modified</span>
    <span class="directive">private</span> <span class="predefined-type">Point</span> point2;

    <span class="directive">public</span> <span class="predefined-type">Line</span>(<span class="predefined-type">Point</span> point1, <span class="predefined-type">Point</span> point2) {
        <span class="local-variable">this</span>.point1 = point1;
        <span class="local-variable">this</span>.point2 = point2;
    }

    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="predefined-type">Point</span> middle() {
        <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">Point</span>((point1.getX() + point2.getX())/<span class="float">2.0</span>,
             (point1.getY()+point2.getY())/<span class="float">2.0</span>);
    }

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> translateHorizontally(<span class="type">double</span> x) {
        point1.setX(point1.getX() + x); <i class="conum" data-value="1"></i><b>(1)</b>
        point2.setX(point2.getX() + x);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Modifying operation on <code>point1</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The fields <code>point1</code> and <code>point2</code> are effectively final.
Without the translation method, the fields would be  <code>@NotModified</code> as well.
The translation method modifies the fields' content, preventing the type from becoming immutable.</p>
</div>
<div class="paragraph">
<p>From the restriction of rule 1, that all its fields should remain unmodified, it follows that, excluding external
changes, every method call on a immutable container object with the same arguments will render the same result.
We note that this statement cannot be bypassed by using <em>static</em> state, i.e., state specific to the type rather
than the object.
The definitions make no distinction between static and instance fields.</p>
</div>
<div class="paragraph">
<p>To obtain a useful definition of immutability, one which is not too strict yet follows our intuitive requirements,
we should allow modifiable fields, if they are properly shielded from the modifications they intrinsically allow.
We will introduce two additional rules to constrain the modifications of this modifiable data.
Together with the first rule, and building on final fields, we define:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition</strong>: A type is <strong>immutable</strong> when</p>
</div>
<div class="paragraph">
<p><strong>Rule 0</strong>: All its fields are effectively final.</p>
</div>
<div class="paragraph">
<p><strong>Rule 1</strong>: All its fields are  <code>@NotModified</code>.</p>
</div>
<div class="paragraph">
<p><strong>Rule 2</strong>: All its fields are either private, or of immutable type themselves.</p>
</div>
<div class="paragraph">
<p><strong>Rule 3</strong>: No parameters of non-private methods or non-private constructors, no return values of non-private methods,
are dependent on (the accessible part of) the fields.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Rule 2 is there to ensure that the modifiable fields of the object cannot be modified externally by means of direct
field access to the non-private fields.
Rule 3 ensures that the modifiable fields of the object cannot be modified externally by obtaining or sharing
references to the fields via a parameter or return value.</p>
</div>
<div class="paragraph">
<p>Types which are immutable will be marked  <code>@Immutable</code> .
When they are containers too, which should be the large majority, we use   <code>@ImmutableContainer</code>  as a shorthand for
the combination of the two annotations.</p>
</div>
<div class="paragraph">
<p>Note that:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>We state that all primitive types are immutable, as is <code>java.lang.Object</code>.
Whilst this is fairly obvious in the case of primitives, immutability for <code>Object</code> requires us to either ignore the
methods related to synchronization, or to assume that its implementation (for it is not an abstract type) has no fields.</p>
</li>
<li>
<p>A consequence of rule 1 is that all methods in a immutable type must be  <code>@NotModified</code>.</p>
</li>
<li>
<p>A field whose type is an unbound type parameter, can locally be considered to be of immutable type, and therefore
need not be private.
This is because the type parameter could be substituted by <code>java.lang.Object</code>, which we have just declared to be
immutable.
More details can be found in the section on <a href="#generics">Generics</a>.</p>
</li>
<li>
<p>Constructor parameters whose formal type is an unbound type parameter, are of hidden type inside the type of the
constructor.
As a consequence, rule 3 does not apply to them.
This will be expanded on in <a href="#hidden-content">More on hidden content</a>.</p>
</li>
<li>
<p>The section on <a href="#inheritance">Inheritance</a> will show how the immutability property relates to implementing interfaces, and
sub-classing.
This is important because the definition is recursive, with <code>java.lang.Object</code> the immutable base of the recursion.
All other types must extend from it.</p>
</li>
<li>
<p>The section on <a href="#abstract-methods">Abstract methods</a> will detail how immutability is computed for abstract types (interfaces,
abstract classes).</p>
</li>
<li>
<p>The first rule can be reached <em>eventually</em> if there is one or more methods that effect a transition from the
mutable to the immutable state.
This typically means that all methods that assign or modify fields become off-limits after calling this marker method.
Eventuality for rules 2 and 3 seems too far-fetched.
We address the topic of eventual immutability fully in the section <a href="#eventual-immutability">Eventual immutability</a>.</p>
</li>
<li>
<p>When the type has fields which allow hidden content, or the type is extendable (see <a href="#extendability">Extendability of types</a>),
 the extra parameter <code>hc=true</code> will be added to the annotation.
The presence of this parameter is for instructive purposes only.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let us go to examples immediately.</p>
</div>
<div class="listingblock">
<div class="title">Example 19, explaining immutability: with array, version 1, not good</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@FinalFields</span> <span class="annotation">@Container</span>
<span class="type">class</span> <span class="class">ArrayContainer1</span>&lt;T&gt; {
    <span class="annotation">@NotModified</span>
    <span class="directive">private</span> <span class="directive">final</span> T<span class="type">[]</span> data;

    <span class="directive">public</span> ArrayContainer1(T<span class="type">[]</span> ts) {
        <span class="local-variable">this</span>.data = ts;
    }

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>)
    <span class="directive">public</span> Stream&lt;T&gt; stream() {
        <span class="keyword">return</span> <span class="predefined-type">Arrays</span>.stream(data);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>After creation, external changes to the source array <code>ts</code> are effectively modifications to the field <code>data</code>.
This construct fails rule 3, as the parameter <code>ts</code> is dependent.
The field is a modifiable data structure, and must be shielded from external modifications.</p>
</div>
<div class="paragraph">
<p>Note the use of  <code>@Independent(hc=true)</code>  annotation on the return value of <code>stream()</code>, to indicate that modifications to the
hidden content are possible on objects obtained from the stream.</p>
</div>
<div class="listingblock">
<div class="title">Example 20, explaining immutability: with array, version 2, not good</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@FinalFields</span> <span class="annotation">@Container</span>
<span class="type">class</span> <span class="class">ArrayContainer2</span>&lt;T&gt; {
    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="directive">final</span> T<span class="type">[]</span> data;

    <span class="directive">public</span> ArrayContainer2(<span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) T<span class="type">[]</span> ts) {
        <span class="local-variable">this</span>.data = <span class="keyword">new</span> T[ts.length];
        <span class="predefined-type">System</span>.arraycopy(ts, <span class="integer">0</span>, data, <span class="integer">0</span>, ts.length);
    }

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>)
    <span class="directive">public</span> Stream&lt;T&gt; stream() {
        <span class="keyword">return</span> <span class="predefined-type">Arrays</span>.stream(data);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Users of this type can modify the content of the array using direct field access!
This construct fails rule 2, which applies for the same reasons as in the previous example.</p>
</div>
<div class="listingblock">
<div class="title">Example 21, explaining immutability: with array, version 3, safe</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>(hc=<span class="predefined-constant">true</span>)
<span class="type">class</span> <span class="class">ArrayContainer3</span>&lt;T&gt; {
    <span class="annotation">@NotModified</span>
    <span class="directive">private</span> <span class="directive">final</span> T<span class="type">[]</span> data; <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="directive">public</span> ArrayContainer3(<span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) T<span class="type">[]</span> ts) {
        <span class="local-variable">this</span>.data = <span class="keyword">new</span> T[ts.length]; <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="predefined-type">System</span>.arraycopy(ts, <span class="integer">0</span>, data, <span class="integer">0</span>, ts.length);
    }

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>)
    <span class="directive">public</span> Stream&lt;T&gt; stream() {
        <span class="keyword">return</span> <span class="predefined-type">Arrays</span>.stream(data);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The array is private, and therefore protected from external modification via the direct access route.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The array has been copied, and therefore is independent of the one passed in the parameter.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The independence rule enforces the type to have its own modifiable structure, rather than someone else&#8217;s.
Here is the same group of examples, now with JDK Collections:</p>
</div>
<div class="listingblock">
<div class="title">Example 22, explaining immutability: with collection, version 1, not good</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@FinalFields</span> <span class="annotation">@Container</span>
<span class="type">class</span> <span class="class">SetBasedContainer1</span>&lt;T&gt; {
    <span class="annotation">@NotModified</span>
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;T&gt; data;

    <span class="annotation">@Dependent</span>
    <span class="directive">public</span> SetBasedContainer1(<span class="predefined-type">Set</span>&lt;T&gt; ts) {
        <span class="local-variable">this</span>.data = ts; <i class="conum" data-value="1"></i><b>(1)</b>
    }

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>)
    <span class="directive">public</span> Stream&lt;T&gt; stream() {
        <span class="keyword">return</span> data.stream();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>After creation, changes to the source set are effectively changes to the data.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The lack of independence of the constructor violates rule 3 in the first example.</p>
</div>
<div class="listingblock">
<div class="title">Example 23, explaining immutability: with collection, version 2, not good</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@FinalFields</span> <span class="annotation">@Container</span>
<span class="type">class</span> <span class="class">SetBasedContainer2</span>&lt;T&gt; {
    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;T&gt; data; <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="directive">public</span> SetBasedContainer2(<span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) <span class="predefined-type">Set</span>&lt;T&gt; ts) {
        <span class="local-variable">this</span>.data = <span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;&gt;(ts);
    }

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>)
    <span class="directive">public</span> Stream&lt;T&gt; stream() {
        <span class="keyword">return</span> data.stream();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Users of this type can modify the content of the set after creation!</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here, the <code>data</code> field is public, which allows for external modification.</p>
</div>
<div class="listingblock">
<div class="title">Example 24, explaining immutability: with collection, version 3, safe</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>(hc=<span class="predefined-constant">true</span>)
<span class="type">class</span> <span class="class">SetBasedContainer3</span>&lt;T&gt; {
    <span class="annotation">@NotModified</span>
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;T&gt; data; <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="directive">public</span> SetBasedContainer3(<span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) <span class="predefined-type">Set</span>&lt;T&gt; ts) {
        <span class="local-variable">this</span>.data = <span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;&gt;(ts); <i class="conum" data-value="2"></i><b>(2)</b>
    }

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>)
    <span class="directive">public</span> Stream&lt;T&gt; stream() {
        <span class="keyword">return</span> data.stream();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The set is private, and therefore protected from external modification.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The set has been copied, and therefore is independent of the one passed in the parameter.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Finally, we have an immutable type.
The next one is immutable as well:</p>
</div>
<div class="listingblock">
<div class="title">Example 25, explaining immutability: with collection, version 4, safe</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>(hc=<span class="predefined-constant">true</span>)
<span class="type">class</span> <span class="class">SetBasedContainer4</span>&lt;T&gt; {

    <span class="annotation">@ImmutableContainer</span>(hc=<span class="predefined-constant">true</span>)
    <span class="directive">public</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;T&gt; data; <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="directive">public</span> SetBasedContainer4(<span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) <span class="predefined-type">Set</span>&lt;T&gt; ts) {
        <span class="local-variable">this</span>.data = <span class="predefined-type">Set</span>.copyOf(ts); <i class="conum" data-value="2"></i><b>(2)</b>
    }

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>)
    <span class="directive">public</span> Stream&lt;T&gt; stream() {
        <span class="keyword">return</span> data.stream();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>the data is public, but the <code>Set</code> is  <code>@Immutable</code>  itself, because its content is the result of <code>Set.copyOf</code>,
which is an implementation that blocks any modification.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Independence guaranteed.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The section on <a href="#dynamic-type-annotations">Dynamic type annotations</a> will explain how the  <code>@Immutable</code>  annotation travels to the field <code>data</code>.</p>
</div>
<div class="paragraph">
<p>The independence rule, rule 3, is there to ensure that the type does not expose its modifiable data through parameters
and return types:</p>
</div>
<div class="listingblock">
<div class="title">Example 26, explaining immutability: with collection, version 5, not good</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@FinalFields</span> <span class="annotation">@Container</span>
<span class="type">class</span> <span class="class">SetBasedContainer5</span>&lt;T&gt; {
    <span class="annotation">@NotModified</span>
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;T&gt; data; <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="directive">public</span> SetBasedContainer5(<span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) <span class="predefined-type">Set</span>&lt;T&gt; ts) {
        <span class="local-variable">this</span>.data = <span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;&gt;(ts); <i class="conum" data-value="2"></i><b>(2)</b>
    }

    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;T&gt; getSet() {
        <span class="keyword">return</span> data; <i class="conum" data-value="3"></i><b>(3)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>No exposure via the field</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>No exposure via the parameter of the constructor</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>&#8230;&#8203; but exposure via the getter.
The presence of the getter is equivalent to adding the modifiers <code>public final</code> to the field.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that by decomposing rules 0 and 1, we observe that requiring all fields to be  <code>@Final</code>  and  <code>@NotModified</code> is equivalent to
requiring that all non-private fields have the <code>final</code> modifier, and that methods that are not part of the
construction phase, are  <code>@NotModified</code>.
The final example shows a type which violates this rule 1, because a modifying method has been added:</p>
</div>
<div class="listingblock">
<div class="title">Example 27, explaining immutability: with collection, version 6, not good</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@FinalFields</span> <span class="annotation">@Container</span>
<span class="type">class</span> <span class="class">SetBasedContainer6</span>&lt;T&gt; {
    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;T&gt; set = <span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;&gt;();

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> add(<span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) T t) { set.add(t); }

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>)
    <span class="directive">public</span> Stream&lt;T&gt; stream() { <span class="keyword">return</span> set.stream(); }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="inheritance">9.2. Inheritance</h3>
<div class="paragraph">
<p>Deriving from an immutable class is the most normal situation: since <code>java.lang.Object</code> is an immutable container,
every class will do so.
Clearly, the property is not inherited.</p>
</div>
<div class="paragraph">
<p>Most importantly, in terms of inheritance, is that the analyser prohibits changing the modification status of
methods from non-modifying to modifying in a derived type.
This means, for example, that the analyser will block a modifying <code>equals()</code> or <code>toString()</code> method, in any class.
Similarly, no implementation of <code>java.util.Collection.size()</code> will be allowed to be modifying.</p>
</div>
<div class="paragraph">
<p>The guiding principle here is that of <em>consistency of expectation</em>: software developers are expecting that
<code>equals</code> is non-modifying.
They know that a setter will make an assignment, but they&#8217;ll expect a getter to simply return a value.
No getter should ever be modifying.</p>
</div>
<div class="paragraph">
<p>The other direction is more interesting, while equally simple to explain: deriving from a parent class cannot
increase the immutability level.
A method overriding one marked  <code>@Modified</code>  does not have to be modifying, but it is not allowed to be explicitly
marked  <code>@NotModified</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example 28, illegal modification status of methods</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">abstract</span> <span class="type">class</span> <span class="class">MyString</span> <span class="directive">implements</span> <span class="predefined-type">Collection</span>&lt;<span class="predefined-type">String</span>&gt; {
    <span class="directive">private</span> <span class="predefined-type">String</span> string = <span class="string"><span class="delimiter">&quot;</span><span class="delimiter">&quot;</span></span>;

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">int</span> size() {
        string = string + <span class="string"><span class="delimiter">&quot;</span><span class="content">!</span><span class="delimiter">&quot;</span></span>; <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="keyword">return</span> string.length();
    }

    <span class="annotation">@Override</span>
    <span class="annotation">@NotModified</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="directive">public</span> <span class="directive">abstract</span> <span class="type">boolean</span> add(<span class="predefined-type">String</span> s);
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Not allowed!
Any implementation of <code>Collection.size()</code> must be non-modifying.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Not allowed!
You cannot explicitly (contractually) change <code>Collection.add()</code> from  <code>@Modified</code>  to  <code>@NotModified</code> in a subtype.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Following the same principles, we observe that types deriving from a  <code>@Container</code>  super-type need not be a container
themselves.
So while we may state that <code>Collection</code> is a container, it is perfectly possible to implement a collection which
has public methods which modify their parameters, as long as the methods inherited from <code>Collection</code> do not
modify their parameters, and the implementation does not modify the objects linked to the parameters of the
<code>Collection</code> methods.</p>
</div>
<div class="paragraph">
<p>Note that sealed types (since JDK 17) reject the 'you can always extend' assumptions of Java types.
In this case, all subtypes are known, and visible.
The single practical consequence is that if the parent type is abstract, its annotations need not be contracted:
they can be computed because all implementations are available to the analyser.</p>
</div>
</div>
<div class="sect2">
<h3 id="generics">9.3. Generics</h3>
<div class="paragraph">
<p>Type parameters are either <em>unbound</em>, in which case they can represent any type, or they explicitly extend a given type.
Because the unbound case is simply a way of saying that the type parameter extends <code>java.lang.Object</code>, we can say
that all type parameters extend a certain type, say <code>T extends E</code>.</p>
</div>
<div class="paragraph">
<p>The analyser simply treats the parameterized type <code>T</code> as if it were the type <code>E</code>.
In the case of an unbound parameter type, only the public methods of <code>java.lang.Object</code> are accessible.
By definition, the type belongs to the hidden content, as defined in <a href="#accessible-hidden-content">Accessible and hidden content</a>.</p>
</div>
<div class="paragraph">
<p>The analyser recognises types that can be replaced by an unbound parameter type, when they are used <em>transparently</em>,
and therefore belong to the hidden content: no methods are called on it, save the ones from <code>java.lang.Object</code>;
none of its fields are accessed, and it is not used as an argument to parameters where anything more specific than
<code>java.lang.Object</code> is required.
It will issue a warning, and internally treat the type as an unbound parameter type, and hence  <code>@ImmutableContainer</code> ,
even if the type is obviously modifiable.</p>
</div>
<div class="paragraph">
<p>The following trivial example should clarify:</p>
</div>
<div class="listingblock">
<div class="title">Example 29, a type used transparently in a class</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>(hc=<span class="predefined-constant">true</span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">OddPair</span> {

    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt; set;
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">StringBuilder</span> sb;

    <span class="directive">public</span> OddPair(<span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt; set, <span class="predefined-type">StringBuilder</span> sb) {
        <span class="local-variable">this</span>.set = set;
        <span class="local-variable">this</span>.sb = sb;
    }

    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt; getSet() { <span class="keyword">return</span> set; }
    <span class="directive">public</span> <span class="predefined-type">StringBuilder</span> getSb() { <span class="keyword">return</span> sb; }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nowhere in <code>OddPair</code> do we make actual use of the fact that <code>set</code> is of type <code>Set</code>, or <code>sb</code> is of type <code>StringBuilder</code>.
The analyser encourages you to replace <code>Set</code> by some unbound parameter type, say <code>K</code>, and <code>StringBuilder</code> by some other,
say <code>V</code>.
The result is, of course, the type <code>Pair</code> as defined <a href="#type-pair">earlier</a>.</p>
</div>
<div class="paragraph">
<p>Making a concrete choices for a type parameter may have an effect on the immutability status, as will be explained in
<a href="#hidden-content">More on hidden content</a>.
Some examples are easy to see: any  <code>@FinalFields</code>  type whose fields consist only of types of unbound type parameter,
will become immutable when the unbound type parameters are substituted for immutable types.
Any immutable type whose hidden content consists only of types of unbound type parameter, will become deeply
immutable (i.e., devoid of hidden content) when the unbound type parameters are substituted for deeply immutable types.
The <code>Pair</code> mentioned before is a case in point, and an example for both rules: <code>Pair&lt;Integer, Long&gt;</code> is deeply immutable.</p>
</div>
</div>
<div class="sect2">
<h3 id="abstract-methods">9.4. Abstract methods</h3>
<div class="paragraph">
<p>Because <code>java.lang.Object</code> is an immutable container, trivial extensions are, too:</p>
</div>
<div class="listingblock">
<div class="title">Example 30, trivial extensions of <code>java.lang.Object</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span> <i class="conum" data-value="1"></i><b>(1)</b>
<span class="type">interface</span> <span class="class">Marker</span> { }

<span class="annotation">@ImmutableContainer</span>
<span class="type">class</span> <span class="class">EmptyClass</span> { }

<span class="annotation">@ImmutableContainer</span>
<span class="type">class</span> <span class="class">ImplementsMarker</span> <span class="directive">implements</span> Marker { }

<span class="annotation">@ImmutableContainer</span>
<span class="type">class</span> <span class="class">ExtendsEmptyClass</span> <span class="directive">extends</span> ImplementsMarker { }</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Because interfaces are meant to be extended, adding <code>hc=true</code> is completely superfluous.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Things only become interesting when methods enter the picture.
Annotation-wise, we stipulate that</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Unless otherwise explicitly annotated, we will assume that abstract methods, be they in interfaces or
abstract classes, are  <code>@NotModified</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Furthermore, we will also impose special variants of the rules for immutability of an abstract type <code>T</code>, to be obeyed
by the abstract methods:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Variant of rule 1</strong>: Abstract methods must be non-modifying.</p>
</div>
<div class="paragraph">
<p><strong>Variant of rule 3</strong>: Abstract methods returning values must be not be dependent, i.e., the object they return must be
not be dependent on the fields.
They cannot expose the fields via parameters: parameters of non-primitive, non-immutable type must not be dependent.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>The consequence of these choices is that implementations and extensions of abstract and non-abstract types will have
the opportunity to have the same immutability properties.
This allows us, e.g., to treat any implementation of <code>Comparable</code>, defined as:</p>
</div>
<div class="listingblock">
<div class="title">Example 31, <code>java.lang.Comparable</code> annotated</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>
<span class="type">interface</span> <span class="class">Comparable</span>&lt;T&gt; {

    <span class="comment">// @NotModified implicitly present</span>
    <span class="type">int</span> compareTo(<span class="annotation">@NotModified</span> T other);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>as an immutable type when the only method we can access is <code>compareTo</code>.</p>
</div>
<div class="paragraph">
<p>As for as the modification status of the <em>parameters</em> of abstract methods is concerned, we start off with  <code>@Modified</code> 
rather than with  <code>@NotModified</code>:</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
Unless otherwise explicitly annotated, or their types are immutable, we will assume that the parameters of
abstract methods, be they in interfaces or abstract classes, are  <code>@Modified</code> .
Overriding the method, the contract can change from  <code>@Modified</code>  to  <code>@NotModified</code>, but not from  <code>@NotModified</code> to  <code>@Modified</code> .
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>While it is possible to compute the immutability and container status of interface types, using the rules presented
above, it often makes more practical sense to use the annotations as contracts: they may save a lot of annotation work
on the abstract methods in the interface.
We repeat that no implementation of a immutable interface is guaranteed to be immutable itself; nor does this
guarantee hold for the container property unless no new non-private methods have been added.</p>
</div>
<div class="paragraph">
<p>We continue this section with some examples which will form the backbone of the examples in <a href="#hidden-content">More on hidden content</a>.</p>
</div>
<div class="paragraph">
<p>If semantically used correctly, types implementing the <code>HasSize</code> interface expose a single numeric aspect of their
content:</p>
</div>
<div class="listingblock">
<div class="title">Example 32, the <code>HasSize</code> interface</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span> <span class="comment">// computed (or contracted)</span>
<span class="type">interface</span> <span class="class">HasSize</span> {

    <span class="comment">// implicitly present: @NotModified</span>
    <span class="type">int</span> size();

    <span class="annotation">@NotModified</span> <span class="comment">// computed, not an abstract method!</span>
    <span class="keyword">default</span> <span class="type">boolean</span> isEmpty() {
        <span class="keyword">return</span> size() == <span class="integer">0</span>;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We extend to:</p>
</div>
<div class="listingblock">
<div class="title">Example 33, still immutable: <code>NonEmptyImmutableList</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span> <span class="comment">// computed, contracted</span>
<span class="type">interface</span> <span class="class">NonEmptyImmutableList</span>&lt;T&gt; <span class="directive">extends</span> HasSize {

    <span class="comment">// implicitly present: @NotModified</span>
    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) <i class="conum" data-value="1"></i><b>(1)</b>
    T first();

    <span class="comment">// implicitly present: @NotModified</span>
    <span class="type">void</span> visit(<span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) Consumer&lt;T&gt; consumer);  <i class="conum" data-value="2"></i><b>(2)</b> <i class="conum" data-value="3"></i><b>(3)</b>

    <span class="annotation">@NotModified</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="annotation">@Override</span>
    <span class="keyword">default</span> <span class="type">boolean</span> isEmpty() {
        <span class="keyword">return</span> <span class="predefined-constant">false</span>;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Whilst formally, <code>T</code> can never be dependent because it must belong to the hidden content of the interface,
contracting the  <code>@Independent(hc=true)</code>  annotation here will force all concrete implementations to have an non-dependent
<code>first</code> method.
If the concrete choice for <code>T</code> is modifiable, the independence rule must be satisfied.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The parameter <code>consumer</code> would normally be  <code>@Modified</code> , which would break the  <code>@Container</code>  property that we wish for
<code>NonEmptyImmutableList</code>.
However, as detailed and explained in <a href="#hidden-content">More on hidden content</a>, the abstract types in <code>java.util.function</code> receive an implicit
 <code>@IgnoreModifications</code>  annotation.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The hidden content of the type is exposed to the outside world via the <code>accept</code> method in the consumer,
similarly to being exposed via the return value of the <code>first</code> method.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Computed, because it is not an abstract method.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>Consumer</code> interface is defined and annotated as:</p>
</div>
<div class="listingblock">
<div class="title">Example 34, the java.util.function.Consumer interface, annotated</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@FunctionalInterface</span>
<span class="type">interface</span> <span class="class">Consumer</span>&lt;T&gt; {

    <span class="annotation">@Modified</span>
    <span class="type">void</span> accept(T t); <span class="comment">// @Modified on t implicit</span>
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Implementations of the <code>accept</code> method are allowed to be modifying (even though in <code>NonEmptyImmutableList.visit</code>
we decide to ignore this modification!).
They are also allowed to modify their parameter, as we will demonstrate shortly.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s downgrade from  <code>@ImmutableContainer</code>  to  <code>@FinalFields</code>   <code>@Container</code>  by adding a modifying method:</p>
</div>
<div id="NonEmptyList" class="listingblock">
<div class="title">Example 4, not immutable anymore: <code>NonEmptyList</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@FinalFields</span> <span class="annotation">@Container</span>
<span class="type">interface</span> <span class="class">NonEmptyList</span>&lt;T&gt; <span class="directive">extends</span> NonEmptyImmutableList&lt;T&gt; {

    <span class="annotation">@Modified</span>
    <span class="type">void</span> setFirst(<span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) T t);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The method <code>setFirst</code> goes against the default annotations twice: because it is modifying, and because it promises to
keep its parameter unmodified thanks
to the  <code>@Container</code>  annotation on the type.
The  <code>@Independent(hc=true)</code>  annotation states that arguments to <code>setFirst</code> will end up in the hidden content of the <code>NonEmptyList</code>.
Implementations can even lose  <code>@FinalFields</code> :</p>
</div>
<div class="listingblock">
<div class="title">Example 35, mutable implementation of <code>NonEmptyList</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Container</span>
<span class="directive">static</span> <span class="type">class</span> <span class="class">One</span>&lt;T&gt; <span class="directive">implements</span> NonEmptyList&lt;T&gt; {

    <span class="comment">// variable</span>
    <span class="directive">private</span> T t;

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> T first() {
        <span class="keyword">return</span> t;
    }

    <span class="annotation">@Modified</span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> setFirst(T t) {
        <span class="local-variable">this</span>.t = t;
    }

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">int</span> size() {
        <span class="keyword">return</span> <span class="integer">1</span>;
    }

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> visit(Consumer&lt;T&gt; consumer) {
        consumer.accept(t);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is a (slightly more convoluted) implementation that remains  <code>@FinalFields</code>  and  <code>@Container</code> :</p>
</div>
<div class="listingblock">
<div class="title">Example 36, final fields implementation of <code>NonEmptyList</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@FinalFields</span> <span class="annotation">@Container</span>
<span class="directive">static</span> <span class="type">class</span> <span class="class">OneWithOne</span>&lt;T&gt; <span class="directive">implements</span> NonEmptyList&lt;T&gt; {
    <span class="directive">private</span> <span class="directive">final</span> One&lt;T&gt; one = <span class="keyword">new</span> One&lt;&gt;();

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> T first() {
        <span class="keyword">return</span> one.first();
    }

    <span class="annotation">@Modified</span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> setFirst(T t) {
        one.setFirst(t);
    }

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">int</span> size() {
        <span class="keyword">return</span> <span class="integer">1</span>;
    }

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> visit(Consumer&lt;T&gt; consumer) {
        consumer.accept(first());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Obviously, an  <code>@ImmutableContainer</code>  implementation is not possible: the immutability status of an extension
(<code>OneWithOne</code>, <code>One</code>) cannot be better than that of the type it is extending from (<code>NonEmptyList</code>).</p>
</div>
<div class="paragraph">
<p>We end the section by showing how concrete implementations of the <code>accept</code> method in <code>Consumer</code> can make modifications.
First, modifications to the parameter:</p>
</div>
<div class="listingblock">
<div class="title">Example 37, modification to the parameter of <code>Consumer.accept</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">One&lt;<span class="predefined-type">StringBuilder</span>&gt; one = <span class="keyword">new</span> One&lt;&gt;();
one.setFirst(<span class="keyword">new</span> <span class="predefined-type">StringBuilder</span>());
one.visit(sb -&gt; sb.append(<span class="string"><span class="delimiter">&quot;</span><span class="content">!</span><span class="delimiter">&quot;</span></span>));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The last statement is maybe more easily seen as:</p>
</div>
<div class="listingblock">
<div class="title">Example 38, modification to the parameter of <code>Consumer.accept</code>, written out</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">one.visit(<span class="keyword">new</span> Consumer&lt;<span class="predefined-type">StringBuilder</span>&gt; {

   <span class="annotation">@Override</span>
   <span class="directive">public</span> <span class="type">void</span> accept(<span class="predefined-type">StringBuilder</span> sb) {
       sb.append(<span class="string"><span class="delimiter">&quot;</span><span class="content">!</span><span class="delimiter">&quot;</span></span>);
   }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>Second, modifications to the fields of the type:</p>
</div>
<div class="listingblock">
<div class="title">Example 39, the method <code>Consumer.accept</code> modifying a field</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@FinalFields</span> <span class="annotation">@Container</span>
<span class="type">class</span> <span class="class">ReceiveStrings</span> <span class="directive">implements</span> Consumer&lt;<span class="predefined-type">String</span>&gt; {

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="directive">final</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; list = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;();

    <span class="annotation">@Modified</span>
    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> accept(<span class="predefined-type">String</span> string) {
        list.add(string);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="static-side-effects">9.5. Static side effects</h3>
<div class="paragraph">
<p>Up to now, we have made no distinction between static fields and instance fields: modifications are modifications.
Inside a primary type, we will stick to this rule.
In the following example, each call to <code>getK</code> increments a counter, which is a modifying operation because the type
owns the counter:</p>
</div>
<div class="listingblock">
<div class="title">Example 40, modifications on static fields are modifications</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@FinalFields</span> <span class="annotation">@Container</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">CountAccess</span>&lt;K&gt; {

    <span class="annotation">@NotModified</span>
    <span class="directive">private</span> <span class="directive">final</span> K k;

    <span class="annotation">@Modified</span>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">AtomicInteger</span> counter = <span class="keyword">new</span> <span class="predefined-type">AtomicInteger</span>();

    <span class="directive">public</span> CountAccess(K k) {
        <span class="local-variable">this</span>.k = k;
    }

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> K getK() {
        counter.getAndIncrement();
        <span class="keyword">return</span> k;
    }

    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">int</span> countAccessToK() {
        <span class="keyword">return</span> counter.get();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can explicitly ignore modifications with the contracted  <code>@IgnoreModifications</code>  annotation, which may make sense from a
semantic point of view:</p>
</div>
<div class="listingblock">
<div class="title">Example 41, modification on static field, explicitly ignored</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>(hc=<span class="predefined-constant">true</span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">CountAccess</span>&lt;K&gt; {

    <span class="annotation">@NotModified</span>
    <span class="directive">private</span> <span class="directive">final</span> K k;

    <span class="annotation">@IgnoreModifications</span>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">AtomicInteger</span> counter = <span class="keyword">new</span> <span class="predefined-type">AtomicInteger</span>();

    <span class="directive">public</span> CountAccess(K k) {
        <span class="local-variable">this</span>.k = k;
    }

    <span class="annotation">@NotModified</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="directive">public</span> K getK() {
        counter.getAndIncrement(); <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="keyword">return</span> k;
    }

    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="directive">static</span> <span class="type">int</span> countAccessToK() {
        <span class="keyword">return</span> counter.get();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The effects of the modifying method <code>getAndIncrement</code> are ignored.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that when the modification takes place inside the constructor, it is still not ignored, because for static fields,
static code blocks act as the constructor:</p>
</div>
<div class="listingblock">
<div class="title">Example 42, modification of static field can occur inside constructor</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@FinalFields</span> <span class="annotation">@Container</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">HasUniqueIdentifier</span>&lt;K&gt; {

    <span class="directive">public</span> <span class="directive">final</span> K k;
    <span class="directive">public</span> <span class="directive">final</span> <span class="type">int</span> identifier;

    <span class="annotation">@Modified</span>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">AtomicInteger</span> generator = <span class="keyword">new</span> <span class="predefined-type">AtomicInteger</span>();

    <span class="directive">public</span> HasUniqueIdentifier(K k) {
        <span class="local-variable">this</span>.k = k;
        identifier = generator.getAndIncrement();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Only modifications in a static code block are ignored:</p>
</div>
<div class="listingblock">
<div class="title">Example 43, static code blocks are the constructors of static fields</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">CountAccess</span>&lt;K&gt; {
    ...
    private <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">AtomicInteger</span> counter;

    <span class="directive">static</span> {
        counter = <span class="keyword">new</span> <span class="predefined-type">AtomicInteger</span>();
        counter.getAndIncrement(); <i class="conum" data-value="1"></i><b>(1)</b>
    }
    ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Modification, part of the construction process.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Nevertheless, we introduce the following rule which does distinguish between modifications on static and instance types:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>When static modifying methods are called, on a field not belonging to the primary type or any of the parent types,
or directly on a type expression which does not refer to any of the types in the primary type or parent types,
we classify the modification as a <em>static side effect</em>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>This is still consistent with the rules of immutable types, which only look at the fields and assume that when methods
do not modify the fields, they are actually non-modifying.
Without an  <code>@IgnoreModifications</code>  annotation on the field <code>System.out</code> (which we would typically add),
printing to the console results in</p>
</div>
<div class="listingblock">
<div class="title">Example 44, static side effects annotation</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@StaticSideEffects</span>
<span class="annotation">@NotModified</span>
<span class="directive">public</span> K getK() {
    <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Getting </span><span class="delimiter">&quot;</span></span>+k);
    <span class="keyword">return</span> k;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We leave it up to the programmer or designer to determine whether static calls deserve a  <code>@StaticSideEffects</code>  warning, or not.
In almost all instances, we prefer a singleton instance (see <a href="#singleton-classes">Singleton classes</a>) over a class with modifying static
methods.
In singletons the normal modification rules apply, unless  <code>@IgnoreModifications</code>  decorates the static field giving
access to the singleton.</p>
</div>
</div>
<div class="sect2">
<h3 id="value-based-classes">9.6. Value-based classes</h3>
<div class="paragraph">
<p>Quoting from the JDK 8 documentation, value-based classes are</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>final and immutable (though may contain references to mutable objects);</p>
</li>
<li>
<p>have implementations of equals, hashCode, and toString which are computed solely from the instance&#8217;s state and not
from its identity or the state of any other object or variable;</p>
</li>
<li>
<p>make no use of identity-sensitive operations such as reference equality (==) between instances, identity hash code
of instances, or synchronization on an instances&#8217;s intrinsic lock;</p>
</li>
<li>
<p>are considered equal solely based on equals(), not based on reference equality (==);</p>
</li>
<li>
<p>do not have accessible constructors, but are instead instantiated through factory methods which make no commitment
as to the identity of returned instances;</p>
</li>
<li>
<p>are freely substitutable when equal, meaning that interchanging any two instances <em>x</em> and <em>y</em> that are equal according
to <code>equals()</code> in any computation or method invocation should produce no visible change in behavior.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Item 1 requires final fields but does not specify any of the restrictions we require for immutability.
Item 2 implies that should <code>equals</code>, <code>hashCode</code> or <code>toString</code> make a modification to the object, its state changes,
which would then change the object with respect to other objects.
We could conclude that these three methods cannot be modifying.</p>
</div>
<div class="paragraph">
<p>Loosely speaking, objects of a value-based class can be identified by the values of their fields.
Immutability is not a requirement to be a value-based class.
However, we expect many immutable types will become value-classes.
Revisiting the example from the previous section, we can construct a counter-example:</p>
</div>
<div class="listingblock">
<div class="title">Example 45, immutable type which is not value-based</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>(hc=<span class="predefined-constant">true</span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">HasUniqueIdentifier</span>&lt;K&gt; {
    <span class="directive">public</span> <span class="directive">final</span> K k;
    <span class="directive">public</span> <span class="directive">final</span> <span class="type">int</span> identifier;

    <span class="annotation">@NotModified</span>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">AtomicInteger</span> generator = <span class="keyword">new</span> <span class="predefined-type">AtomicInteger</span>();

    <span class="directive">public</span> HasUniqueIdentifier(K k) {
        <span class="local-variable">this</span>.k = k;
        identifier = generator.getAndIncrement();
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">boolean</span> equals(<span class="predefined-type">Object</span> other) {
        <span class="keyword">if</span>(<span class="local-variable">this</span> == other) <span class="keyword">return</span> <span class="predefined-constant">true</span>;
        <span class="keyword">if</span>(other <span class="keyword">instanceof</span> HasUniqueIdentifier&lt;?&gt; hasUniqueIdentifier) {
            <span class="keyword">return</span> identifier == hasUniqueIdentifier.identifier;
        }
        <span class="keyword">return</span> <span class="predefined-constant">false</span>;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>equals</code> method violates item 2 of the value-class definition, maybe not to the letter but at least in its spirit:
the field <code>k</code> is arguably the most important field, and its value is not taken into account when computing equality.</p>
</div>
</div>
<div class="sect2">
<h3 id="dynamic-type-annotations">9.7. Dynamic type annotations</h3>
<div class="paragraph">
<p>When it is clear a method returns an immutable set, but the formal type is <code>java.util.Set</code>, the  <code>@Immutable</code>  annotation
can 'travel':</p>
</div>
<div class="listingblock">
<div class="title">Example 46, revisiting <code>SetBasedContainer6</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>(hc=<span class="predefined-constant">true</span>)
<span class="type">class</span> <span class="class">SetBasedContainer6</span>&lt;T&gt; {

    <span class="annotation">@ImmutableContainer</span>(hc=<span class="predefined-constant">true</span>)
    <span class="directive">public</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;T&gt; data;

    <span class="directive">public</span> SetBasedContainer4(<span class="predefined-type">Set</span>&lt;T&gt; ts) {
        <span class="local-variable">this</span>.data = <span class="predefined-type">Set</span>.copyOf(ts);
    }

    <span class="annotation">@ImmutableContainer</span>(hc=<span class="predefined-constant">true</span>)
    <span class="directive">public</span> <span class="predefined-type">Set</span>&lt;T&gt; getSet() {
        <span class="keyword">return</span> data;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Whilst <code>Set</code> in general is not  <code>@Immutable</code> , the <code>data</code> field itself is.</p>
</div>
<div class="paragraph">
<p>The computations that the analyser needs to track dynamic type annotations, are similar to those it needs to compute
eventual immutability.
We introduce them in the next chapter.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="eventual-immutability">10. Eventual immutability</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section we explore types which follow a two-phase life cycle: the start off as mutable, then somehow become
immutable.</p>
</div>
<div class="sect2">
<h3 id="_builders">10.1. Builders</h3>
<div class="paragraph">
<p>We start with the well-established <em>builder</em> paradigm.</p>
</div>
<div class="listingblock">
<div class="title">Example 47, static nested builder type</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>
<span class="type">class</span> <span class="class">Point</span> {
    <span class="directive">public</span> <span class="directive">final</span> <span class="type">double</span> x;
    <span class="directive">public</span> <span class="directive">final</span> <span class="type">double</span> y;

    <span class="directive">public</span> <span class="predefined-type">Point</span>(<span class="type">double</span> x, <span class="type">double</span> y) {
        <span class="local-variable">this</span>.x = x;
        <span class="local-variable">this</span>.y = y;
    }
}

<span class="annotation">@ImmutableContainer</span>
<span class="type">class</span> <span class="class">Polygon</span> {

    <span class="annotation">@ImmutableContainer</span>
    <span class="directive">public</span> <span class="directive">final</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">Point</span>&gt; points;

    <span class="directive">private</span> <span class="predefined-type">Polygon</span>(<span class="predefined-type">List</span>&lt;<span class="predefined-type">Point</span>&gt; points) { <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="local-variable">this</span>.points = points;
    }

    <span class="annotation">@FinalFields</span>(builds=<span class="predefined-type">Polygon</span>.class)
    <span class="directive">static</span> <span class="type">class</span> <span class="class">Builder</span> {

        <span class="annotation">@Modified</span>
        <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">Point</span>&gt; points = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;();

        <span class="annotation">@Modified</span>
        <span class="directive">public</span> <span class="type">void</span> addPoint(<span class="predefined-type">Point</span> point) {
            points.add(point);
        }

        <span class="annotation">@NotModified</span>
        <span class="directive">public</span> <span class="predefined-type">Polygon</span> build() {
            <span class="keyword">return</span> <span class="keyword">new</span> <span class="predefined-type">Polygon</span>(<span class="predefined-type">List</span>.copyOf(points));
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The private constructor combined with the construction of an immutable copy in the <code>build</code> method guarantees
immutability.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If your code can live with two different types (<code>Polygon.Builder</code>, <code>Polygon</code>) to represent polygons in their different
stages (mutable, immutable), the builder paradigm is great.
If, on the other hand, you want to hold polygons in a type that spans both stages of the polygon lifecycle, it becomes
difficult to do this with an eye on immutability.
One solution is the use of an interface that is implemented both by the builder and the immutable type.</p>
</div>
<div class="paragraph">
<p>The <a href="#support-firstthen">FirstThen</a> type can also assist in this situation: it holds an initial object (the <em>first</em>) until a
state change occurs, and it is forced to hold a second object (the <em>then</em>).
Once it is in the final state, it cannot change anymore.
It is <em>eventually immutable</em>:</p>
</div>
<div class="listingblock">
<div class="title">Example 48, use of <code>FirstThen</code> to make a type eventually immutable</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">PolygonManager</span> {
    <span class="comment">// initially, the polygon is in builder phase</span>
    <span class="directive">public</span> <span class="directive">final</span> FirstThen&lt;<span class="predefined-type">Polygon</span>.Builder, <span class="predefined-type">Polygon</span>&gt; polygon =
        <span class="keyword">new</span> FirstThen&lt;&gt;(<span class="keyword">new</span> <span class="predefined-type">Polygon</span>.Builder());

    <span class="comment">// ...</span>

    <span class="directive">public</span> <span class="type">void</span> construct() {
        <span class="comment">// in builder phase ...</span>
        polygon.getFirst().add(point);
        <span class="comment">// transition</span>
        polygon.set(polygon.getFirst().build());
        <span class="comment">// from here on, polygon is immutable!</span>
    }

    <span class="directive">public</span> <span class="predefined-type">Point</span> firstPoint() {
        <span class="keyword">return</span> polygon.get().points.get(<span class="integer">0</span>);
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_definition">10.2. Definition</h3>
<div class="paragraph">
<p>We propose a system of eventual immutability based on a single transition of state inside an object.</p>
</div>
<div class="listingblock">
<div class="title">Example 49, state change in a boolean field</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">frozen</span><span class="delimiter">&quot;</span></span>)
<span class="type">class</span> <span class="class">SimpleImmutableSet1</span>&lt;T&gt; {
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;T&gt; set = <span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;&gt;();
    <span class="directive">private</span> <span class="type">boolean</span> frozen;

    <span class="annotation">@Only</span>(before=<span class="string"><span class="delimiter">&quot;</span><span class="content">frozen</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">boolean</span> add(T t) {
        <span class="keyword">if</span>(frozen) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>();
        set.add(t);
    }

    <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">frozen</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">void</span> freeze() {
        <span class="keyword">if</span>(frozen) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>();
        frozen = <span class="predefined-constant">true</span>;
    }

    <span class="annotation">@Only</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">frozen</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> Stream&lt;T&gt; stream() {
        <span class="keyword">if</span>(!frozen) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>();
        <span class="keyword">return</span> set.stream();
    }

    <span class="annotation">@TestMark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">frozen</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">boolean</span> isFrozen() { <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="keyword">return</span> frozen;
    }

    <span class="directive">public</span> <span class="type">int</span> size() { <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="keyword">return</span> set.size();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>These methods can be called any time.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The analyser has no problem detecting the presence of preconditions, and observing that one method changes its own
precondition.
The rules, however, are sufficiently general to support arbitrary preconditions, as shown in the following variant.
This example does not require an additional field, but relies on the empty/not-empty state change:</p>
</div>
<div class="listingblock">
<div class="title">Example 50, state change going from empty to non-empty</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">set</span><span class="delimiter">&quot;</span></span>)
<span class="type">class</span> <span class="class">SimpleImmutableSet2</span>&lt;T&gt; {
    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;T&gt; set = <span class="keyword">new</span> <span class="predefined-type">HashSet</span>&lt;&gt;();

    <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">set</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">void</span> initialize(<span class="predefined-type">Set</span>&lt;T&gt; data) {
        <span class="keyword">if</span>(!set.isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>();
        <span class="keyword">if</span>(data.isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>();
        set.addAll(data);
    }

    <span class="annotation">@Only</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">set</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> Stream&lt;T&gt; stream() {
        <span class="keyword">if</span>(set.isEmpty()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>();
        <span class="keyword">return</span> set.stream();
    }

    <span class="directive">public</span> <span class="type">int</span> size() {
        <span class="keyword">return</span> set.size();
    }

    <span class="annotation">@TestMark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">set</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">boolean</span> hasBeenInitialised() {
        <span class="keyword">return</span> !set.isEmpty();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let us summarize the annotations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The  <code>@Mark</code>  annotation marks methods that change the state from <em>before</em> to <em>after</em>.</p>
</li>
<li>
<p>The  <code>@Only</code>  annotation identifies methods that, because of their precondition, can only be executed without raising
an exception before (when complemented with a <code>before="&#8230;&#8203;"</code> parameter) or after (with a <code>after="&#8230;&#8203;"</code> parameter)
the transition.</p>
</li>
<li>
<p>The analyser computes the  <code>@TestMark</code>  annotation on methods which return the state as a boolean.
There is a parameter to indicate that instead of returning <code>true</code> when the object is <em>after</em>, the method actually
returns <code>true</code> on <em>before</em>.</p>
</li>
<li>
<p>Finally, the eventuality of the type shows in the <code>after="&#8230;&#8203;"</code> parameter of  <code>@FinalFields</code> ,  <code>@Immutable</code>  or the
shorthand  <code>@ImmutableContainer</code> .</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In each of these annotations, the actual value of the <code>&#8230;&#8203;</code> in the <code>after=</code> or <code>before=</code> parameters is the name of the
field.</p>
</div>
<div class="paragraph">
<p>In case there are multiple fields involved, their names are represented in a comma-separated fashion.</p>
</div>
<div class="paragraph">
<p>The  <code>@Mark</code>  and  <code>@Only</code>  annotations can also be assigned to parameters, in the event that marked methods are called
on a parameter of eventually immutable type.
Consider the following utility method for <a href="#support-eventuallyfinal">EventuallyFinal</a>, frequently used in the analyser&#8217;s own code:</p>
</div>
<div class="listingblock">
<div class="title">Example 51, utility method for <code>EventuallyFinal</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="directive">static</span> &lt;T&gt; <span class="type">void</span> setFinalAllowEquals(
        <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">isFinal</span><span class="delimiter">&quot;</span></span>) EventuallyFinal&lt;T&gt; eventuallyFinal, T t) {
    <span class="keyword">if</span> (eventuallyFinal.isVariable() || !Objects.equals(eventuallyFinal.get(), t)) {
        eventuallyFinal.setFinal(t);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the <code>setFinal</code> method&#8217;s  <code>@Mark</code>  annotation travels to the parameter, where it is applied to the argument each
time the static method is applied.</p>
</div>
</div>
<div class="sect2">
<h3 id="_propagation">10.3. Propagation</h3>
<div class="paragraph">
<p>The support types detailed in <a href="#support-classes">Support classes</a> can be used as building blocks to make ever more complex eventually
immutable classes.
Effectively final fields of eventually immutable type will at some point hold objects that are in their final or <code>after</code>
state, in which case they act as immutable fields.</p>
</div>
<div class="paragraph">
<p>The analyser itself consists of many eventually immutable classes; we show some examples in <a href="#in-the-analyser">Support classes in the analyser</a>.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
For everyday use of eventual immutability, this is probably the most important consequence of all definitions
up to now.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_before_the_mark">10.4. Before the mark</h3>
<div class="paragraph">
<p>A method can return an eventually immutable object, guaranteed to be in its initial or <code>before</code> state.
This can be annotated with  <code>@BeforeMark</code> .
Employing <code>SimpleImmutableSet1</code> from the example above,</p>
</div>
<div class="listingblock">
<div class="title">Example 52, <code>@BeforeMark</code> annotation</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@BeforeMark</span>
<span class="directive">public</span> SimpleImmutableSet1 create() {
    <span class="keyword">return</span> <span class="keyword">new</span> SimpleImmutableSet1();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Similarly, the analyser can compute a parameter to be  <code>@BeforeMark</code> , when in the method, at least one before-mark
methods is called on the parameter.</p>
</div>
<div class="paragraph">
<p>Finally, a field can even be  <code>@BeforeMark</code> , when it is created or arrives in the type as  <code>@BeforeMark</code> , and stays in
this state.
This situation must occur in a type with a  <code>@Finalizer</code> , as explained in <a href="#finalizers">Finalizers</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_extensions_of_annotations">10.5. Extensions of annotations</h3>
<div class="paragraph">
<p>When a type is eventually  <code>@FinalFields</code> , should the field(s) of the state transition be marked  <code>@Final</code> ?
Similarly, when a type is eventually immutable, should the analyser mark the initially mutable or assignable fields
 <code>@Modified</code>  or  <code>@NotModified</code>?</p>
</div>
<div class="paragraph">
<p>Basically, we propose to mark the end state, qualifying with the parameter <code>after</code>:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">property</th>
<th class="tableblock halign-left valign-top">not present</th>
<th class="tableblock halign-left valign-top">eventually</th>
<th class="tableblock halign-left valign-top">effectively</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">finality of field</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">no annotation, or <code>@Final(absent=true)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@Final(after="mark")</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"> <code>@Final</code> </p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">non-modification of field</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"> <code>@Modified</code> </p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>@NotModified(after="mark")</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"> <code>@NotModified</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Since in an IDE it is not too easy to have multiple visual markers, it seems best to use the same visuals as the end
state.</p>
</div>
<div class="paragraph">
<p>When a type is effectively  <code>@FinalFields</code>  (not eventually), all fields are effectively final.
The analyser wants to emphasise the rules needed to obtain (eventual) immutability, by clearly indicating which fields
break the immutability rules.</p>
</div>
<div class="paragraph">
<p>Eventual finality simply adds a <code>@Final(after="mark")</code> annotation to each of these situations.</p>
</div>
</div>
<div class="sect2">
<h3 id="_frameworks_and_contracts">10.6. Frameworks and contracts</h3>
<div class="paragraph">
<p>A fair number of Java frameworks introduce dependency injection and initializer methods.
This concept is, in many cases, compatible with the idea of eventual immutability: once dependency injection has taken
place, and an initializing method has been called, the framework stops intervening in the value of the fields.</p>
</div>
<div class="paragraph">
<p>It is therefore not difficult to imagine, and implement in the analyser, a <em>before</em> state (initialization still ongoing)
and an <em>after</em> state (initialization done) associated with the particular framework.
The example below shows how this could be done for the <code>Verticle</code> interface of the <a href="https://vertx.io" target="_blank" rel="noopener">vertx.io framework</a>.</p>
</div>
<div class="listingblock">
<div class="title">Example 53, excerpts and annotations of <code>Verticle.java</code> and <code>AbstractVerticle.java</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@FinalFields</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">init</span><span class="delimiter">&quot;</span></span>)
<span class="type">interface</span> <span class="class">Verticle</span> {

    <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">init</span><span class="delimiter">&quot;</span></span>)
    <span class="type">void</span> init(Vertx vertx, <span class="predefined-type">Context</span> context);

    <span class="annotation">@Only</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">init</span><span class="delimiter">&quot;</span></span>)
    Vertx getVertx();

    <span class="annotation">@Only</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">init</span><span class="delimiter">&quot;</span></span>)
    <span class="type">void</span> start(Promise&lt;<span class="predefined-type">Void</span>&gt; startPromise) <span class="directive">throws</span> <span class="exception">Exception</span>;

    <span class="annotation">@Only</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">init</span><span class="delimiter">&quot;</span></span>)
    <span class="type">void</span> stop(Promise&lt;<span class="predefined-type">Void</span>&gt; startPromise) <span class="directive">throws</span> <span class="exception">Exception</span>;
}

<span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">AbstractVerticle</span> <span class="directive">implements</span> Verticle {
    <span class="annotation">@Final</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">init</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">protected</span> Vertx vertx;

    <span class="annotation">@Final</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">init</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">protected</span> <span class="predefined-type">Context</span> context;

    <span class="annotation">@Override</span>
    <span class="directive">public</span> Vertx getVertx() {
        <span class="keyword">return</span> vertx;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> init(Vertx vertx, <span class="predefined-type">Context</span> context) {
        <span class="local-variable">this</span>.vertx = vertx;
        <span class="local-variable">this</span>.context = context;
    }
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Currently, contracted eventual immutability has not been implemented yet in the analyser.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="modification-part2">11. Modification, part 2</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This section goes deeper into modification, linking and independence.
We start with cyclic references.</p>
</div>
<div class="sect2">
<h3 id="_cyclic_references">11.1. Cyclic references</h3>
<div class="paragraph">
<p>We need to study the situation of seemingly non-modifying methods with modifying parameters.
Up to now, a method is only modifying when it assigns to a field, calls a modifying method on one of the fields, or
directly calls a modifying method on <code>this</code>.
However, there could be indirect modifications, as in:</p>
</div>
<div class="listingblock">
<div class="title">Example 54, indirect modifications</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">CyclicReferences</span> {

    <span class="comment">// not @FinalFields, not @Container</span>
    <span class="directive">static</span> <span class="type">class</span> <span class="class">C1</span> {

        <span class="comment">// variable</span>
        <span class="directive">private</span> <span class="type">int</span> i;

        <span class="annotation">@Modified</span>
        <span class="directive">public</span> <span class="type">int</span> incrementAndGet() {
            <span class="keyword">return</span> ++i;
        }

        <span class="annotation">@Modified</span> <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="directive">public</span> <span class="type">int</span> useC2(<span class="annotation">@Modified</span> C2 c2) {
            <span class="keyword">return</span> i + c2.incrementAndGetWithI();
        }

    }

    <span class="annotation">@FinalFields</span> <span class="comment">// not @Container</span>
    <span class="directive">static</span> <span class="type">class</span> <span class="class">C2</span> {

        <span class="directive">private</span> <span class="directive">final</span> <span class="type">int</span> j;

        <span class="annotation">@Modified</span>
        <span class="directive">private</span> <span class="directive">final</span> C1 c1;

        <span class="directive">public</span> C2(<span class="type">int</span> j, <span class="annotation">@Modified</span> C1 c1) {
            <span class="local-variable">this</span>.c1 = c1;
            <span class="local-variable">this</span>.j = j;
        }

        <span class="annotation">@Modified</span>
        <span class="directive">public</span> <span class="type">int</span> incrementAndGetWithI() {
            <span class="keyword">return</span> c1.incrementAndGet() + j;
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>useC2</code> does not directly modify <code>i</code>, but <code>incrementAndGetWithI</code> does so indirectly.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This observation forces us to tighten the definition of a non-modifying method: on top of the definition given above,
we have to ensure that none of the modifying methods called on a parameter which is  <code>@Modified</code> , call one of 'our'
modifying methods.
These rules are mostly, but not easily, enforceable when all code is visible.</p>
</div>
<div class="paragraph">
<p>An additional interface can help to remove the circular dependency between the types.
This has the advantage of simplicity, both for the programmer and the analyser, which at this point doesn&#8217;t handle
circular dependencies very well.
It imposes more annotation work on the programmer, however, because the interface&#8217;s methods need contracts.</p>
</div>
</div>
<div class="sect2">
<h3 id="computing-dependence">11.2. How to compute linking</h3>
<div class="paragraph">
<p>To compute linking, the analyser tries to track actual objects, with the aim of knowing if a field links to
another field or a parameter.
It computes a dependency graph of variables depending on other variables, with the following four basic rules:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Rule 1: in an assignment <code>v = w</code>, variable <code>v</code> links to variable <code>w</code>.</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Rule 2: in an assignment <code>v = a.method(b)</code>,<code>v</code> potentially links to <code>a</code> and <code>b</code>.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Note that saying <code>v</code> links to <code>a</code> is the same as saying that the return value of <code>method</code> links to some field
inside <code>A</code>, the type of <code>a</code>.
This is especially clear when <code>a == this</code>.</p>
</div>
<div class="paragraph">
<p>We discern a number of special cases:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>When <code>v</code> is of  <code>@Immutable</code>  type, there cannot be any linking; <code>v</code> does not link to <code>a</code> nor <code>b</code>.</p>
</li>
<li>
<p>If <code>b</code> is of  <code>@Immutable</code>  type, <code>v</code> cannot link to <code>b</code>.</p>
</li>
<li>
<p>When <code>method</code> has the annotation  <code>@Independent</code>  (allowing for hidden content, or not), <code>v</code> cannot link to <code>a</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Recall that primitives, <code>java.lang.Object</code>, <code>java.lang.String</code>, and unbound parameter types, are  <code>@Immutable</code> .</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Rule 3: in an assignment <code>v = new A(b)</code>, <code>v</code> potentially links to <code>b</code>.</p>
</div>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>When <code>b</code> is of  <code>@Immutable</code>  type, <code>v</code> cannot link to <code>b</code>.</p>
</li>
<li>
<p>If <code>A</code> is  <code>@Immutable</code> , then <code>v</code> cannot link to <code>b</code>, because all its constructor parameters are independent.</p>
</li>
<li>
<p>When <code>b</code> has been marked  <code>@Independent</code> , <code>v</code> cannot link to <code>b</code>.</p>
</li>
</ol>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Rule 4: in a modifying method call <code>a.method(b)</code>, <code>a</code> potentially links to <code>b</code></p>
</div>
</div>
</div>
<div class="paragraph">
<p>This situation is similar to that of the constructor (rule 3), with <code>a</code> taking the role of <code>v</code>.</p>
</div>
<div class="paragraph">
<p>Most of the other linking computations are consequences of the basic rules above.
For example,</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>in an assignment <code>v = condition ? a : b</code>, <code>v</code> links to both <code>a</code> and <code>b</code>.</p>
</li>
<li>
<p>type casting does not prevent linking: in <code>v = (Type)w</code>, <code>v</code> links to <code>w</code></p>
</li>
<li>
<p>a pattern variable <code>p</code> in an instance-of statement <code>a instanceof P p</code> links to <code>a</code></p>
</li>
<li>
<p>Binary operators return primitives or <code>java.lang.String</code>, which prevents linking: in <code>v = a + b</code>, <code>v</code> does not
link to <code>a</code> nor <code>b</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Note: in a method call <code>v = a.method(b, c, d)</code>, links between <code>b</code>, <code>c</code>, and <code>d</code> are possible.
They are covered by the  <code>@Modified</code>  annotation:
when a parameter is  <code>@NotModified</code>, no modifications at all are possible, not even indirectly.
We do not compute individual linking, because we advocate the use of containers: all parameters should be  <code>@NotModified</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_locally_implemented_abstract_methods">11.3. Locally implemented abstract methods</h3>
<div class="paragraph">
<p>Abstract methods are present in interfaces, and abstract classes.
Their very definition is that no implementation is present at the place of definition: only the ins (parameters)
and outs (return type) are pre-defined.</p>
</div>
<div class="paragraph">
<p>Functional interfaces are interfaces with a single abstract method; any other methods in the interface are
required to have a <code>default</code> implementation.
The following table lists some frequently used ones:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">single abstract method (SAM)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Consumer&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>void accept(T t);</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Function&lt;T,R&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>R apply(T t);</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>BiFunction&lt;T, U, R&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>R apply(T t, U u);</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Supplier&lt;R&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>R get();</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>Predicate&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>boolean test(T t);</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>It is important not to forget that <em>any</em> interface defining a single abstract method can be seen as a functional
interface.
While the examples above all employ generics (more specifically, unbound type parameters), generics are not a
requirement for functional interfaces.
The Java language offers syntactic sugar for functional programming, but the types remain normal Java types.</p>
</div>
<div class="paragraph">
<p>We will not make any distinction between a functional interface and an abstract type.
If one were forced to make one, the <em>intention to hold data</em> would be the dividing line between a functional interface,
which conveys no such intention, and an abstract type, which does.</p>
</div>
<div class="paragraph">
<p>In this section we want to discuss a limited application of functional interfaces: the one where the SAMs have a
local implementation.
The general case, where objects of abstract types come in via a parameter, will be addressed in <a href="#hidden-content">More on hidden content</a>.
Consider the following example:</p>
</div>
<div class="listingblock">
<div class="title">Example 55, concrete implementation of suppliers</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@FinalFields</span> <span class="annotation">@Container</span>
<span class="type">class</span> <span class="class">ApplyLocalFunctions</span> {

    <span class="annotation">@Container</span>
    <span class="directive">static</span> <span class="type">class</span> <span class="class">Counter</span> {
        <span class="directive">private</span> <span class="type">int</span> counter;

        <span class="annotation">@Modified</span>
        <span class="directive">public</span> <span class="type">int</span> increment() {
            <span class="keyword">return</span> ++counter;
        }
    }

    <span class="annotation">@Modified</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="directive">private</span> <span class="directive">final</span> Counter myCounter = <span class="keyword">new</span> Counter();

    <span class="annotation">@Modified</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="directive">private</span> <span class="directive">final</span> Supplier&lt;<span class="predefined-type">Integer</span>&gt; getAndIncrement = myCounter::increment;

    <span class="annotation">@Modified</span>
    <span class="directive">private</span> <span class="directive">final</span> Supplier&lt;<span class="predefined-type">Integer</span>&gt; explicitGetAndIncrement = <span class="keyword">new</span> Supplier&lt;<span class="predefined-type">Integer</span>&gt;() {
        <span class="annotation">@Override</span> <span class="annotation">@Modified</span>
        <span class="directive">public</span> <span class="predefined-type">Integer</span> get() {
            <span class="keyword">return</span> myCounter.increment();
        }
    };

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">int</span> myIncrementer() {
        <span class="keyword">return</span> getAndIncrement.get();
    }

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">int</span> myExplicitIncrementer() {
        <span class="keyword">return</span> explicitGetAndIncrement.get();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Modified in <code>getAndIncrement</code> and <code>explicitGetAndIncrement</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td> <code>@Modified</code>  because its modifying method <code>get</code> is called in <code>myIncrementer</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The fields <code>getAndIncrement</code> and <code>explicitGetAndIncrement</code> hold instances of anonymous <em>inner classes</em> of
<code>ApplyLocalFunctions</code>: these inner classes hold data, they have access to the <code>myCounter</code> field.
Their concrete implementations of <code>get</code> each modify <code>myCounter</code>.
A straightforward application of the rules of modification of fields makes  <code>getAndIncrement</code> and
<code>explicitGetAndIncrement</code>  <code>@Modified</code> :
in <code>myIncrementer</code>, a modifying method is applied to <code>getAndIncrement</code>, and in <code>myExplicitIncrementer</code>,
a modifying method is applied to <code>explicitGetAndIncrement</code>.</p>
</div>
<div class="paragraph">
<p>Given that <code>ApplyLocalFunctions</code> is clearly  <code>@FinalFields</code> , and the inner classes hold no other data,
the inner classes are  <code>@FinalFields</code>  as well.</p>
</div>
<div class="paragraph">
<p>Now, if we move away from suppliers, but use consumers, we can discuss:</p>
</div>
<div class="listingblock">
<div class="title">Example 56, concrete implementation of consumers</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">ApplyLocalFunctions2</span> {

    <span class="annotation">@Container</span>
    <span class="directive">static</span> <span class="type">class</span> <span class="class">Counter</span> {
        <span class="directive">private</span> <span class="type">int</span> counter;

        <span class="annotation">@NotModified</span>
        <span class="directive">public</span> <span class="type">int</span> getCounter() {
            <span class="keyword">return</span> counter;
        }

        <span class="annotation">@Modified</span>
        <span class="directive">public</span> <span class="type">int</span> increment() {
            <span class="keyword">return</span> ++counter;
        }
    }

    <span class="annotation">@NotModified</span>
    <span class="directive">private</span> <span class="directive">final</span> Counter myCounter = <span class="keyword">new</span> Counter();

    <span class="annotation">@Immutable</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> Consumer&lt;Counter&gt; incrementer = Counter::increment;

    <span class="annotation">@Immutable</span>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> Consumer&lt;Counter&gt; explicitIncrementer = <span class="keyword">new</span> Consumer&lt;Counter&gt;() {
        <span class="annotation">@Override</span>
        <span class="annotation">@NotModified</span>
        <span class="directive">public</span> <span class="type">void</span> accept(<span class="annotation">@Modified</span> Counter counter) { <i class="conum" data-value="2"></i><b>(2)</b>
            counter.increment();
        }
    };

    <span class="annotation">@ImmutableContainer</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> Consumer&lt;Counter&gt; printer = counter -&gt;
        <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Have </span><span class="delimiter">&quot;</span></span> + counter.getCounter());

    <span class="annotation">@ImmutableContainer</span>
    <span class="directive">private</span> <span class="directive">static</span> <span class="directive">final</span> Consumer&lt;Counter&gt; explicitPrinter = <span class="keyword">new</span> Consumer&lt;Counter&gt;() {
        <span class="annotation">@Override</span>
        <span class="annotation">@NotModified</span>
        <span class="directive">public</span> <span class="type">void</span> accept(<span class="annotation">@NotModified</span> Counter counter) { <i class="conum" data-value="4"></i><b>(4)</b>
            <span class="predefined-type">System</span>.out.println(<span class="string"><span class="delimiter">&quot;</span><span class="content">Have </span><span class="delimiter">&quot;</span></span> + counter.getCounter());
        }
    };

    <span class="directive">private</span> <span class="type">void</span> apply(<span class="annotation">@Container</span>(contract = <span class="predefined-constant">true</span>) Consumer&lt;Counter&gt; consumer) { <i class="conum" data-value="5"></i><b>(5)</b>
        consumer.accept(myCounter);
    }

    <span class="directive">public</span> <span class="type">void</span> useApply() {
        apply(printer); <span class="comment">// should be fine</span>
        apply(explicitPrinter);
        apply(incrementer); <span class="comment">// should cause an ERROR </span><i class="conum" data-value="6"></i><b>(6)</b>
        apply(explicitIncrementer); <span class="comment">// should cause an ERROR</span>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The anonymous type is static, has no fields, so is  <code>@Immutable</code> .
It is not a container.
This is clearly visible in the explicit variant&#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Here we see why <code>incrementer</code> is not a container: the method modifies its parameters.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Now, we have a container, because in the anonymous type does not modify its parameters.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Explicitly visible here in <code>explicitPrinter</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>If we insist that all parameters are containers, &#8230;&#8203;</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>We can use the annotations to detect errors.
Here, <code>incrementer</code> is not a container.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Using the  <code>@Container</code>  annotation in a dynamic way allows us to control which abstract types can use the method:
when only containers are allowed, then the abstract types must not have implementations which change their parameters.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="hidden-content">12. More on hidden content</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section, we consider modifications to the hidden content of a type, and explain when they are of importance.</p>
</div>
<div class="sect2">
<h3 id="_visitors">12.1. Visitors</h3>
<div class="paragraph">
<p>Let&#8217;s go back to <code>NonEmptyImmutableList</code>, first defined in <a href="#abstract-methods">Abstract methods</a>:</p>
</div>
<div class="listingblock">
<div class="title">Example 57, revisiting <code>NonEmptyImmutableList</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>
<span class="type">interface</span> <span class="class">NonEmptyImmutableList</span>&lt;T&gt; <span class="directive">extends</span> HasSize {

    <span class="comment">// implicitly present: @NotModified</span>
    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>)
    T first();

    <span class="comment">// implicitly present: @NotModified</span>
    <span class="type">void</span> visit(<span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) Consumer&lt;T&gt; consumer); <span class="comment">// implicitly present: @NotModified</span>

    <span class="annotation">@NotModified</span>
    <span class="annotation">@Override</span>
    <span class="keyword">default</span> <span class="type">boolean</span> isEmpty() {
        <span class="keyword">return</span> <span class="predefined-constant">false</span>;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We start the discussion with the following immutable implementation of this interface:</p>
</div>
<div class="listingblock">
<div class="title">Example 58, immutable implementation of <code>NonEmptyImmutableList</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>
<span class="type">class</span> <span class="class">ImmutableOne</span>&lt;T&gt; <span class="directive">implements</span> NonEmptyImmutableList&lt;T&gt; {
    <span class="directive">private</span> <span class="directive">final</span> T t;

    <span class="directive">public</span> ImmutableOne(<span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) T t) {
        <span class="local-variable">this</span>.t = t;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">int</span> size() {
        <span class="keyword">return</span> <span class="integer">1</span>;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> T first() {
        <span class="keyword">return</span> t;
    }

    <span class="annotation">@Override</span>
    <span class="directive">public</span> <span class="type">void</span> visit(Consumer&lt;T&gt; consumer) {
        consumer.accept(t);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>According to the interface contract, we need the <code>visit</code> method to be non-modifying,
and also not to modify its parameter <code>consumer</code>.
However, following the normal definitions of modification, the following two statements hold:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Because <code>accept</code> is  <code>@Modified</code> , we should mark the parameter <code>consumer</code> as  <code>@Modified</code> .</p>
</li>
<li>
<p>Because <code>t</code>, the parameter of <code>accept</code>, is  <code>@Modified</code> , we should mark <code>visit</code> as  <code>@Modified</code> .</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The result of the first statement would violate the <code>@Container</code> property on <code>ImmutableOne</code>, and we&#8217;d be very
reluctant to do that:
according to the intuitive definition in <a href="#containers">Containers</a>, <code>ImmutableOne</code> is a type that holds data, but does not
change the data it has been given.
This statement still holds in the presence of a <code>visit</code> method, which is nothing but a way of exposing the object
in a way similar to the method <code>first</code>.
The second statement would make <code>visit</code> modifying, which again goes against our intuition:
looping over elements is, in itself, not modifying.</p>
</div>
<div class="paragraph">
<p>Luckily, there are two observations that come to the rescue.</p>
</div>
<div class="paragraph">
<p>First, we believe it is correct to assume that concrete implementations of <code>Consumer</code> are semantically
unrelated to <code>ImmutableOne</code>.
As a consequence, we could say that the only modifications that concern us in this <code>visit</code> method, are the
potential modifications to <code>accept</code> 's parameter <code>t</code>.
Other modifications, for example those to the fields of the type in which the implementation is present,
may be considered to be outside our scope.</p>
</div>
<div class="paragraph">
<p>However, if we replace <code>Consumer</code> by <code>Set</code> and <code>accept</code> by <code>add</code>, we encounter a modification that we really do not
want to ignore, in an otherwise equal setting.
Therefore, it does not look like we can reason away potential modifications by <code>accept</code>.
We will have to revert to a contracted  <code>@IgnoreModifications</code>  annotation on the parameter <code>consumer</code>,
if we want to avoid <code>ImmutableOne</code> losing the <code>@Container</code> property.</p>
</div>
<div class="paragraph">
<p>While we will ignore this second source of modification in the <code>ImmutableOne</code> type,
we will <em>defer</em> or <em>propagate</em> it to the place where a concrete implementation of the consumer is presented.
We can ignore it here, because <code>t</code> is part of the hidden content of the type; what happens to
its content happens outside the zone of control of <code>ImmutableOne</code>.
The fact that it is passed as an argument to a method of <code>consumer</code> is reflected by the  <code>@Independent</code>  annotation.
It will take care of the propagation of modifications from the concrete implementation into the hidden content.</p>
</div>
<div class="paragraph">
<p>This results in the following annotations for <code>visit</code> in <code>ImmutableOne</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example 59, the <code>visit</code> method in <code>ImmutableOne</code>, fully annotated</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@NotModified</span>
<span class="directive">public</span> <span class="type">void</span> visit(<span class="annotation">@IgnoreModifications</span> <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) Consumer&lt;T&gt; consumer) {
    consumer.accept(t);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that we assume that we will need  <code>@IgnoreModifications</code>  for almost every use of a functional interface
from the package <code>java.util.function</code> occurring as a parameter.
These types are for generic use; one should never use them to represent some specific data type where modifications
are of concern to the current type.
Therefore, we make this annotation implicit in exactly this context.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
A parameter of a formal functional interface type of <code>java.util.function</code>
 will be marked  <code>@IgnoreModifications</code>  implicitly.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Looking at the more general case of a <code>forEach</code> implementation iterating over a list or array, we therefore end up with:</p>
</div>
<div class="listingblock">
<div class="title">Example 60, a generic <code>forEach</code> implementation</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@NotModified</span>
<span class="directive">public</span> <span class="type">void</span> forEach(<span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) Consumer&lt;T&gt; consumer) {
    <span class="keyword">for</span>(T t: list) consumer.accept(t);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Modifications to the parameter, made by the concrete implementation, are propagated into the hidden content of <code>list</code>,
as shown in the next section.
The  <code>@Independent</code>  annotation appears because hidden content in <code>list</code> is exposed to the <code>consumer</code> parameter.
This annotation does not appear for the accessible content of the immutable type.</p>
</div>
<div class="paragraph">
<p>Recall that parameters of modifiable type can already be shielded from external modification by
the  <code>@Independent</code>  annotation.</p>
</div>
</div>
<div class="sect2">
<h3 id="_propagating_modifications">12.2. Propagating modifications</h3>
<div class="paragraph">
<p>Let us apply the <code>visit</code> method of <code>NonEmptyImmutableList</code> to <code>StringBuilder</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example 61, propagating the modification of <code>visit</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">static</span> <span class="type">void</span> print(<span class="annotation">@NotModified</span> NonEmptyImmutableList&lt;<span class="predefined-type">StringBuilder</span>&gt; list) {
    one.visit(<span class="predefined-type">System</span>.out::println); <i class="conum" data-value="1"></i><b>(1)</b>
}

<span class="directive">static</span> <span class="type">void</span> addNewLine(<span class="annotation">@Modified</span> NonEmptyImmutableList&lt;<span class="predefined-type">StringBuilder</span>&gt; list) {
    one.visit(sb -&gt; sb.append(<span class="string"><span class="delimiter">&quot;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>)); <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Non-modifying method implies no modification on the hidden content of <code>list</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Parameter-modifying lambda propagates a modification to <code>list</code> 's hidden content.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is the second method, <code>addNewLine</code>, that is of importance here.
Thanks to the  <code>@Modified</code>  annotation, we know of a modification to <code>list</code>.
It may help to see the for-loop written out, if we temporarily assume that we have added an implementation of
<code>Iterable</code> to <code>NonEmptyImmutableList</code>, functionally identical to <code>visit</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example 62, alternative implementation of <code>addNewLine</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">static</span> <span class="type">void</span> addNewLine(<span class="annotation">@Modified</span> NonEmptyImmutableList&lt;<span class="predefined-type">StringBuilder</span>&gt; list) {
    <span class="keyword">for</span>(<span class="predefined-type">StringBuilder</span> sb: list) {
        sb.append(<span class="string"><span class="delimiter">&quot;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>));
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that while <code>NonEmptyImmutableList</code> is immutable, its concrete instantiation gives access to a modifying method
in its hidden content.</p>
</div>
<div class="paragraph">
<p>We really need the link between <code>sb</code> and <code>list</code> for the modification on <code>sb</code> to propagate to <code>list</code>.
Without this propagation, we would not be able to implement the full definition of modification of parameters,
as stipulated in <a href="#modification">Modification</a>, in this relatively straightforward and probably frequently occurring situation.</p>
</div>
<div class="paragraph">
<p>Moving from <code>NonEmptyImmutableList</code> to <code>NonEmptyList</code>, defined <a href="#NonEmptyList">here</a>, which has a modifying method,
 allows us to contrast two different modifications:</p>
</div>
<div class="listingblock">
<div class="title">Example 63, contrasting the modification on the parameter <code>sb</code> to that on <code>list</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">static</span> <span class="type">void</span> addNewLine(<span class="annotation">@Modified</span> NonEmptyList&lt;<span class="predefined-type">StringBuilder</span>&gt; list) {
    list.visit(sb -&gt; sb.append(<span class="string"><span class="delimiter">&quot;</span><span class="char">\n</span><span class="delimiter">&quot;</span></span>)); <i class="conum" data-value="1"></i><b>(1)</b>
}

<span class="directive">static</span> <span class="type">void</span> replace(<span class="annotation">@Modified</span> NonEmptyList&lt;<span class="predefined-type">StringBuilder</span>&gt; list) {
    list.setFirst(<span class="keyword">new</span> <span class="predefined-type">StringBuilder</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">?</span><span class="delimiter">&quot;</span></span>)); <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Modification to the hidden content of <code>list</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Modification to the modifiable content of <code>list</code></td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Without storing additional information (e.g., using an as yet undefined parameter like <code>@Modified(hc=true)</code> on <code>list</code>
in <code>addNewLine</code>), however, we cannot make the distinction between a modification to the string builders
inside <code>list</code>, or a modification to <code>list</code> itself.
In other words, applying the two methods further on, we cannot compute</p>
</div>
<div class="listingblock">
<div class="title">Example 64, using <code>print</code> and <code>addNewLine</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">static</span> <span class="predefined-type">String</span> useAddNewLine(<span class="annotation">@NotModified</span> <span class="predefined-type">StringBuilder</span> input) { <i class="conum" data-value="1"></i><b>(1)</b>
    NonEmptyList&lt;<span class="predefined-type">StringBuilder</span>&gt; list = <span class="keyword">new</span> One&lt;&gt;();
    list.setFirst(input);
    addNewLine(list);
    <span class="keyword">return</span> list.getFirst().toString();
}

<span class="directive">static</span> <span class="predefined-type">String</span> useReplace(<span class="annotation">@NotModified</span> <span class="predefined-type">StringBuilder</span> input) {
    NonEmptyList&lt;<span class="predefined-type">StringBuilder</span>&gt; list = <span class="keyword">new</span> One&lt;&gt;();
    list.setFirst(input);
    replace(list); <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="keyword">return</span> list.getFirst().toString();
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Should be  <code>@Modified</code> , however, in the 3rd statement we cannot know that the modification is to <code>input</code> rather than to <code>list</code></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This action discards <code>input</code> from <code>list</code> without modifying it.</td>
</tr>
</table>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>The example shows that the introduction of  <code>@Independent</code>  only gets us so far: from the concrete, modifying implementation, to the parameter (or field).
We do not plan to keep track of the distinction between modification of hidden content vs modification of modifiable content to a further extent.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Finally, we mention again the modification to a field from a concrete lambda:</p>
</div>
<div class="listingblock">
<div class="title">Example 65, modification of a field outside the scope</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; strings = ...
<span class="annotation">@Modified</span>
<span class="type">void</span> addToStrings(<span class="annotation">@NotModified</span> NonEmptyList&lt;<span class="predefined-type">StringBuilder</span>&gt; list) {
  list.visit(sb -&gt; strings.add(sb.toString()));
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="content-linking">12.3. Content linking</h3>
<div class="paragraph">
<p>Going back to <code>ImmutableOne</code>, we see that the constructor links the parameter <code>t</code> to the instance&#8217;s field by
means of assignment.
Let us call this binding of parameters of hidden content to the field <em>content linking</em>,
and mark it using  <code>@Independent(hc=true)</code> , <em>content dependence</em>:</p>
</div>
<div class="listingblock">
<div class="title">Example 66, constructor of <code>ImmutableOne</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">private</span> <span class="directive">final</span> T t;

<span class="directive">public</span> ImmutableOne(<span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) T t) {
    <span class="local-variable">this</span>.t = t;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Returning a part of the hidden content of the type, or exposing it as argument, both warrants a  <code>@Independent(hc=true)</code> 
annotation:</p>
</div>
<div class="listingblock">
<div class="title">Example 67, more methods of <code>ImmutableOne</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>)
<span class="annotation">@Override</span>
<span class="directive">public</span> T first() {
    <span class="keyword">return</span> t;
}

<span class="annotation">@Override</span>
<span class="directive">public</span> <span class="type">void</span> visit(<span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) Consumer&lt;T&gt; consumer) {
    consumer.accept(t);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Observe that content dependence implies absence of dependence, as described in <a href="#linking-and-independence">Linking, dependence</a>
and <a href="#computing-dependence">How to compute linking</a>, exactly because we are dealing with type parameters of an immutable type.</p>
</div>
<div class="paragraph">
<p>Another place where the hidden content linking can be seen, is the <em>for-each</em> statement:</p>
</div>
<div class="listingblock">
<div class="title">Example 68, for-each loop and hidden content linking</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">ImmutableList&lt;<span class="predefined-type">StringBuilder</span>&gt; list = ...;
<span class="predefined-type">List</span>&lt;<span class="predefined-type">StringBuilder</span>&gt; builders = ...;
<span class="keyword">for</span>(<span class="predefined-type">StringBuilder</span> sb: list) {
    builders.add(sb);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Because the <code>Collection</code> API contains an <code>add</code> method annotated as:</p>
</div>
<div class="listingblock">
<div class="title">Example 69, <code>add</code> in <code>Collection</code> annotated</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Modified</span>
<span class="type">boolean</span> add(<span class="annotation">@NotNull</span> <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) E e);</code></pre>
</div>
</div>
<div class="paragraph">
<p>indicating that after calling <code>add</code>, the argument will become part of the hidden content of the collection,
we conclude that the local loop variable <code>sb</code> gets content linked to the <code>builders</code> list.
Similarly, this loop variable contains hidden content from the <code>list</code> object.</p>
</div>
<div class="paragraph">
<p>Let us look at a possible implementation of <code>Collection.addAll</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example 70, a possible implementation of <code>addAll</code> in <code>Collection</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Modified</span>
<span class="type">boolean</span> addAll(<span class="annotation">@NotNull</span>(content=<span class="predefined-constant">true</span>) <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) <span class="predefined-type">Collection</span>&lt;? <span class="directive">extends</span> E&gt; collection) {
    <span class="type">boolean</span> modified = <span class="predefined-constant">false</span>;
    <span class="keyword">for</span> (E e : c) <span class="keyword">if</span> (add(e)) modified = <span class="predefined-constant">true</span>;
    <span class="keyword">return</span> modified;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The call to <code>add</code> content links <code>e</code> to <code>this</code>.
Because <code>e</code> is also content linked to <code>c</code>, the parameter <code>collection</code> holds content linked to the hidden content of
the instance.</p>
</div>
<div class="paragraph">
<p>We are now properly armed to see how a for-each loop can be implemented using an iterator whose hidden content
links to that of a container.</p>
</div>
</div>
<div class="sect2">
<h3 id="_iterator_iterable_loops">12.4. Iterator, Iterable, loops</h3>
<div class="paragraph">
<p>Let us start with the simplest definition of an iterator, without <code>remove</code> method:</p>
</div>
<div class="listingblock">
<div class="title">Example 71, the <code>Iterator</code> type, without <code>remove</code> method</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Container</span>
<span class="type">interface</span> <span class="class">Iterator</span>&lt;T&gt; {

    <span class="annotation">@Modified</span>
    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>)
    T next();

    <span class="annotation">@Modified</span>
    <span class="type">boolean</span> hasNext();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Either the <code>next</code> method, or the <code>hasNext</code> method, must make a change to the iterator, because it has to keep track
of the next element.
As such, we make both  <code>@Modified</code> .
Following the discussion in the previous section, <code>next</code> is  <code>@Independent(hc=true)</code> , because it returns part of the hidden
content held by the iterator.</p>
</div>
<div class="paragraph">
<p>The interface <code>Iterable</code> is a supplier of iterators:</p>
</div>
<div class="listingblock">
<div class="title">Example 72, the <code>Iterable</code> type</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>
<span class="type">interface</span> <span class="class">Iterable</span>&lt;T&gt; {

    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>)
    <span class="predefined-type">Iterator</span>&lt;T&gt; iterator();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>First, creating an iterator should never be a modifying operation on a type.
Typically, as we explore in the next section, it implies creating a subtype, static or not, of the type implementing <code>Iterable</code>.
Second, the iterator itself is independent of the fields of the implementing type, but has the ability to return its hidden content.</p>
</div>
<div class="paragraph">
<p>The loop, on a variable <code>list</code> of type implementing <code>Iterable&lt;T&gt;</code>, is expressed as <code>for(T t: list) { &#8230;&#8203; }</code>, and can be interpreted as</p>
</div>
<div class="listingblock">
<div class="title">Example 73, implementation of for-each using an <code>Iterator</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">Iterator</span>&lt;T&gt; it = list.iterator();
<span class="keyword">while</span>(it.hasNext()) {
    T t = it.next();
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The iterator <code>it</code> content-links to <code>list</code>; via the <code>next</code> method, it content-links the hidden content of the <code>list</code> to <code>t</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="independent-type">12.5. Independence of types</h3>
<div class="paragraph">
<p>A concrete implementation of an iterator is often a nested type, static or not (inner class), of the iterable type:</p>
</div>
<div class="listingblock">
<div class="title">Example 74, implementation of an <code>Iterator</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ImmutableArray</span>&lt;T&gt; <span class="directive">implements</span> <span class="predefined-type">Iterable</span>&lt;T&gt; {

    <span class="annotation">@NotNull</span>(content=<span class="predefined-constant">true</span>)
    <span class="directive">private</span> <span class="directive">final</span> T<span class="type">[]</span> elements;

    <span class="annotation">@SuppressWarnings</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">unchecked</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> ImmutableArray(<span class="predefined-type">List</span>&lt;T&gt; input) {
        <span class="local-variable">this</span>.elements = (T<span class="type">[]</span>) input.toArray();
    }

    <span class="annotation">@Override</span>
    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>)
    <span class="directive">public</span> <span class="predefined-type">Iterator</span>&lt;T&gt; iterator() {
        <span class="keyword">return</span> <span class="keyword">new</span> IteratorImpl();
    }

    <span class="annotation">@Container</span>
    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>)
    <span class="type">class</span> <span class="class">IteratorImpl</span> <span class="directive">implements</span> <span class="predefined-type">Iterator</span>&lt;T&gt; {
        <span class="directive">private</span> <span class="type">int</span> i;

        <span class="annotation">@Override</span>
        <span class="directive">public</span> <span class="type">boolean</span> hasNext() {
            <span class="keyword">return</span> i &lt; elements.length;
        }

        <span class="annotation">@Override</span>
        <span class="annotation">@NotNull</span>
        <span class="directive">public</span> T next() {
            <span class="keyword">return</span> elements[i++];
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For <code>ImmutableArray</code> to be immutable, the <code>iterator()</code> method must be independent of the field <code>elements</code>, in other words, the <code>IteratorImpl</code> object must not expose the <code>ImmutableArray</code> 's fields to the outside world.
It cannot be immutable itself, because it needs to hold the state of the iterator.
However, it should protect the fields owned by its enclosing type, up to the same standard as required
for immutability.</p>
</div>
<div class="paragraph">
<p>We propose to add a definition for the independence of a type, identical to the "shielding off" part of the definition of immutability.
Let&#8217;s first go there in a roundabout way:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition</strong>: an <strong>external modification</strong> is a modification, carried out outside the type,</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>on a field, directly accessed from the object, or</p>
</li>
<li>
<p>on an argument or return value, executed after the constructor or method call on the object.</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>Clearly, such external modifications are only possible when the constructor, method or field is non-private.</p>
</div>
<div class="paragraph">
<p>Armed with this definition, we can define the independence of types:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definitions</strong>:</p>
</div>
<div class="paragraph">
<p>A type is <strong>dependent</strong> when external modifications impact the accessible content of the type.</p>
</div>
<div class="paragraph">
<p>A type is <strong>independent</strong>, annotated  <code>@Independent</code> , when external modifications cannot impact the accessible content of the type.
The hidden content of the type is mutable or modifiable.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>This definition is entirely equivalent to the definition of immutability without rules 0 and 1, and rules 2
and 3 restricted to those fields that are 'exposed' to the outside world via linking or content linking.</p>
</div>
<div class="paragraph">
<p>Consider the static variant of <code>IteratorImpl</code>, which makes it more obvious that <code>IteratorImpl</code> maintains a reference
to the element array of its enclosing type:</p>
</div>
<div class="listingblock">
<div class="title">Example 75, implementation of an <code>Iterator</code> as a static nested type</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">ImmutableArray</span>&lt;T&gt; <span class="directive">implements</span> <span class="predefined-type">Iterable</span>&lt;T&gt; {
    ...

    <span class="annotation">@Container</span>
    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>)
    <span class="directive">static</span> <span class="type">class</span> <span class="class">IteratorImpl</span> <span class="directive">implements</span> <span class="predefined-type">Iterator</span>&lt;T&gt; {
        <span class="annotation">@Modified</span>
        <span class="directive">private</span> <span class="type">int</span> i;

        <span class="directive">private</span> <span class="directive">final</span> T<span class="type">[]</span> elements;

        <span class="directive">private</span> IteratorImpl(T<span class="type">[]</span> elements) {
            <span class="local-variable">this</span>.elements = elements;
        }

        <span class="annotation">@Override</span>
        <span class="directive">public</span> <span class="type">boolean</span> hasNext() {
            <span class="keyword">return</span> i &lt; elements.length;
        }

        <span class="annotation">@Override</span>
        <span class="annotation">@NotNull</span>
        <span class="annotation">@Modified</span>
        <span class="directive">public</span> T next() {
            <span class="keyword">return</span> elements[i++];
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The type <code>T</code> is part of the hidden content, the <code>T[]</code> and the counter <code>i</code> are part of the accessible content.
No external modification can impact the array or the counter; indeed, only <code>T</code> and a <code>boolean</code> are exposed.
The latter is immutable, so does not allow modifications.
The former allows modifications on the hidden content, whence the  <code>@Independent(hc=true)</code>  annotation for <code>IteratorImpl</code>.</p>
</div>
<div class="paragraph">
<p>Immutable types are independent as a type, but a type does not even have to be immutable to be independent.
In fact, any type communicating via immutable types to the outside world is independent:</p>
</div>
<div class="listingblock">
<div class="title">Example 76, simple getter and setter, independent</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Independent</span>
<span class="annotation">@Container</span>
<span class="type">class</span> <span class="class">GetterSetter</span> {
    <span class="directive">private</span> <span class="type">int</span> i;

    <span class="directive">public</span> <span class="type">int</span> getI() {
        <span class="keyword">return</span> i;
    }

    <span class="directive">public</span> <span class="type">void</span> setI(<span class="type">int</span> i) {
        <span class="local-variable">this</span>.i = i;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following table summarizes the relationship between immutability and independence by means of example types:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">Mutable, modifiable</th>
<th class="tableblock halign-left valign-top">Immutable with hidden content</th>
<th class="tableblock halign-left valign-top">Immutable without hidden content</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dependent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span> <code>Set</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Independent with hidden content</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span> <code>Iterator&lt;T&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span> <code>Optional&lt;T&gt;</code>, <code>Set.of(T)</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times"></i></span></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Independent</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span> <code>Writer</code>, <code>Iterator&lt;String&gt;</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon red"><i class="fa fa-times"></i></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon green"><i class="fa fa-check"></i></span> <code>int</code>, <code>String</code>, <code>Class</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_further_notes_on_immutability">13. Further notes on immutability</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="extendability">13.1. Extendability of types</h3>
<div class="paragraph">
<p>Unless a class is marked <code>final</code>, <code>sealed</code>, or <code>private</code>, it can be extended in a different source file.
In the context of immutability, this means that any extendable class is like an interface:
it must allow for hidden content.</p>
</div>
<div class="paragraph">
<p>The analyser, however, can be pragmatic about this. Just as in the case of effectively final fields, it can
compute types to be effectively final, or effectively sealed, <em>when presented with the complete code base</em>.
Indeed, if there is a guarantee of being able to see all code, the analyser can easily compute if
a type has effectively been extended, or not.</p>
</div>
<div class="paragraph">
<p>This observation shows that the distinction between immutability with and without
hidden content, is rather small.</p>
</div>
</div>
<div class="sect2">
<h3 id="_eventual_immutability">13.2. Eventual immutability</h3>
<div class="paragraph">
<p>How does the whole story of eventually final fields and eventual immutability mix with hidden content?
At some point, once a necessary precondition has been met, the hidden content will be well-defined, and modifying methods become unavailable.
Before that, fields that will eventually contain the hidden content may still be <code>null</code>, or may be re-assigned.
This should not have any effect, however, on the computation of hidden content linking,  <code>@Independent</code>  annotations, and the propagation of modifications, since the actual types do not change.
The two concepts are sufficiently perpendicular to each other, and can easily co-exist.</p>
</div>
</div>
<div class="sect2">
<h3 id="_constant_types">13.3. Constant types</h3>
<div class="paragraph">
<p>A constant type can be defined as an immutable type whose fields are of constant type themselves.
The basis of this recursion are the primitives, possibly boxed, <code>java.lang.String</code>, and <code>java.lang.Class</code>, i.e.,
all the types that can have a Java literal as a value.</p>
</div>
<div class="paragraph">
<p>The analyser marks a constant type by the string representation of its value, e.g., <code>@ImmutableContainer("3.14")</code>,
but obviously only in case of fields and method return types.
This seems to be the only practical use of this definition.</p>
</div>
<div class="paragraph">
<p>So while not really relevant, observe that types can be constant but not  <code>@Container</code> ; they can be eventually constant,
and they can be constant with hidden content.</p>
</div>
</div>
<div class="sect2">
<h3 id="_field_access_restrictions">13.4. Field access restrictions</h3>
<div class="paragraph">
<p>Let us end this section with a note on the <em>non-private</em> requirement for field and method access.
The definitions of immutability and independence insist on the properties holding for all non-private fields, methods and constructors.</p>
</div>
<div class="paragraph">
<p>First, consider nested types.
Any nested type (a class defined either statically or nested inside another class, an interface defined inside another type) has access to the private methods of the primary type and other nested types inside the primary type.
We first need to investigate whether this additional access plays havoc with the immutability and independence rules.</p>
</div>
<div class="paragraph">
<p>Because all nested types of a primary type are fully known at analysis time, as they must reside in the same <code>.java</code> file, it is possible to ensure that a field, accessible beyond its own class even though it is private to the nested type, remains  <code>@NotModified</code>.
Consider:</p>
</div>
<div class="listingblock">
<div class="title">Example 77, immutability of a nested type</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">NestedTypeExample</span> {

    <span class="annotation">@FinalFields</span> <span class="annotation">@Container</span> <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="directive">static</span> <span class="type">class</span> <span class="class">HoldsStringBuilder</span> {

        <span class="annotation">@Modified</span> <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">StringBuilder</span> sb = <span class="keyword">new</span> <span class="predefined-type">StringBuilder</span>();

        <span class="directive">public</span> HoldsStringBuilder(<span class="predefined-type">String</span> s) {
            add(s).add(s);
        }

        <span class="directive">private</span> HoldsStringBuilder add(<span class="predefined-type">String</span> s) { <i class="conum" data-value="3"></i><b>(3)</b>
            sb.append(s);
            <span class="keyword">return</span> <span class="local-variable">this</span>;
        }

        <span class="annotation">@Override</span>
        <span class="directive">public</span> <span class="predefined-type">String</span> toString() {
            <span class="keyword">return</span> sb.toString();
        }
    }

    <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">String</span> break1(<span class="predefined-type">String</span> s) {
        HoldsStringBuilder hsb = <span class="keyword">new</span> HoldsStringBuilder(s);
        hsb.add(<span class="string"><span class="delimiter">&quot;</span><span class="content">modify!</span><span class="delimiter">&quot;</span></span>);
        <span class="keyword">return</span> hsb.toString();
    }

    <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">String</span> break2(<span class="predefined-type">String</span> s) {
        HoldsStringBuilder hsb = <span class="keyword">new</span> HoldsStringBuilder(s);
        hsb.sb.append(<span class="string"><span class="delimiter">&quot;</span><span class="content">modify field</span><span class="delimiter">&quot;</span></span>);
        <span class="keyword">return</span> hsb.toString();
    }

    <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">StringBuilder</span> break3(<span class="predefined-type">String</span> s) { <i class="conum" data-value="4"></i><b>(4)</b>
        HoldsStringBuilder hsb = <span class="keyword">new</span> HoldsStringBuilder(s);
        hsb.sb.append(<span class="string"><span class="delimiter">&quot;</span><span class="content">modify field</span><span class="delimiter">&quot;</span></span>);
        <span class="keyword">return</span> hsb.sb;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Would have been  <code>@ImmutableContainer</code> , were it not for the <code>break</code> methods</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Because of <code>break2</code>, not because of the presence of <code>add(s).add(s)</code> in the constructor!</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Not only part of construction, because of <code>break1</code></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Introduces a dependence of <code>sb</code> on a method return value</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The solution here, clearly, is to extend the rules to all non-private methods and constructors of the primary type and all its nested types.</p>
</div>
<div class="paragraph">
<p>The second question to answer is whether we can or should relax the requirement of private access, e.g., for a restriction of 'private and same package', or even 'non-public'.
Remember that the <code>protected</code> access modifier allows access to classes that inherit from the type, <em>and</em> to members of the same package.</p>
</div>
<div class="paragraph">
<p>First, consider allowing 'package-private'.
If we were to assume that all types in the same package are fully visible to the analyser at the time of analysis, we could consider extending the rules to analyse all types in the package at the same time, as we did for nested types inside a primary type.
However, firstly, it is perfectly possible, even if it is bad practice, to spread a package over multiple jars.
This denies the analyser complete visibility over the types in a package.
Secondly, the complications that arise computationally are too much for efficient analysis.</p>
</div>
<div class="paragraph">
<p>So there&#8217;s no point in considering <code>protected</code> access.
Even if inheritance where the only criterion used to define this access level, we would not allow it, because the child class can be invisible to the analyser at the time of analysis of the parent.</p>
</div>
<div class="paragraph">
<p>When annotating APIs (see  <em>e2immu</em>  manual), we do use the public vs non-public criterion instead of the non-private vs private one, mostly as a matter of convenience.
We assume (hope?) that library designers and implementers shield off internal types sufficiently, and rely on the project implementer to stick to their package prefix.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="support-classes">14. Support classes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <code>e2immu-support-1.0.0.jar</code> library (in whichever version it comes) essentially contains the
annotations of the analyser, and a small selection of support types.
They are the eventually immutable building blocks that you can use in your project, irrespective
of whether you want analyser support or not.</p>
</div>
<div class="paragraph">
<p>We discuss a selection of the building blocks here.</p>
</div>
<div class="sect2">
<h3 id="support-flipswitch">14.1. FlipSwitch</h3>
<div class="paragraph">
<p>Simpler than <code>FlipSwitch</code> is not possible for an eventually immutable type: it consists solely of a
single boolean, which is at the same time the data and the guard:</p>
</div>
<div class="listingblock">
<div class="title">Example 78, most of <code>org.e2immu.support.FlipSwitch</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">FlipSwitch</span> {

    <span class="annotation">@Final</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">private</span> <span class="directive">volatile</span> <span class="type">boolean</span> t;

    <span class="directive">private</span> <span class="type">boolean</span> set<span class="error">$</span>Precondition() { <span class="keyword">return</span> !t; } <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> set() {
        <span class="keyword">if</span> (t) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Already set</span><span class="delimiter">&quot;</span></span>);
        t = <span class="predefined-constant">true</span>;
    }

    <span class="annotation">@TestMark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="type">boolean</span> isSet() {
        <span class="keyword">return</span> t;
    }

    <span class="directive">private</span> <span class="type">boolean</span> copy<span class="error">$</span>Precondition() { <span class="keyword">return</span> !t; } <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> copy(FlipSwitch other) {
        <span class="keyword">if</span> (other.isSet()) set();
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This companion method is present in the code to validate the computation of the precondition.
See <a href="#preconditions-and-instance-state">Preconditions and instance state</a> for more details.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The  <code>@Mark</code>  is present, even if it is executed conditionally.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The obvious use case for this helper class is to indicate whether a certain job has been done, or not.
Once it has been done, it can never be 'undone' again.</p>
</div>
</div>
<div class="sect2">
<h3 id="support-setonce">14.2. SetOnce</h3>
<div class="paragraph">
<p>One step up from <code>FlipSwitch</code> is <code>SetOnce</code>: a place-holder for one object which can be filled exactly once:</p>
</div>
<div class="listingblock">
<div class="title">Example 79, parts of <code>org.e2immu.support.SetOnce</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>(hc=<span class="predefined-constant">true</span>, after=<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">SetOnce</span>&lt;T&gt; {

    <span class="annotation">@Final</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">private</span> <span class="directive">volatile</span> T t;

    <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> set(<span class="annotation">@NotNull</span> <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) T t) {
        <span class="keyword">if</span> (t == <span class="predefined-constant">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">NullPointerException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Null not allowed</span><span class="delimiter">&quot;</span></span>);
        <span class="keyword">if</span> (<span class="local-variable">this</span>.t != <span class="predefined-constant">null</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Already set: have </span><span class="delimiter">&quot;</span></span> + <span class="local-variable">this</span>.t + <span class="string"><span class="delimiter">&quot;</span><span class="content">, try to set </span><span class="delimiter">&quot;</span></span> + t);
        }
        <span class="local-variable">this</span>.t = t;
    }

    <span class="annotation">@Only</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@NotNull</span>
    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>)
    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> T get() {
        <span class="keyword">if</span> (t == <span class="predefined-constant">null</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Not yet set</span><span class="delimiter">&quot;</span></span>);
        }
        <span class="keyword">return</span> t;
    }

    <span class="annotation">@TestMark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="type">boolean</span> isSet() {
        <span class="keyword">return</span> t != <span class="predefined-constant">null</span>;
    }

    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) <i class="conum" data-value="1"></i><b>(1)</b>
    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> T getOrDefault(T defaultValue) {
        <span class="keyword">if</span> (isSet()) <span class="keyword">return</span> get();
        <span class="keyword">return</span> defaultValue;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Even if it is only linked to the hidden content conditionally.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The analyser relies heavily on this type, with additional support to allow setting multiple times, with exactly
the same value.
This can be ascertained with a helper method, which, as noted in the previous section, also gets the  <code>@Mark</code>  annotation.</p>
</div>
</div>
<div class="sect2">
<h3 id="support-eventuallyfinal">14.3. EventuallyFinal</h3>
<div class="paragraph">
<p>Slightly more flexible than <code>SetOnce</code> is <code>EventuallyFinal</code>: the type allows you to keep writing objects using the
<code>setVariable</code> method, until you write using <code>setFinal</code>.
Then, the state changes and the type becomes immutable:</p>
</div>
<div class="listingblock">
<div class="title">Example 80, <code>org.e2immu.support.EventuallyFinal</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>(hc=<span class="predefined-constant">true</span>, after=<span class="string"><span class="delimiter">&quot;</span><span class="content">isFinal</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">EventuallyFinal</span>&lt;T&gt; {
    <span class="directive">private</span> T value;
    <span class="directive">private</span> <span class="type">boolean</span> isFinal;

    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>)
    <span class="directive">public</span> T get() {
        <span class="keyword">return</span> value;
    }

    <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">isFinal</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">void</span> setFinal(<span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) T value) {
        <span class="keyword">if</span> (<span class="local-variable">this</span>.isFinal) {
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Trying to overwrite a final value</span><span class="delimiter">&quot;</span></span>);
        }
        <span class="local-variable">this</span>.isFinal = <span class="predefined-constant">true</span>;
        <span class="local-variable">this</span>.value = value;
    }

    <span class="annotation">@Only</span>(before=<span class="string"><span class="delimiter">&quot;</span><span class="content">isFinal</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">void</span> setVariable(<span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) T value) {
        <span class="keyword">if</span> (<span class="local-variable">this</span>.isFinal) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Value is already final</span><span class="delimiter">&quot;</span></span>);
        <span class="local-variable">this</span>.value = value;
    }

    <span class="annotation">@TestMark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">isFinal</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">boolean</span> isFinal() {
        <span class="keyword">return</span> isFinal;
    }

    <span class="annotation">@TestMark</span>(value=<span class="string"><span class="delimiter">&quot;</span><span class="content">isFinal</span><span class="delimiter">&quot;</span></span>, before=<span class="predefined-constant">true</span>)
    <span class="directive">public</span> <span class="type">boolean</span> isVariable() {
        <span class="keyword">return</span> !isFinal;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note the occurrence of a negated  <code>@TestMark</code>  annotation: <code>isVariable</code> returns the negation of the normal
<code>iFinal</code> mark test.</p>
</div>
</div>
<div class="sect2">
<h3 id="support-freezable">14.4. Freezable</h3>
<div class="paragraph">
<p>The previous support class, <code>EventuallyFinal</code>, forms the template for a more general approach to eventual immutability:
allow free modifications, until the type is <em>frozen</em> and no modifications can be allowed anymore.</p>
</div>
<div class="listingblock">
<div class="title">Example 81, <code>org.e2immu.support.Freezable</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">frozen</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="1"></i><b>(1)</b>
<span class="directive">public</span> <span class="directive">abstract</span> <span class="type">class</span> <span class="class">Freezable</span> {

    <span class="annotation">@Final</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">frozen</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">private</span> <span class="directive">volatile</span> <span class="type">boolean</span> frozen;

    <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">frozen</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">void</span> freeze() {
        ensureNotFrozen();
        frozen = <span class="predefined-constant">true</span>;
    }

    <span class="annotation">@TestMark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">frozen</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">boolean</span> isFrozen() {
        <span class="keyword">return</span> frozen;
    }

    <span class="directive">private</span> <span class="type">boolean</span> ensureNotFrozen<span class="error">$</span>Precondition() { <span class="keyword">return</span> !frozen; } <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="directive">public</span> <span class="type">void</span> ensureNotFrozen() {
        <span class="keyword">if</span> (frozen) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Already frozen!</span><span class="delimiter">&quot;</span></span>);
    }

    <span class="directive">private</span> <span class="type">boolean</span> ensureFrozen<span class="error">$</span>Precondition() { <span class="keyword">return</span> frozen; } <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="directive">public</span> <span class="type">void</span> ensureFrozen() {
        <span class="keyword">if</span> (!frozen) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Not yet frozen!</span><span class="delimiter">&quot;</span></span>);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Because the type is abstract, <code>hc=true</code> is implied.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>This companion method is present in the code to validate the computation of the precondition.
See <a href="#preconditions-and-instance-state">Preconditions and instance state</a> for more details.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that as discussed in <a href="#inheritance">Inheritance</a>, it is important for <code>Freezable</code>, as an abstract class, to be immutable:
derived classes can never be immutable when their parents are not immutable.</p>
</div>
</div>
<div class="sect2">
<h3 id="support-setoncemap">14.5. SetOnceMap</h3>
<div class="paragraph">
<p>We discuss one example that makes use of (derives from) <code>Freezable</code>: a freezable map where no objects can be overwritten:</p>
</div>
<div class="listingblock">
<div class="title">Example 82, part of <code>org.e2immu.support.SetOnceMap</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>(hc=<span class="predefined-constant">true</span>, after=<span class="string"><span class="delimiter">&quot;</span><span class="content">frozen</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">SetOnceMap</span>&lt;K, V&gt; <span class="directive">extends</span> Freezable {

    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">Map</span>&lt;K, V&gt; map = <span class="keyword">new</span> <span class="predefined-type">HashMap</span>&lt;&gt;();

    <span class="annotation">@Only</span>(before=<span class="string"><span class="delimiter">&quot;</span><span class="content">frozen</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">void</span> put(<span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) <span class="annotation">@NotNull</span> K k,
                    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) <span class="annotation">@NotNull</span> V v) {
        Objects.requireNonNull(k);
        Objects.requireNonNull(v);
        ensureNotFrozen();
        <span class="keyword">if</span> (isSet(k)) {
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Already decided on </span><span class="delimiter">&quot;</span></span> + k + <span class="string"><span class="delimiter">&quot;</span><span class="content">: have </span><span class="delimiter">&quot;</span></span> +
                get(k) + <span class="string"><span class="delimiter">&quot;</span><span class="content">, want to write </span><span class="delimiter">&quot;</span></span> + v);
        }
        map.put(k, v);
    }

    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>)
    <span class="annotation">@NotNull</span>
    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> V get(K k) {
        <span class="keyword">if</span> (!isSet(k)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Not yet decided on </span><span class="delimiter">&quot;</span></span> + k);
        <span class="keyword">return</span> Objects.requireNonNull(map.get(k)); <i class="conum" data-value="1"></i><b>(1)</b>
    }

    <span class="directive">public</span> <span class="type">boolean</span> isSet(K k) { <i class="conum" data-value="2"></i><b>(2)</b>
        <span class="keyword">return</span> map.containsKey(k);
    }

    ...
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The analyser will warn for a potential null pointer exception here, not (yet) making the connection between
<code>isSet</code> and <code>containsKey</code>.
This connection can be implemented using the techniques described in <a href="#preconditions-and-instance-state">Preconditions and instance state</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Implicitly, the parameter <code>K k</code> is  <code>@Independent</code> , because the method is  <code>@NotModified</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The code analyser makes frequent use of this type, often with an additional guard that allows repeatedly putting
the same value to a key.</p>
</div>
</div>
<div class="sect2">
<h3 id="support-lazy">14.6. Lazy</h3>
<div class="paragraph">
<p><code>Lazy</code> implements a lazily-initialized immutable field, of unbound generic type <code>T</code>.
Properly implemented, it is an eventually immutable type:</p>
</div>
<div class="listingblock">
<div class="title">Example 83, <code>org.e2immu.support.Lazy</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>(hc=<span class="predefined-constant">true</span>, after=<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">Lazy</span>&lt;T&gt; {

    <span class="annotation">@NotNull</span>(content=<span class="predefined-constant">true</span>)
    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>, after=<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">private</span> Supplier&lt;T&gt; supplier;

    <span class="annotation">@Final</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">private</span> <span class="directive">volatile</span> T t;

    <span class="directive">public</span> Lazy(<span class="annotation">@NotNull</span>(content=<span class="predefined-constant">true</span>) <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) Supplier&lt;T&gt; supplier) { <i class="conum" data-value="1"></i><b>(1)</b>
        <span class="local-variable">this</span>.supplier = supplier;
    }

    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>)
    <span class="annotation">@NotNull</span>
    <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">t</span><span class="delimiter">&quot;</span></span>) <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="directive">public</span> T get() {
        <span class="keyword">if</span> (t != <span class="predefined-constant">null</span>) <span class="keyword">return</span> t;
        t = Objects.requireNonNull(supplier.get()); <i class="conum" data-value="3"></i><b>(3)</b>
        supplier = <span class="predefined-constant">null</span>; <i class="conum" data-value="4"></i><b>(4)</b>
        <span class="keyword">return</span> t;
    }

    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="type">boolean</span> hasBeenEvaluated() {
        <span class="keyword">return</span> t != <span class="predefined-constant">null</span>;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>The annotation has travelled from the field to the parameter; therefore the parameter has <code>@Independent(hc=true)</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The  <code>@Mark</code>  annotation is conditional; the transition is triggered by nullity of <code>t</code></td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Here <code>t</code>, part of the hidden content, links to <code>supplier</code>, as explained in <a href="#content-linking">Content linking</a>.
The statement also causes the  <code>@NotNull(content=true)</code>  annotation, as defined in <a href="#nullable-section">Nullable, not null</a> and <a href="#identity-and-fluent">Identity and fluent methods</a>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>After the transition from mutable to effectively immutable, the field <code>supplier</code> moves out of the picture.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>After calling the marker method <code>get()</code>, <code>t</code> cannot be assigned anymore, and it becomes  <code>@Final</code> .
The constructor parameter <code>supplier</code> is <code>@Independent(hc=true)</code>, as its hidden content (the result of <code>get()</code>)
links to that of <code>Lazy</code>, namely the field <code>t</code>.</p>
</div>
<div class="paragraph">
<p>But why is <code>supplier</code> as a field not linked to the constructor parameter?
Clearly, <code>supplier</code> is part of the accessible content of <code>Lazy</code>, as its <code>get()</code> method gets called.
The criterion is: a modification on one may cause a modification on the other.
Modifications can only be made by calling the <code>get()</code> method, as there are no other methods, and no fields.
Consequently, the constructor should link to the field, and <code>supplier</code> cannot be <code>@Independent</code>.</p>
</div>
<div class="paragraph">
<p>The answer lies in the eventual nature of <code>Lazy</code>: <em>before</em> the first call to <code>get</code>, the <code>supplier</code> field
is of relevance to the type, and <code>t</code> is not.
<em>After</em> the call to <code>get()</code>, the converse is true, because <code>supplier</code> has been emptied.
We should extend rule 2 of effective immutability by slightly augmenting rule 2:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Rule 2</strong>: All fields are either private, of immutable type, or equal to null.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>A null field cannot be modified, and cannot be but  <code>@Independent</code> , so no changes are necessary to rules 1 and 3.
One can argue that they do not belong to the accessible content, nor to the hidden content, since they cannot be
accessed, and are content-less: rule 4 should not be affected.
In combination with effective finality, this allows the eventually "blanking out" of modifiable fields in
immutable types.</p>
</div>
</div>
<div class="sect2">
<h3 id="support-firstthen">14.7. FirstThen</h3>
<div class="paragraph">
<p>A variant on <code>SetOnce</code> is <code>FirstThen</code>, an eventually immutable container which starts off with one
value, and transitions to another:</p>
</div>
<div class="listingblock">
<div class="title">Example 84, <code>org.e2immu.support.FirstThen</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>(hc=<span class="predefined-constant">true</span>, after=<span class="string"><span class="delimiter">&quot;</span><span class="content">mark</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">FirstThen</span>&lt;S, T&gt; {
    <span class="directive">private</span> <span class="directive">volatile</span> S first;
    <span class="directive">private</span> <span class="directive">volatile</span> T then;

    <span class="directive">public</span> FirstThen(<span class="annotation">@NotNull</span> <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) S first) {
        <span class="local-variable">this</span>.first = Objects.requireNonNull(first);
    }

    <span class="annotation">@TestMark</span>(value=<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>, before=<span class="predefined-constant">true</span>)
    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="type">boolean</span> isFirst() {
        <span class="keyword">return</span> first != <span class="predefined-constant">null</span>;
    }

    <span class="annotation">@TestMark</span>(value=<span class="string"><span class="delimiter">&quot;</span><span class="content">first</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@NotModified</span>
    <span class="directive">public</span> <span class="type">boolean</span> isSet() {
        <span class="keyword">return</span> first == <span class="predefined-constant">null</span>;
    }

    <span class="annotation">@Mark</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">mark</span><span class="delimiter">&quot;</span></span>)
    <span class="directive">public</span> <span class="type">void</span> set(<span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>) <span class="annotation">@NotNull</span> T then) {
        Objects.requireNonNull(then);
        <span class="directive">synchronized</span> (<span class="local-variable">this</span>) {
            <span class="keyword">if</span> (first == <span class="predefined-constant">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Already set</span><span class="delimiter">&quot;</span></span>);
            <span class="local-variable">this</span>.then = then;
            first = <span class="predefined-constant">null</span>;
        }
    }

    <span class="annotation">@Only</span>(before=<span class="string"><span class="delimiter">&quot;</span><span class="content">mark</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>)
    <span class="annotation">@NotModified</span>
    <span class="annotation">@NotNull</span>
    <span class="directive">public</span> S getFirst() {
        <span class="keyword">if</span> (first == <span class="predefined-constant">null</span>)
            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Then has been set</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="1"></i><b>(1)</b>
        S s = first;
        <span class="keyword">if</span> (s == <span class="predefined-constant">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">NullPointerException</span>();
        <span class="keyword">return</span> s;
    }

    <span class="annotation">@Only</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">mark</span><span class="delimiter">&quot;</span></span>)
    <span class="annotation">@Independent</span>(hc=<span class="predefined-constant">true</span>)
    <span class="annotation">@NotModified</span>
    <span class="annotation">@NotNull</span>
    <span class="directive">public</span> T get() {
        <span class="keyword">if</span> (first != <span class="predefined-constant">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>(<span class="string"><span class="delimiter">&quot;</span><span class="content">Not yet set</span><span class="delimiter">&quot;</span></span>); <i class="conum" data-value="2"></i><b>(2)</b>
        T t = then;
        <span class="keyword">if</span> (t == <span class="predefined-constant">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">NullPointerException</span>();
        <span class="keyword">return</span> t;
    }

    <span class="annotation">@Override</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="directive">public</span> <span class="type">boolean</span> equals(<span class="annotation">@Nullable</span> <span class="predefined-type">Object</span> o) {
        <span class="keyword">if</span> (<span class="local-variable">this</span> == o) <span class="keyword">return</span> <span class="predefined-constant">true</span>;
        <span class="keyword">if</span> (o == <span class="predefined-constant">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="predefined-constant">false</span>;
        FirstThen&lt;?, ?&gt; firstThen = (FirstThen&lt;?, ?&gt;) o;
        <span class="keyword">return</span> Objects.equals(first, firstThen.first) &amp;&amp;
                Objects.equals(then, firstThen.then);
    }

    <span class="annotation">@Override</span> <i class="conum" data-value="3"></i><b>(3)</b>
    <span class="directive">public</span> <span class="type">int</span> hashCode() {
        <span class="keyword">return</span> Objects.hash(first, then);
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>This is a bit convoluted.
The precondition is on the field <code>first</code>, and the current implementation of the precondition analyser requires
an explicit check on the field.
Because this field is not final, we cannot assume that it is still null after the initial check; therefore,
we assign it to a local variable, and do another null check to guarantee that the result that we return is <code>@NotNull</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Largely in line with the previous comment: we stick to the precondition on <code>first</code>, and have to check <code>then</code>
to guarantee that the result is <code>@NotNull</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>The <code>equals</code> and <code>hashCode</code> methods inherit the  <code>@NotModified</code> annotation from <code>java.lang.Object</code>.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note that if we were to annotate the methods as contracts, rather than relying on the analyser to detect them, we could have a slightly more efficient implementation.</p>
</div>
</div>
<div class="sect2">
<h3 id="in-the-analyser">14.8. Support classes in the analyser</h3>
<div class="paragraph">
<p>Practice what you preach, and all that.
The  <em>e2immu</em>  analyser relies heavily on support classes such as <code>SetOnce</code>, and on the builder pattern described in the previous section.
Almost all public types are containers.
Because we intend to use the analyser&#8217;s code as a showcase for this project, one important class (<code>ExpressionContext</code>) was intentionally kept as a non-container.</p>
</div>
<div class="paragraph">
<p>A good example of our aim for eventual immutability is <code>TypeInfo</code>, the primary container holding a type.
Initially, a type is nothing but a reference, with a fully qualified name.
Source code or byte code inspection augments it with information about its methods and fields.
Whilst during inspection information is writable, after inspection this information becomes immutable.
We use the builder pattern for <code>TypeInspection</code>, using <code>TypeInspectionImpl.Builder</code> first and <code>TypeInspectionImpl</code> later.
The inspection information is stored using <code>SetOnce</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example 85, explaining <code>org.e2immu.analyser.model.TypeInfo</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="directive">public</span> <span class="type">class</span> <span class="class">TypeInfo</span> {
    <span class="directive">public</span> <span class="directive">final</span> <span class="predefined-type">String</span> fullyQualifiedName;
    <span class="directive">public</span> <span class="directive">final</span> SetOnce&lt;TypeInspection&gt; typeInspection = <span class="keyword">new</span> SetOnce&lt;&gt;();
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once inspection is over, the code analyser takes over.
Results are temporarily stored in <code>TypeAnalysisImpl.Builder</code>, then copied into the immutable <code>TypeAnalysisImpl</code> class.
Both classes implement the <code>TypeAnalysis</code> interface to shield off the build phase.
Once the immutable type is ready, it is stored in <code>TypeInfo</code>:</p>
</div>
<div class="listingblock">
<div class="title">Example 86, explaining <code>org.e2immu.analyser.model.TypeInfo</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>(after=<span class="string"><span class="delimiter">&quot;</span><span class="content">typeAnalysis,typeInspection</span><span class="delimiter">&quot;</span></span>)
<span class="directive">public</span> <span class="type">class</span> <span class="class">TypeInfo</span> {
    <span class="directive">public</span> <span class="directive">final</span> <span class="predefined-type">String</span> fullyQualifiedName;

    <span class="directive">public</span> <span class="directive">final</span> SetOnce&lt;TypeInspection&gt; typeInspection = <span class="keyword">new</span> SetOnce&lt;&gt;();
    <span class="directive">public</span> <span class="directive">final</span> SetOnce&lt;TypeAnalysis&gt; typeAnalysis = <span class="keyword">new</span> SetOnce&lt;&gt;();

    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this way, if we keep playing by the book recursively downward, <code>TypeInfo</code> will become an eventually immutable type.
Software engineers writing applications which use the  <em>e2immu</em>  analyser as a library, can feel secure that once the
analysis phase is over, all the inspected and analysed information remains stable.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_other_annotations">15. Other annotations</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The  <em>e2immu</em>  project defines a whole host of annotations complementary to the ones required for immutability.
We discuss them briefly, and refer to the user manual for an in-depth analysis.</p>
</div>
<div class="sect2">
<h3 id="nullable-section">15.1. Nullable, not null</h3>
<div class="paragraph">
<p>Nullability is a standard static code analyser topic, which we approach from a computational side: the analyser
infers where possible, the user adds annotations to abstract methods.
The complement of not-null (marked  <code>@NotNull</code> ) is nullable (marked  <code>@Nullable</code> ).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A method marked  <code>@NotNull</code>  will never return a null result.
This is very standard.</p>
</li>
<li>
<p>Calling a parameter marked  <code>@NotNull</code>  will result in a null pointer exception at some point during the object life-cycle.</p>
</li>
<li>
<p>A  <code>@NotNull</code>  or  <code>@Nullable</code>  annotation on a field is a consequence of not-null computations on the assignments to the field.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To be able to compute the not-null of parameters, we must specify some sort of flow or direction to break
chicken-and-egg situations.
We compute in the following order:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>context not-null of parameters: do parameters occur in a not-null context?</p>
</li>
<li>
<p>field not-null: has the field been assigned a value (or values) that are possibly null? does the field
occur in a not-null context?</p>
</li>
<li>
<p>external not-null of parameters linked to fields: once the first two have been computed, warnings can be given
when a parameter, assigned to a nullable field, occurs in a not-null context</p>
</li>
</ol>
</div>
<div class="sect3">
<h4 id="_higher_order_not_null">15.1.1. Higher order not-null</h4>
<div class="paragraph">
<p>We use the annotation  <code>@NotNull(content=true)</code>  to indicate that none of the object&#8217;s fields can be null.
This concept is useful when working with collections.</p>
</div>
<div class="paragraph">
<p>Consider the following  <code>@NotNull</code>  variants on the <code>List</code> API:</p>
</div>
<div class="listingblock">
<div class="title">Example 87,  <code>@NotNull</code>  annotations on <code>Collection</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">boolean</span> add(<span class="annotation">@NotNull</span> E e);
<span class="type">boolean</span> addAll(<span class="annotation">@NotNull</span>(content=<span class="predefined-constant">true</span>) <span class="predefined-type">Collection</span>&lt;? <span class="directive">extends</span> E&gt; collection);
<span class="annotation">@NotNull</span>(content=<span class="predefined-constant">true</span>) <span class="directive">static</span> &lt;E&gt; <span class="predefined-type">List</span>&lt;E&gt; copyOf(<span class="annotation">@NotNull</span>(content=<span class="predefined-constant">true</span>) <span class="predefined-type">Collection</span>&lt;? <span class="directive">extends</span> E&gt; collection);
<span class="annotation">@NotNull</span>(content=<span class="predefined-constant">true</span>) <span class="predefined-type">Iterator</span>&lt;E&gt; iterator();</code></pre>
</div>
</div>
<div class="paragraph">
<p>They effectively block the use of null elements in the collection.
As a consequence, looping over the elements will not give potential null pointer warnings.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
This is purely an opinion: we&#8217;d rather not use null as elements of a collection.
You are free to annotate differently!
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Higher orders are possible as well.
A second level would be useful when working with entry sets:</p>
</div>
<div class="listingblock">
<div class="title">Example 88,  <code>@NotNull</code>  annotations on <code>Map</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">V put(<span class="annotation">@NotNull</span> K key, <span class="annotation">@NotNull</span> V value);
<span class="annotation">@NotNull</span> <span class="directive">static</span> &lt;K, V&gt; <span class="predefined-type">Map</span>&lt;K, V&gt; copyOf(<span class="annotation">@NotNull</span> <span class="predefined-type">Map</span>&lt;? <span class="directive">extends</span> K, ? <span class="directive">extends</span> V&gt; map);
<span class="annotation">@NotNull</span>(content2=<span class="predefined-constant">true</span>) <span class="predefined-type">Set</span>&lt;<span class="predefined-type">Map</span>.Entry&lt;K, V&gt;&gt; entrySet();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how the map copy is only  <code>@NotNull</code> , while the entry set is not null, the entries in this set are not null,
and the keys and values are neither.
There is currently no plan to implement beyond  <code>@NotNull(content=true)</code> , however.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="identity-and-fluent">15.2. Identity and fluent methods</h3>
<div class="paragraph">
<p>The analyser marks methods which returns their first parameter with <code>@Identity</code>, and methods which return
<code>this</code> with <code>@Fluent</code>.
The former are convenient to introduce preconditions, the latter occur frequently when chaining methods in builders.
Here is an integrated example:</p>
</div>
<div class="listingblock">
<div class="title">Example 89, methods marked  <code>@Identity</code>  and  <code>@Fluent</code> </div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@FinalFields</span>(builds=<span class="predefined-type">List</span>.class)
<span class="type">class</span> <span class="class">Builder</span> {

    <span class="annotation">@NotNull</span>
    <span class="annotation">@NotModified</span>
    <span class="annotation">@Identity</span>
    <span class="directive">private</span> <span class="directive">static</span> &lt;T&gt; T requireNonNull(<span class="annotation">@NotNull</span> T t) {
        <span class="keyword">if</span>(t == <span class="predefined-constant">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalArgumentException</span>();
        <span class="keyword">return</span> t;
    }

    <span class="directive">private</span> <span class="directive">final</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; list = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;();

    <span class="annotation">@Modified</span>
    <span class="annotation">@Fluent</span>
    <span class="directive">public</span> Builder add(<span class="annotation">@NotNull</span> <span class="predefined-type">String</span> s) {
        list.add(requireNonNull(s));
        <span class="keyword">return</span> <span class="local-variable">this</span>;
    }

    <span class="annotation">@Modified</span>
    <span class="annotation">@Fluent</span>
    <span class="directive">public</span> Builder add(<span class="type">int</span> i) {
        list.add(<span class="predefined-type">Integer</span>.toString(i));
        <span class="keyword">return</span> <span class="local-variable">this</span>;
    }

    <span class="annotation">@NotModified</span>
    <span class="annotation">@ImmutableContainer</span>
    <span class="directive">public</span> <span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; build() {
        <span class="keyword">return</span> <span class="predefined-type">List</span>.copyOf(list);
    }

    <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> <span class="predefined-type">Set</span>&lt;<span class="predefined-type">String</span>&gt; one23 = <span class="keyword">new</span> Builder().add(<span class="integer">1</span>).add(<span class="integer">2</span>).add(<span class="integer">3</span>).add(<span class="string"><span class="delimiter">&quot;</span><span class="content">go</span><span class="delimiter">&quot;</span></span>).build();
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="finalizers">15.3. Finalizers</h3>
<div class="paragraph">
<p>Up to now, we have focused on the distinction between the building phase of an object&#8217;s life-cycle, and its
subsequent immutable phase.
We have ignored the destruction of objects: critically important for some applications, but often completely
ignored by Java programmers because of the silent background presence of the garbage collector.
In this section we introduce an annotation,  <code>@Finalizer</code> , with the goal of being able to mark that calling a
certain method means that the object has reached the end of its life-cycle:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Once a method marked  <code>@Finalizer</code>  has been called, no other methods may be subsequently applied.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>Why is this useful?
The most obvious use-case for immutability is the meaning of the <code>build()</code> method in a builder: can you call it once,
or is the builder somehow incremental?
Secondly, consider "terminal" operations such as <code>findAny</code> or <code>collect</code> on a stream. They close the stream,
after which you are not allowed to use it anymore.</p>
</div>
<div class="paragraph">
<p>How can the analyser enforce the sequence of method calling on an object?</p>
</div>
<div class="paragraph">
<p>The simplest way is by some severe restrictions:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>The following need to be true at all times when using types with finalizer methods:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Any field of a type with finalizers must be effectively final (marked with  <code>@Final</code> ).</p>
</li>
<li>
<p>A finalizer method can only be called on a field inside a method which is marked as a finalizer as well.</p>
</li>
<li>
<p>A finalizer method can never be called on a parameter or any variable linked to it, with linking as defined throughout this document (see <a href="#linking-and-independence">Linking, dependence</a>).</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>Interestingly, these restrictions are such that they help you control the life-cycle of objects with a  <code>@Finalizer</code> , by not letting them out of sight.</p>
</div>
<div class="paragraph">
<p>Note that the  <code>@Finalizer</code>  annotation is always contracted; it cannot be computed.</p>
</div>
<div class="paragraph">
<p>Let us start from the following example, using <a href="#support-eventuallyfinal">EventuallyFinal</a>:</p>
</div>
<div class="listingblock">
<div class="title">Example 90, a type with a  <code>@Finalizer</code>  method</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">ExampleWithFinalizer</span> {
    <span class="annotation">@BeforeMark</span>
    <span class="directive">private</span> <span class="directive">final</span> EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; data = <span class="keyword">new</span> EventuallyFinal&lt;&gt;();

    <span class="annotation">@Fluent</span>
    <span class="directive">public</span> ExampleWithFinalizer set(<span class="predefined-type">String</span> string) {
        data.setVariable(string);
        <span class="keyword">return</span> <span class="local-variable">this</span>;
    }

    <span class="annotation">@Fluent</span>
    <span class="directive">public</span> ExampleWithFinalizer doSomething() {
        <span class="predefined-type">System</span>.out.println(data.toString());
        <span class="keyword">return</span> <span class="local-variable">this</span>;
    }

    <span class="annotation">@Finalizer</span>
    <span class="annotation">@BeforeMark</span>
    <span class="directive">public</span> EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; getData() {
        <span class="keyword">return</span> data;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using  <code>@Fluent</code>  methods to go from construction to finalizer is definitely allowed according to the rules:</p>
</div>
<div class="listingblock">
<div class="title">Example 91, calling the finalizer method</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>
<span class="directive">public</span> <span class="directive">static</span> EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; fluent() {
    EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; d = <span class="keyword">new</span> ExampleWithFinalizer()
        .set(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>).doSomething().set(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>).doSomething().getData();
    d.setFinal(<span class="string"><span class="delimiter">&quot;</span><span class="content">x</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">return</span> d;
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Passing on these objects as arguments is permitted, but the recipient should not call the finalizer.
Actually, given our strong preference for containers, the recipient should not even modify the object!
Consider:</p>
</div>
<div class="listingblock">
<div class="title">Example 92, illegal call</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ImmutableContainer</span>
<span class="directive">public</span> <span class="directive">static</span> EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; stepWise() {
    ExampleWithFinalizer ex = <span class="keyword">new</span> ExampleWithFinalizer();
    ex.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>);
    ex.doSomething();
    ex.set(<span class="string"><span class="delimiter">&quot;</span><span class="content">b</span><span class="delimiter">&quot;</span></span>);
    doSthElse(ex); <i class="conum" data-value="1"></i><b>(1)</b>
    EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; d = ex.getData();
    d.setFinal(<span class="string"><span class="delimiter">&quot;</span><span class="content">x</span><span class="delimiter">&quot;</span></span>);
    <span class="keyword">return</span> d;
}

<span class="directive">private</span> <span class="directive">static</span> <span class="type">void</span> doSthElse(<span class="annotation">@NotModified</span> ExampleWithFinalizer ex) {
    ex.doSomething(); <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>here we pass on the object</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>forbidden to call the finalizer; other methods allowed.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Rules 1 and 2 allow you to store a finalizer type inside a field, but only when finalization is attached to the destruction of the holding type.
Examples follow immediately, in the context of the  <code>@BeforeMark</code>  annotation.</p>
</div>
<div class="sect3">
<h4 id="_processors_and_finishers">15.3.1. Processors and finishers</h4>
<div class="paragraph">
<p>It is worth observing that finalizers play well with the  <code>@BeforeMark</code>  annotation.
They allow us to introduce the concepts of <em>processors</em> and <em>finishers</em> for eventually immutable types in their <em>before</em> state.</p>
</div>
<div class="paragraph">
<p>The purpose of a <em>processor</em> is to receive an object in the  <code>@BeforeMark</code>  state, hold it, use a lot of temporary data in the meantime, and then release it again, modified but still in the  <code>@BeforeMark</code>  state.</p>
</div>
<div class="listingblock">
<div class="title">Example 93, conceptual example of a processor</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Processor</span> {
    <span class="directive">private</span> <span class="type">int</span> count; <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="annotation">@BeforeMark</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="directive">private</span> <span class="directive">final</span> EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; eventuallyFinal;

    <span class="directive">public</span> Processor(<span class="annotation">@BeforeMark</span> EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; eventuallyFinal) {
        <span class="local-variable">this</span>.eventuallyFinal = eventuallyFinal;
    }

    <span class="directive">public</span> <span class="type">void</span> set(<span class="predefined-type">String</span> s) { <i class="conum" data-value="3"></i><b>(3)</b>
        eventuallyFinal.setVariable(s);
        count++;
    }

    <span class="annotation">@Finalizer</span>
    <span class="annotation">@BeforeMark</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="directive">public</span> EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; done(<span class="predefined-type">String</span> last) {
        eventuallyFinal.setVariable(last + <span class="string"><span class="delimiter">&quot;</span><span class="content">; tried </span><span class="delimiter">&quot;</span></span> + count);
        <span class="keyword">return</span> eventuallyFinal;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>symbolises the temporary data to be destroyed after processing</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>the field is private, not passed on, no  <code>@Mark</code>  method is called on it, and it is exposed only in a  <code>@Finalizer</code> </td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>symbolises the modifications that act as processing</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>the result of processing: an eventually immutable object in the same initial state.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The purpose of a <em>finisher</em> is to receive an object in the  <code>@BeforeMark</code>  state, and return it in the final state.
In the meantime, it gets modified (finished), while there is other temporary data around.
Once the final state is reached, the analyser guarantees that the temporary data is destroyed by severely limiting the scope of the finisher object.</p>
</div>
<div class="listingblock">
<div class="title">Example 94, conceptual example of finisher</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">class</span> <span class="class">Finisher</span> {
    <span class="directive">private</span> <span class="type">int</span> count; <i class="conum" data-value="1"></i><b>(1)</b>

    <span class="annotation">@BeforeMark</span> <i class="conum" data-value="2"></i><b>(2)</b>
    <span class="directive">private</span> <span class="directive">final</span> EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; eventuallyFinal;

    <span class="directive">public</span> Finisher(<span class="annotation">@BeforeMark</span> EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; eventuallyFinal) {
        <span class="local-variable">this</span>.eventuallyFinal = eventuallyFinal;
    }

    <span class="annotation">@Modified</span>
    <span class="directive">public</span> <span class="type">void</span> set(<span class="predefined-type">String</span> s) { <i class="conum" data-value="3"></i><b>(3)</b>
        eventuallyFinal.setVariable(s);
        count++;
    }

    <span class="annotation">@Finalizer</span>
    <span class="annotation">@ImmutableContainer</span> <i class="conum" data-value="4"></i><b>(4)</b>
    <span class="directive">public</span> EventuallyFinal&lt;<span class="predefined-type">String</span>&gt; done(<span class="predefined-type">String</span> last) {
        eventuallyFinal.setFinal(last + <span class="string"><span class="delimiter">&quot;</span><span class="content">; tried </span><span class="delimiter">&quot;</span></span> + count);
        <span class="keyword">return</span> eventuallyFinal;
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>symbolises the temporary data to be destroyed.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>only possible because the transition occurs in a  <code>@Finalizer</code>  method</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>symbolises the modifications that act as finishing</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>the result of finishing: an eventually immutable object in its end-state.</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_utility_classes">15.4. Utility classes</h3>
<div class="paragraph">
<p>We use the simple and common definition:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p><strong>Definition</strong>: a <strong>utility class</strong> is an immutable class which cannot be instantiated.</p>
</div>
</div>
</div>
<div class="paragraph">
<p>These definitions imply</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>a utility class has no non-static fields,</p>
</li>
<li>
<p>it has a single, private, unused constructor,</p>
</li>
<li>
<p>and its static fields (if it has any) are of immutable type.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_extension_classes">15.5. Extension classes</h3>
<div class="paragraph">
<p>In Java, many classes cannot be extended easily.
Implementations of extensions typically use a utility class with the convention that the first parameter of the
static method is the object of the extended method call:</p>
</div>
<div class="listingblock">
<div class="title">Example 95, an extension class</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@ExtensionClass</span>(of=<span class="predefined-type">String</span><span class="type">[]</span>.class)
<span class="type">class</span> <span class="class">ExtendStringArray</span> {
    <span class="directive">private</span> ExtendStringArray() { <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">UnsupportedOperationException</span>(); }

    <span class="directive">public</span> <span class="directive">static</span> <span class="predefined-type">String</span> weave(<span class="annotation">@NotModified</span> <span class="predefined-type">String</span><span class="type">[]</span> strings) {
        <span class="comment">// generate a new string by weaving the given strings (concat 1st chars, etc.)</span>
    }

    <span class="directive">public</span> <span class="directive">static</span> <span class="type">int</span> appendEach(<span class="annotation">@Modified</span> <span class="predefined-type">String</span><span class="type">[]</span> strings, <span class="predefined-type">String</span> append) {
        <span class="comment">// append the parameter 'append' to each of the strings in the array</span>
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>We use the following criteria to designate a class as an extension:</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>A class is an extension class of a type <code>E</code> when</p>
</div>
<div class="ulist">
<ul>
<li>
<p>the class is immutable;</p>
</li>
<li>
<p>all non-private static methods with parameters must have a  <code>@NotNull</code>  1st parameter of type <code>E</code>, the type being extended.
There must be at least one such method;</p>
</li>
<li>
<p>non-private static methods without parameters must return a value of type <code>E</code>, and must also be  <code>@NotNull</code> .</p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph">
<p>Static classes can be used to 'extend' closed types, as promoted by the <a href="https://www.eclipse.org/xtend/" target="_blank" rel="noopener">Xtend</a> project.
Immutable classes can also play the role of extension facilitators, with the additional benefit of having some
immutable data to be used as a context.</p>
</div>
<div class="paragraph">
<p>Note that extension classes will often not be  <code>@Container</code> , since the first parameter will be  <code>@Modified</code>  in many cases.</p>
</div>
</div>
<div class="sect2">
<h3 id="singleton-classes">15.6. Singleton classes</h3>
<div class="paragraph">
<p>A singleton class is a class which has a mechanism to limit the creation of instances to a maximum of one.
The term 'singleton' then refers to this unique instance.</p>
</div>
<div class="paragraph">
<p>The  <em>e2immu</em>  analyser currently recognizes two systems for limiting the number of instances:
the creation of an instance in a single static field with a static constructor, and a precondition on a constructor
using a private static boolean field.</p>
</div>
<div class="paragraph">
<p>An example of the first strategy is:</p>
</div>
<div class="listingblock">
<div class="title">Example 96, first mechanism recognized to enforce a singleton</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Singleton</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SingletonExample</span> {

    <span class="directive">public</span> <span class="directive">static</span> <span class="directive">final</span> SingletonExample SINGLETON = <span class="keyword">new</span> SingletonExample(<span class="integer">123</span>);

    <span class="directive">private</span> <span class="directive">final</span> <span class="type">int</span> k;

    <span class="directive">private</span> SingletonExample(<span class="type">int</span> k) {
        <span class="local-variable">this</span>.k = k;
    }

    <span class="directive">public</span> <span class="type">int</span> multiply(<span class="type">int</span> i) {
        <span class="keyword">return</span> k * i;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>An example of the second strategy is:</p>
</div>
<div class="listingblock">
<div class="title">Example 97, second mechanism recognized to enforce a singleton</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="annotation">@Singleton</span>
<span class="directive">public</span> <span class="type">class</span> <span class="class">SingletonWithPrecondition</span> {

    <span class="directive">private</span> <span class="directive">final</span> <span class="type">int</span> k;
    <span class="directive">private</span> <span class="directive">static</span> <span class="type">boolean</span> created;

    <span class="directive">public</span> SingletonWithPrecondition(<span class="type">int</span> k) {
        <span class="keyword">if</span> (created) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="exception">IllegalStateException</span>();
        created = <span class="predefined-constant">true</span>;
        <span class="local-variable">this</span>.k = k;
    }

    <span class="directive">public</span> <span class="type">int</span> multiply(<span class="type">int</span> i) {
        <span class="keyword">return</span> k * i;
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="preconditions-and-instance-state">16. Preconditions and instance state</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The  <em>e2immu</em>  analyser needs pretty strong support for determining preconditions on methods to be able to compute eventual immutability.
A lot of the mechanics involved can be harnessed in other ways as well, for example, to detect common mistakes in the use of collection classes.</p>
</div>
<div class="paragraph">
<p>We have implemented a system where the value of a variable can be augmented with <em>instance state</em> each time a method operates on the variable.
In the case of Java collections and <code>StringBuilder</code>, size-based instance state is low-hanging fruit.
Let&#8217;s start with an example:</p>
</div>
<div class="listingblock">
<div class="title">Example 98, creating an empty list</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; list = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;();
<span class="keyword">if</span> (list.size() &gt; <span class="integer">0</span>) { <span class="comment">// WARNING: evaluates to constant</span>
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When creating a new <code>ArrayList</code> using the empty constructor, we can store in the variable&#8217;s value that its size is 0.
First, let us look at the annotations for the <code>size</code> method:</p>
</div>
<div class="listingblock">
<div class="title">Example 99, annotations of <code>List.size</code></div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">void</span> size<span class="error">$</span>Aspect<span class="error">$</span>Size() {}
<span class="type">boolean</span> size<span class="error">$</span>Invariant<span class="error">$</span>Size(<span class="type">int</span> i) { <span class="keyword">return</span> i &gt;= <span class="integer">0</span>; }
<span class="annotation">@NotModified</span>
<span class="type">int</span> size() { <span class="keyword">return</span> <span class="integer">0</span>; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>The method has two <em>companion methods</em>.
The first registers <code>Size</code> as a numeric <em>aspect</em> linked to the <code>size</code> method.
The second adds an invariant (an assertion that is always true) in relation to the aspect: the size is never negative.</p>
</div>
<div class="paragraph">
<p>Looking at the annotations for the empty constructor,</p>
</div>
<div class="listingblock">
<div class="title">Example 100, annotations of empty <code>ArrayList</code> constructor</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">boolean</span> <span class="predefined-type">ArrayList</span><span class="error">$</span>Modification<span class="error">$</span>Size(<span class="type">int</span> post) { <span class="keyword">return</span> post == <span class="integer">0</span>; }
<span class="directive">public</span> <span class="predefined-type">ArrayList</span><span class="error">$</span>() { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>we see another companion method, that expresses the effect of the construction in terms of the <code>Size</code> aspect.
(The dollar sign at the end of the constructor is an artifact of the annotated API system; please refer to the  <em>e2immu</em>  manual.) Internally, we represent the value of <code>list</code> after the assignment as</p>
</div>
<div class="listingblock">
<div class="title">Example 101, internal representation of an empty list</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;()<span class="comment">/*0==this.size()*/</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The expression in the companion results in the fact that the <code>Size</code> aspect post-modification is 0.
This then gets added to the evaluation state, which allows the analyser to conclude that the expression in the if-statement is a constant true.</p>
</div>
<div class="paragraph">
<p>This approach is sufficiently strong to catch a number of common problems when working with collections.
After adding one element to the empty list, as in:</p>
</div>
<div class="listingblock">
<div class="title">Example 102, adding an element to an empty list</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="predefined-type">List</span>&lt;<span class="predefined-type">String</span>&gt; list = <span class="keyword">new</span> <span class="predefined-type">ArrayList</span>&lt;&gt;();
list.add(<span class="string"><span class="delimiter">&quot;</span><span class="content">a</span><span class="delimiter">&quot;</span></span>);</code></pre>
</div>
</div>
<div class="paragraph">
<p>the value of <code>list</code> becomes</p>
</div>
<div class="listingblock">
<div class="title">Example 103, internal representation after adding an element</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java">instance type <span class="predefined-type">ArrayList</span>&lt;<span class="predefined-type">String</span>&gt;<span class="comment">/*this.contains(&quot;a&quot;)&amp;&amp;1==this.size()*/</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>The boolean expression in the comments is added to the evaluation state, so that expressions such as <code>list.isEmpty()</code>, defined as:</p>
</div>
<div class="listingblock">
<div class="title">Example 104, <code>List.isEmpty</code> and its companion method</div>
<div class="content">
<pre class="CodeRay highlight"><code data-lang="java"><span class="type">boolean</span> isEmpty<span class="error">$</span>Value<span class="error">$</span>Size(<span class="type">int</span> i, <span class="type">boolean</span> retVal) { <span class="keyword">return</span> i == <span class="integer">0</span>; }
<span class="annotation">@NotModified</span>
<span class="type">boolean</span> isEmpty() { <span class="keyword">return</span> <span class="predefined-constant">true</span>; }</code></pre>
</div>
</div>
<div class="paragraph">
<p>can be evaluated by the analyser.
We refer to the manual for a more in-depth treatment of companion methods and instance state.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_appendix">17. Appendix</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_default_annotations">17.1. Default annotations</h3>
<div class="paragraph">
<p>When annotating abstract types and methods, or types in the Annotated APIs, observe the following rules.</p>
</div>
<div class="paragraph">
<p>A method is  <code>@NotModified</code> unless otherwise specified, its parameters are assumed to be  <code>@Modified</code> , unless they are of
immutable type.</p>
</div>
<div class="paragraph">
<p>Due to the large amount of circular type dependencies in the JDK, combined with the current limitations of the analyser,
the implementation of the Annotated API analyser requires contracted annotations about independence,
immutability, and container on the type.
The following combinations are possible with respect ot independence and immutability:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>no independence information: (in)dependence according to the immutability value
(not immutable &#8594; dependent,  <code>@Immutable(hc=true)</code>  &#8594;  <code>@Independent(hc=true)</code> ,  <code>@Immutable</code>  &#8594;  <code>@Independent</code> )</p>
</li>
<li>
<p> <code>@Independent(absent=true)</code> : dependent; this requires that the type is not immutable</p>
</li>
<li>
<p> <code>@Independent(hc=true)</code> : this is the default for  <code>@Immutable(hc=true)</code> ,  <code>@ImmutableContainer(hc=true)</code> , so explicitly writing this annotation
is only necessary on non-immutable types</p>
</li>
<li>
<p> <code>@Independent</code> : this is the default for  <code>@Immutable</code> ,  <code>@ImmutableContainer</code> , so so explicitly writing this annotation
is only useful for mutable or  <code>@Immutable(hc=true)</code>  types</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Recall that abstract types always have hidden content, so the <code>hc=true</code> is always implicitly present on
 <code>@Independent</code>  and  <code>@Immutable</code> ,  <code>@ImmutableContainer</code>  on the type.
We generally do not write <code>hc=false</code>, as that is the default value in the annotation.
The analyser will complain when <code>hc=false</code> is present on the  <code>@Immutable</code>  annotation of an abstract type.</p>
</div>
<div class="paragraph">
<p>To support the user, a warning will be raised when the independence value on the type is incompatible with
that on its methods, parameters and fields.</p>
</div>
<div class="paragraph">
<p>In a  <code>@Container</code>  type, all  <code>@Fluent</code>  methods and all void methods are assumed to be  <code>@Modified</code> .
Change this by explicitly marking the method  <code>@NotModified</code> or  <code>@StaticSideEffects</code> .</p>
</div>
<div class="paragraph">
<p>Parameters of a non-modifying method are  <code>@Independent</code>  by default, regardless of an independence annotation on the type.
This can be overwritten by  <code>@Independent(absent=true)</code>  or  <code>@Independent(hc=true)</code>  when the method exposes parts of the fields' object graph via its parameters.
Parameters of a modifying method are assumed to be dependent when the type is not immutable, and independent when the type is immutable, the hidden content carrying over from immutable to independent.</p>
</div>
<div class="paragraph">
<p>Dependence is only explicitly written as  <code>@Independent(absent=true)</code>  on a type after analysis, when this type has (eventually) final fields and no modifying methods, as a marker to the user to indicate that it is the independence property that is missing to reach immutability.
Marking a non-immutable type with  <code>@Independent</code>  specifies that no parameter or return value can be dependent.
The hidden content parameter given by the user is ignored: you will still have to mark any method or parameter which communicates hidden content with  <code>@Independent(hc=true)</code> .</p>
</div>
<div class="paragraph">
<p>When a type is immutable,  <code>@Independent</code>  becomes the default independence annotation for methods and parameters.
You must still use  <code>@Independent(hc=true)</code>  to indicate communication of hidden content.</p>
</div>
<div class="paragraph">
<p>Methods marked  <code>@Fluent</code>  are always  <code>@Independent</code> , because returning the type itself does not expose any additional information.</p>
</div>
<div class="paragraph">
<p>Following its definition,  <code>@UtilityClass</code>  on a type implies  <code>@Immutable</code> .</p>
</div>
<div class="paragraph">
<p>In application mode, the analyser will regard every class that is never extended as effectively final.
This property is only relevant when the type is immutable; the absence of <code>hc=true</code> is a marker.</p>
</div>
<div class="paragraph">
<p>Parameters of "official" functional interface type (i.e., the type is a functional interface type in the package
<code>java.util.function</code>) have the  <code>@IgnoreModifications</code>  annotation, unless explicitly overwritten by  <code>@Modified</code> .</p>
</div>
<div class="paragraph">
<p>The default nullable annotation for parameters and return values of non-primitive type is  <code>@Nullable</code> .</p>
</div>
<div class="paragraph">
<p>A factory method is a static method returning an object of the type of the class.
Independence of a factory method is always with respect to the method&#8217;s parameters, rather than to the type.
Independence of a factory method&#8217;s parameters corresponds to the immutability of the parameter type.
These two rules also applies to any static method in an immutable type.
Note that utility classes are classes that are deeply immutable and cannot be instantiated, so it applies to their static methods.</p>
</div>
<div class="paragraph">
<p>In general, annotations are inherited on types, methods and parameters.
The properties can deviate,</p>
</div>
<div class="ulist">
<ul>
<li>
<p>from  <code>@Modified</code>  to  <code>@NotModified</code> is possible, from  <code>@NotModified</code> to  <code>@Modified</code>  is not</p>
</li>
<li>
<p>independence can go from left to right in  <code>@Independent(absent=true)</code>  &#8594;  <code>@Independent(hc=true)</code>  &#8594;  <code>@Independent</code> ,
but not from right to left</p>
</li>
<li>
<p>a type deriving from an immutable type does not need to be immutable; however, a type deriving from a
non-immutable type can never be immutable</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When a method has a single statement, returning a constant value, the <code>@ImmutableContainer("value")</code> is implicit.
Similarly, when a field is explicitly final (it has the <code>final</code> modifier) and it has an initialiser, then both  <code>@Final</code> 
and, if relevant, <code>@ImmutableContainer("value")</code>, is implicit.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_copyright_and_license">18. Copyright and License</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Copyright &#169; 2020&#8212;&#8203;2023 Bart Naudts, <a href="https://www.e2immu.org" class="bare">https://www.e2immu.org</a></p>
</div>
<div class="paragraph">
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.
You should have received a copy of the GNU Lesser General Public License along with this program.  If not, see <a href="http://www.gnu.org/licenses/" class="bare">http://www.gnu.org/licenses/</a>.</p>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2023-10-24 13:25:55 +0200
</div>
</div>
<style>
/* Stylesheet for CodeRay to match GitHub theme | MIT License | http://foundation.zurb.com */
pre.CodeRay{background:#f7f7f8}
.CodeRay .line-numbers{border-right:1px solid currentColor;opacity:.35;padding:0 .5em 0 0}
.CodeRay span.line-numbers{display:inline-block;margin-right:.75em}
.CodeRay .line-numbers strong{color:#000}
table.CodeRay{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.CodeRay td{vertical-align:top;line-height:inherit}
table.CodeRay td.line-numbers{text-align:right}
table.CodeRay td.code{padding:0 0 0 .75em}
.CodeRay .debug{color:#fff !important;background:#000080 !important}
.CodeRay .annotation{color:#007}
.CodeRay .attribute-name{color:#000080}
.CodeRay .attribute-value{color:#700}
.CodeRay .binary{color:#509}
.CodeRay .comment{color:#998;font-style:italic}
.CodeRay .char{color:#04d}
.CodeRay .char .content{color:#04d}
.CodeRay .char .delimiter{color:#039}
.CodeRay .class{color:#458;font-weight:bold}
.CodeRay .complex{color:#a08}
.CodeRay .constant,.CodeRay .predefined-constant{color:#008080}
.CodeRay .color{color:#099}
.CodeRay .class-variable{color:#369}
.CodeRay .decorator{color:#b0b}
.CodeRay .definition{color:#099}
.CodeRay .delimiter{color:#000}
.CodeRay .doc{color:#970}
.CodeRay .doctype{color:#34b}
.CodeRay .doc-string{color:#d42}
.CodeRay .escape{color:#666}
.CodeRay .entity{color:#800}
.CodeRay .error{color:#808}
.CodeRay .exception{color:inherit}
.CodeRay .filename{color:#099}
.CodeRay .function{color:#900;font-weight:bold}
.CodeRay .global-variable{color:#008080}
.CodeRay .hex{color:#058}
.CodeRay .integer,.CodeRay .float{color:#099}
.CodeRay .include{color:#555}
.CodeRay .inline{color:#000}
.CodeRay .inline .inline{background:#ccc}
.CodeRay .inline .inline .inline{background:#bbb}
.CodeRay .inline .inline-delimiter{color:#d14}
.CodeRay .inline-delimiter{color:#d14}
.CodeRay .important{color:#555;font-weight:bold}
.CodeRay .interpreted{color:#b2b}
.CodeRay .instance-variable{color:#008080}
.CodeRay .label{color:#970}
.CodeRay .local-variable{color:#963}
.CodeRay .octal{color:#40e}
.CodeRay .predefined{color:#369}
.CodeRay .preprocessor{color:#579}
.CodeRay .pseudo-class{color:#555}
.CodeRay .directive{font-weight:bold}
.CodeRay .type{font-weight:bold}
.CodeRay .predefined-type{color:inherit}
.CodeRay .reserved,.CodeRay .keyword {color:#000;font-weight:bold}
.CodeRay .key{color:#808}
.CodeRay .key .delimiter{color:#606}
.CodeRay .key .char{color:#80f}
.CodeRay .value{color:#088}
.CodeRay .regexp .delimiter{color:#808}
.CodeRay .regexp .content{color:#808}
.CodeRay .regexp .modifier{color:#808}
.CodeRay .regexp .char{color:#d14}
.CodeRay .regexp .function{color:#404;font-weight:bold}
.CodeRay .string{color:#d20}
.CodeRay .string .string .string{background:#ffd0d0}
.CodeRay .string .content{color:#d14}
.CodeRay .string .char{color:#d14}
.CodeRay .string .delimiter{color:#d14}
.CodeRay .shell{color:#d14}
.CodeRay .shell .delimiter{color:#d14}
.CodeRay .symbol{color:#990073}
.CodeRay .symbol .content{color:#a60}
.CodeRay .symbol .delimiter{color:#630}
.CodeRay .tag{color:#008080}
.CodeRay .tag-special{color:#d70}
.CodeRay .variable{color:#036}
.CodeRay .insert{background:#afa}
.CodeRay .delete{background:#faa}
.CodeRay .change{color:#aaf;background:#007}
.CodeRay .head{color:#f8f;background:#505}
.CodeRay .insert .insert{color:#080}
.CodeRay .delete .delete{color:#800}
.CodeRay .change .change{color:#66f}
.CodeRay .head .head{color:#f4f}
</style>
</body>
</html>